/*! For license information please see web-python-kernel.min.mjs.LICENSE.txt */
var e={590:(e,t,r)=>{r.d(t,{LV:()=>p});const n=Symbol("Comlink.proxy"),o=Symbol("Comlink.endpoint"),s=Symbol("Comlink.releaseProxy"),i=Symbol("Comlink.finalizer"),a=Symbol("Comlink.thrown"),l=e=>"object"==typeof e&&null!==e||"function"==typeof e,c=new Map([["proxy",{canHandle:e=>l(e)&&e[n],serialize(e){const{port1:t,port2:r}=new MessageChannel;return u(e,t),[r,[r]]},deserialize:e=>(e.start(),p(e))}],["throw",{canHandle:e=>l(e)&&a in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function u(e,t=globalThis,r=["*"]){t.addEventListener("message",function o(s){if(!s||!s.data)return;if(!function(e,t){for(const r of e){if(t===r||"*"===r)return!0;if(r instanceof RegExp&&r.test(t))return!0}return!1}(r,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:l,type:c,path:p}=Object.assign({path:[]},s.data),m=(s.data.argumentList||[]).map(v);let h;try{const t=p.slice(0,-1).reduce((e,t)=>e[t],e),r=p.reduce((e,t)=>e[t],e);switch(c){case"GET":h=r;break;case"SET":t[p.slice(-1)[0]]=v(s.data.value),h=!0;break;case"APPLY":h=r.apply(t,m);break;case"CONSTRUCT":h=function(e){return Object.assign(e,{[n]:!0})}(new r(...m));break;case"ENDPOINT":{const{port1:t,port2:r}=new MessageChannel;u(e,r),h=function(e,t){return w.set(e,t),e}(t,[t])}break;case"RELEASE":h=void 0;break;default:return}}catch(e){h={value:e,[a]:0}}Promise.resolve(h).catch(e=>({value:e,[a]:0})).then(r=>{const[n,s]=k(r);t.postMessage(Object.assign(Object.assign({},n),{id:l}),s),"RELEASE"===c&&(t.removeEventListener("message",o),d(t),i in e&&"function"==typeof e[i]&&e[i]())}).catch(e=>{const[r,n]=k({value:new TypeError("Unserializable return value"),[a]:0});t.postMessage(Object.assign(Object.assign({},r),{id:l}),n)})}),t.start&&t.start()}function d(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function p(e,t){const r=new Map;return e.addEventListener("message",function(e){const{data:t}=e;if(!t||!t.id)return;const n=r.get(t.id);if(n)try{n(t)}finally{r.delete(t.id)}}),g(e,r,[],t)}function m(e){if(e)throw new Error("Proxy has been released and is not useable")}function h(e){return x(e,new Map,{type:"RELEASE"}).then(()=>{d(e)})}const y=new WeakMap,f="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const t=(y.get(e)||0)-1;y.set(e,t),0===t&&h(e)});function g(e,t,r=[],n=function(){}){let i=!1;const a=new Proxy(n,{get(n,o){if(m(i),o===s)return()=>{!function(e){f&&f.unregister(e)}(a),h(e),t.clear(),i=!0};if("then"===o){if(0===r.length)return{then:()=>a};const n=x(e,t,{type:"GET",path:r.map(e=>e.toString())}).then(v);return n.then.bind(n)}return g(e,t,[...r,o])},set(n,o,s){m(i);const[a,l]=k(s);return x(e,t,{type:"SET",path:[...r,o].map(e=>e.toString()),value:a},l).then(v)},apply(n,s,a){m(i);const l=r[r.length-1];if(l===o)return x(e,t,{type:"ENDPOINT"}).then(v);if("bind"===l)return g(e,t,r.slice(0,-1));const[c,u]=E(a);return x(e,t,{type:"APPLY",path:r.map(e=>e.toString()),argumentList:c},u).then(v)},construct(n,o){m(i);const[s,a]=E(o);return x(e,t,{type:"CONSTRUCT",path:r.map(e=>e.toString()),argumentList:s},a).then(v)}});return function(e,t){const r=(y.get(t)||0)+1;y.set(t,r),f&&f.register(e,t,e)}(a,e),a}function E(e){const t=e.map(k);return[t.map(e=>e[0]),(r=t.map(e=>e[1]),Array.prototype.concat.apply([],r))];var r}const w=new WeakMap;function k(e){for(const[t,r]of c)if(r.canHandle(e)){const[n,o]=r.serialize(e);return[{type:"HANDLER",name:t,value:n},o]}return[{type:"RAW",value:e},w.get(e)||[]]}function v(e){switch(e.type){case"HANDLER":return c.get(e.name).deserialize(e.value);case"RAW":return e.value}}function x(e,t,r,n){return new Promise(o=>{const s=new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-");t.set(s,o),e.start&&e.start(),e.postMessage(Object.assign({id:s},r),n)})}},696:(e,t,r)=>{var n;r.d(t,{z:()=>n}),function(e){e.STREAM="stream",e.DISPLAY_DATA="display_data",e.UPDATE_DISPLAY_DATA="update_display_data",e.EXECUTE_RESULT="execute_result",e.EXECUTE_ERROR="execute_error",e.EXECUTE_REQUEST="execute_request",e.INPUT_REQUEST="input_request",e.CLEAR_OUTPUT="clear_output",e.COMM_OPEN="comm_open",e.COMM_MSG="comm_msg",e.COMM_CLOSE="comm_close",e.KERNEL_READY="kernel_ready",e.KERNEL_BUSY="kernel_busy",e.KERNEL_IDLE="kernel_idle",e.ALL="*",e.EXECUTION_STALLED="execution_stalled",e.KERNEL_UNRECOVERABLE="kernel_unrecoverable",e.EXECUTION_INTERRUPTED="execution_interrupted",e.KERNEL_RESTARTED="kernel_restarted",e.KERNEL_TERMINATED="kernel_terminated"}(n||(n={}))}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var n={};r.d(n,{MB:()=>h,zZ:()=>c.z,y9:()=>l,dR:()=>p,J9:()=>a});const o="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js";let s=!1,i=null;var a,l,c=r(696),u=r(590);class d{constructor(){this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}off(e,t){if(!this.events[e])return;const r=this.events[e].indexOf(t);r>-1&&this.events[e].splice(r,1)}removeListener(e,t){this.off(e,t)}emit(e,...t){this.events[e]&&this.events[e].forEach(e=>e(...t))}setMaxListeners(e){}}!function(e){e.MAIN_THREAD="main_thread",e.WORKER="worker"}(a||(a={})),function(e){e.PYTHON="python"}(l||(l={}));class p extends d{resolveWorkerUrl(){if(this.workerUrl)return this.workerUrl;if("undefined"!=typeof window&&window.location){const e=document.currentScript||Array.from(document.getElementsByTagName("script")).pop();if(e&&e.src){const t=new URL(e.src),r=t.href.substring(0,t.href.lastIndexOf("/"));return t.hostname.includes("jsdelivr.net")||t.hostname.includes("unpkg.com")||t.hostname.includes("cdnjs.cloudflare.com"),`${r}/kernel.worker.js`}return`${window.location.origin+window.location.pathname.substring(0,window.location.pathname.lastIndexOf("/"))}/dist/kernel.worker.js`}return"./kernel.worker.js"}isKeyboardInterrupt(e){return e&&"object"==typeof e&&("type"in e&&"KeyboardInterrupt"===e.type||"message"in e&&"string"==typeof e.message&&e.message.includes("KeyboardInterrupt"))}createKeyboardInterruptResult(){return{success:!1,error:new Error("KeyboardInterrupt: Execution interrupted by user"),result:{status:"error",ename:"KeyboardInterrupt",evalue:"Execution interrupted by user",traceback:["KeyboardInterrupt: Execution interrupted by user"]}}}storeAbortController(e,t,r){this.abortControllers.has(e)||this.abortControllers.set(e,new Map),this.abortControllers.get(e).set(t,r)}removeAbortController(e,t){const r=this.abortControllers.get(e);if(!r)return;const n=r.get(t);return n&&(r.delete(t),0===r.size&&this.abortControllers.delete(e)),n}abortAllKernelOperations(e){const t=this.abortControllers.get(e);if(t){for(const[r,n]of t)try{n.abort(),console.log(`üö´ Aborted execution ${r} for kernel ${e}`)}catch(e){console.warn(`‚ö†Ô∏è Error aborting execution ${r}:`,e)}this.abortControllers.delete(e)}}constructor(e={}){super(),this.kernels=new Map,this.listenerWrappers=new Map,this.lastActivityTime=new Map,this.inactivityTimers=new Map,this.ongoingExecutions=new Map,this.executionTimeouts=new Map,this.executionStartTimes=new Map,this.executionMetadata=new Map,this.abortControllers=new Map,this.pool=new Map,this.isPreloading=!1,this.prefillingInProgress=new Map,this.interruptBuffers=new Map,super.setMaxListeners(100),this.interruptionMode=e.interruptionMode||"auto",this.workerUrl=e.workerUrl,this.allowedKernelTypes=e.allowedKernelTypes||[{mode:a.WORKER,language:l.PYTHON}];const t=this.allowedKernelTypes.filter(e=>e.language===l.PYTHON);this.poolConfig={enabled:!1,poolSize:2,autoRefill:!0,preloadConfigs:t,...e.pool},this.poolConfig.preloadConfigs&&(this.poolConfig.preloadConfigs=this.poolConfig.preloadConfigs.filter(e=>{const t=this.isKernelTypeAllowed(e.mode,e.language);return t||console.warn(`Pool preload config ${e.mode}-${e.language} is not in allowedKernelTypes, skipping`),t})),this.poolConfig.enabled&&this.preloadPool().catch(e=>{console.error("Error preloading kernel pool:",e)})}getPoolKey(e,t){return`${e}-${t}`}getFromPool(e,t){if(!this.poolConfig.enabled)return null;const r=this.getPoolKey(e,t),n=this.pool.get(r);if(!n||0===n.length)return null;const o=n.shift();return this.poolConfig.autoRefill&&setTimeout(()=>{this.refillPoolSingle(e,t).catch(e=>{console.error(`Error refilling single kernel for ${r}:`,e)})},0),o}addToPool(e,t,r){if(!this.poolConfig.enabled)return;const n=this.getPoolKey(e,t);this.pool.has(n)||this.pool.set(n,[]);const o=this.pool.get(n);o.length<this.poolConfig.poolSize?(o.push(r),r.catch(e=>{console.error(`Pool kernel promise rejected for ${n}:`,e);const t=o.indexOf(r);-1!==t&&o.splice(t,1)})):r.then(e=>{e.destroy().catch(e=>{console.error("Error destroying excess pool kernel:",e)})}).catch(e=>{console.error("Excess pool kernel promise rejected:",e)})}async refillPoolSingle(e,t){if(!this.poolConfig.enabled)return;const r=this.getPoolKey(e,t);if((this.pool.get(r)||[]).length<this.poolConfig.poolSize){const r=this.createPoolKernelPromise(e,t);this.addToPool(e,t,r)}}async refillPool(e,t){if(!this.poolConfig.enabled)return;const r=this.getPoolKey(e,t);if(!this.prefillingInProgress.get(r)){this.prefillingInProgress.set(r,!0);try{const n=this.pool.get(r)||[],o=this.poolConfig.poolSize-n.length;if(o<=0)return;const s=Array.from({length:o},()=>this.createPoolKernelPromise(e,t));for(const r of s)this.addToPool(e,t,r)}catch(e){console.error(`Error refilling pool for ${r}:`,e)}finally{this.prefillingInProgress.set(r,!1)}}}createPoolKernelPromise(e,t){return new Promise(async(r,n)=>{try{const n=await this.createPoolKernel(e,t);n.isFromPool=!0,r(n)}catch(r){console.error(`Error creating pool kernel for ${e}-${t}:`,r),n(r)}})}async createPoolKernel(e,t){const r=`pool-${crypto.randomUUID()}`,n={mode:e,lang:t};let o;try{if(e===a.MAIN_THREAD){const s={id:r,options:n,mode:e,language:t};this.kernels.set(r,s);try{o=await this.createMainThreadKernel(r)}finally{this.kernels.delete(r)}}else{const s={id:r,options:n,mode:e,language:t};this.kernels.set(r,s);try{o=await this.createWorkerKernel(r)}finally{this.kernels.delete(r)}}}catch(e){throw this.kernels.delete(r),e}return o}async preloadPool(){if(this.poolConfig.enabled&&!this.isPreloading){this.isPreloading=!0;try{for(const e of this.poolConfig.preloadConfigs)try{await this.refillPool(e.mode,e.language)}catch(t){console.error(`Error preloading ${e.mode}-${e.language}:`,t)}}catch(e){console.error("Error during kernel pool preloading:",e)}finally{this.isPreloading=!1}}}canUsePool(e){return!!this.poolConfig.enabled&&!e.filesystem&&!e.deno?.permissions&&void 0===e.inactivityTimeout&&void 0===e.maxExecutionTime}reassignPoolKernel(e,t,r){const n={id:t,kernel:e.kernel,mode:e.mode,language:e.language,worker:e.worker,created:(new Date).toISOString(),options:{...e.options,...r},isFromPool:!0,destroy:e.destroy};if("function"!=typeof n.destroy)throw console.error("Failed to preserve destroy function during pool kernel reassignment"),console.error("poolKernel.destroy type:",typeof e.destroy),console.error("updatedInstance.destroy type:",typeof n.destroy),new Error("Failed to preserve destroy function during pool kernel reassignment");return n}getPoolStats(){const e={};for(const[t,r]of this.pool.entries())e[t]={available:r.length,total:this.poolConfig.poolSize};return e}getPoolConfig(){return{enabled:this.poolConfig.enabled,poolSize:this.poolConfig.poolSize,autoRefill:this.poolConfig.autoRefill,preloadConfigs:[...this.poolConfig.preloadConfigs],isPreloading:this.isPreloading}}getWorkerUrl(){return this.workerUrl}setWorkerUrl(e){this.workerUrl=e}async createKernel(e={}){if(e.id&&e.id.includes(":"))throw new Error("Kernel ID cannot contain colons");const t=e.id||crypto.randomUUID(),r=e.mode||a.WORKER,n=e.lang||l.PYTHON;if(!this.isKernelTypeAllowed(r,n))throw new Error(`Kernel type ${r}-${n} is not allowed. Allowed types: ${this.allowedKernelTypes.map(e=>`${e.mode}-${e.language}`).join(", ")}`);const o=e.namespace?`${e.namespace}:${t}`:t;if(this.kernels.has(o))throw new Error(`Kernel with ID ${o} already exists`);if(this.canUsePool(e)){const t=this.getPoolKey(r,n);if(this.poolConfig.preloadConfigs.some(e=>e.mode===r&&e.language===n)){let s=this.getFromPool(r,n);if(s)return await this.setupPoolKernelFromPromise(s,o,e);try{const s=this.createPoolKernelPromise(r,n);return this.poolConfig.autoRefill&&setTimeout(()=>{this.refillPool(r,n).catch(e=>{console.error(`Error refilling exhausted pool for ${t}:`,e)})},0),await this.setupPoolKernelFromPromise(s,o,e)}catch(e){console.error(`Failed to create kernel promise for exhausted pool: ${e}`)}}else{const t=this.getFromPool(r,n);if(t)return await this.setupPoolKernelFromPromise(t,o,e)}}return this.createOnDemandKernel(o,r,n,e)}async setupPoolKernelFromPromise(e,t,r){try{const n=await e,o=this.reassignPoolKernel(n,t,r);if(o.mode===a.WORKER&&o.worker){const e=o.worker,{port1:r,port2:n}=new MessageChannel;e.postMessage({type:"SET_EVENT_PORT",port:n},[n]);const s=e=>{e.data&&e.data.type&&super.emit(e.data.type,{kernelId:t,data:e.data.data})};r.addEventListener("message",s),r.start();const i=o.destroy;o.destroy=async()=>(r.removeEventListener("message",s),r.close(),i())}return this.kernels.set(t,o),this.setupEventForwarding(o),this.updateKernelActivity(t),r.inactivityTimeout&&r.inactivityTimeout>0&&this.setupInactivityTimeout(t,r.inactivityTimeout),r.maxExecutionTime&&r.maxExecutionTime>0&&this.setupStalledExecutionHandler(t),t}catch(e){throw console.error(`Error setting up pool kernel ${t}:`,e),super.emit(c.z.EXECUTE_ERROR,{kernelId:t,data:{ename:"KernelSetupError",evalue:`Failed to setup kernel: ${e instanceof Error?e.message:String(e)}`,traceback:[e instanceof Error?e.stack||e.message:String(e)]}}),e}}setupPoolKernel(e,t,r){const n=this.reassignPoolKernel(e,t,r);if(n.mode===a.WORKER&&n.worker){const e=n.worker,{port1:r,port2:o}=new MessageChannel;e.postMessage({type:"SET_EVENT_PORT",port:o},[o]);const s=e=>{e.data&&e.data.type&&super.emit(e.data.type,{kernelId:t,data:e.data.data})};r.addEventListener("message",s),r.start();const i=n.destroy;n.destroy=async()=>(r.removeEventListener("message",s),r.close(),i())}return this.kernels.set(t,n),this.setupEventForwarding(n),this.updateKernelActivity(t),r.inactivityTimeout&&r.inactivityTimeout>0&&this.setupInactivityTimeout(t,r.inactivityTimeout),r.maxExecutionTime&&r.maxExecutionTime>0&&this.setupStalledExecutionHandler(t),t}async createOnDemandKernel(e,t,r,n){const o={id:e,options:{...n,lang:r},mode:t,language:r};let s;return this.kernels.set(e,o),s=t===a.MAIN_THREAD?await this.createMainThreadKernel(e):await this.createWorkerKernel(e),this.kernels.set(e,s),this.setupEventForwarding(s),this.updateKernelActivity(e),n.inactivityTimeout&&n.inactivityTimeout>0&&this.setupInactivityTimeout(e,n.inactivityTimeout),n.maxExecutionTime&&n.maxExecutionTime>0&&this.setupStalledExecutionHandler(e),e}async createMainThreadKernel(e){const t=this.kernels.get(e)?.options||{},r=t.lang||l.PYTHON,n=new h,o={id:e,kernel:n,mode:a.MAIN_THREAD,language:r,created:(new Date).toISOString(),options:t,destroy:async()=>Promise.resolve()},s={};return t.filesystem&&(s.filesystem=t.filesystem),t.env&&(s.env=t.env),t.lockFileURL&&(s.lockFileURL=t.lockFileURL),void 0!==t.autoSyncFs&&(s.autoSyncFs=t.autoSyncFs),await n.initialize(s),o}async createWorkerKernel(e){const t=this.kernels.get(e)?.options||{},r=t.lang||l.PYTHON;t.deno?.permissions&&t.deno.permissions;const n=this.resolveWorkerUrl(),o=new Worker(n,{type:"classic"}),{port1:s,port2:i}=new MessageChannel,c=new Promise((e,t)=>{const r=n=>{"KERNEL_INITIALIZED"===n.data?.type&&(n.data.data.success?(s.removeEventListener("message",r),e()):(s.removeEventListener("message",r),t(new Error("Kernel initialization failed"))))};s.addEventListener("message",r)});o.postMessage({type:"SET_EVENT_PORT",port:i},[i]);const d=u.LV(o),p=t=>{t.data&&t.data.type&&super.emit(t.data.type,{kernelId:e,data:t.data.data})};return s.addEventListener("message",p),s.start(),o.postMessage({type:"INITIALIZE_KERNEL",options:{filesystem:t.filesystem,env:t.env,lockFileURL:t.lockFileURL,autoSyncFs:t.autoSyncFs,lang:r}}),await c,await this.setupWorkerInterruptBuffer(e,o),{id:e,kernel:{initialize:async e=>d.initialize(e),execute:async(e,t)=>await d.execute(e,t),isInitialized:()=>d.isInitialized(),inputReply:async e=>d.inputReply(e),getStatus:async()=>{try{return"function"==typeof d.getStatus?await d.getStatus():"unknown"}catch(e){return"unknown"}},complete:async(e,t,r)=>{try{return"function"==typeof d.complete?await d.complete(e,t,r):{status:"error",error:"Completion not supported"}}catch(e){return{status:"error",error:String(e)}}},inspect:async(e,t,r,n)=>{try{return"function"==typeof d.inspect?await d.inspect(e,t,r,n):{status:"error",error:"Inspection not supported"}}catch(e){return{status:"error",error:String(e)}}},isComplete:async(e,t)=>{try{return"function"==typeof d.isComplete?await d.isComplete(e,t):{status:"unknown"}}catch(e){return{status:"error",error:String(e)}}},interrupt:async()=>{try{return"function"==typeof d.interrupt&&await d.interrupt()}catch(e){return!1}},setInterruptBuffer:e=>{try{"function"==typeof d.setInterruptBuffer&&d.setInterruptBuffer(e)}catch(e){console.warn("Failed to set interrupt buffer:",e)}},mountFS:async(e,t,r)=>{try{if("function"==typeof d.mountFS)return await d.mountFS(e,t,r);throw new Error("mountFS is not supported by this kernel")}catch(e){throw e}},getMountedFileSystems:()=>{try{return"function"==typeof d.getMountedFileSystems?d.getMountedFileSystems():[]}catch(e){return console.warn("Failed to get mounted filesystems:",e),[]}},syncFileSystem:async e=>{try{return"function"==typeof d.syncFileSystem?await d.syncFileSystem(e):{success:!1,error:"syncFileSystem is not supported by this kernel"}}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e)}}},upgradeFileSystemPermission:async e=>{try{return"function"==typeof d.upgradeFileSystemPermission?await d.upgradeFileSystemPermission(e):{success:!1,error:"upgradeFileSystemPermission is not supported by this kernel"}}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e)}}},commInfo:async(e,t)=>{try{return"function"==typeof d.commInfo?await d.commInfo(e,t):{comms:{},status:"ok"}}catch(e){return{comms:{},status:"error",error:String(e)}}},commOpen:async(e,t)=>{try{if("function"==typeof d.commOpen)return await d.commOpen(e,t)}catch(e){console.warn("Failed to open comm:",e)}},commMsg:async(e,t)=>{try{if("function"==typeof d.commMsg)return await d.commMsg(e,t)}catch(e){console.warn("Failed to send comm message:",e)}},commClose:async(e,t)=>{try{if("function"==typeof d.commClose)return await d.commClose(e,t)}catch(e){console.warn("Failed to close comm:",e)}}},mode:a.WORKER,language:r,worker:o,created:(new Date).toISOString(),options:t,destroy:async()=>(s.removeEventListener("message",p),s.close(),o.terminate(),Promise.resolve())}}setupEventForwarding(e){e.mode===a.MAIN_THREAD&&Object.values(c.z).forEach(t=>{e.kernel.on(t,r=>{super.emit(t,{kernelId:e.id,data:r})})})}getKernel(e){return this.kernels.get(e)}getKernelIds(){return Array.from(this.kernels.keys())}async listKernels(e){const t=Array.from(this.kernels.entries()).filter(([t])=>!t.startsWith("pool-")&&(!e||t.startsWith(`${e}:`)));return await Promise.all(t.map(async([e,t])=>{const r=e.match(/^([^:]+):/),n=r?r[1]:void 0;let o="unknown";try{t&&t.kernel&&"function"==typeof t.kernel.getStatus&&(o=await t.kernel.getStatus())}catch(t){console.warn(`Error getting status for kernel ${e}:`,t),o="unknown"}return{id:e,mode:t.mode,language:t.language,status:o,created:t.created||(new Date).toISOString(),namespace:n,deno:t.options?.deno}}))}async destroyKernel(e){const t=this.kernels.get(e);if(t){if("function"!=typeof t.destroy)throw new Error(`Kernel ${e} is missing destroy function (type: ${typeof t.destroy})`);if(this.abortAllKernelOperations(e),this.clearInactivityTimeout(e),this.executionTimeouts.has(e)){const t=this.executionTimeouts.get(e);for(const e of t.values())clearTimeout(e);this.executionTimeouts.delete(e)}this.executionStartTimes.has(e)&&this.executionStartTimes.delete(e),this.executionMetadata.has(e)&&this.executionMetadata.delete(e),this.interruptBuffers.has(e)&&this.interruptBuffers.delete(e),this.ongoingExecutions.delete(e),this.lastActivityTime.delete(e),this.removeAllKernelListeners(e),await t.destroy(),this.kernels.delete(e)}}async destroyAll(e){const t=Array.from(this.kernels.keys()).filter(t=>!e||t.startsWith(`${e}:`)).map(async e=>{const t=this.kernels.get(e);return t&&"function"==typeof t.destroy?this.destroyKernel(e):(console.warn(`Skipping incomplete kernel instance ${e} during destroyAll`),void this.kernels.delete(e))});await Promise.all(t),e||await this.destroyPool()}async destroyPool(){const e=[];for(const[t,r]of this.pool.entries())for(const t of r){const r=t.then(e=>e.destroy()).catch(e=>{console.error("Error destroying pool kernel from promise:",e)});e.push(r)}await Promise.all(e),this.pool.clear(),this.prefillingInProgress.clear()}onKernelEvent(e,t,r){if(!this.kernels.has(e))throw new Error(`Kernel with ID ${e} not found`);const n={original:r,wrapped:t=>{t.kernelId===e&&r(t.data)}};this.storeListener(e,t,r,n),super.on(t,n.wrapped)}offKernelEvent(e,t,r){const n=this.getListener(e,t,r);n&&(super.removeListener(t,n.wrapped),this.removeStoredListener(e,t,r))}storeListener(e,t,r,n){this.listenerWrappers.has(e)||this.listenerWrappers.set(e,new Map);const o=this.listenerWrappers.get(e);o.has(t)||o.set(t,new Map),o.get(t).set(r,n)}getListener(e,t,r){const n=this.listenerWrappers.get(e);if(!n)return;const o=n.get(t);return o?o.get(r):void 0}removeStoredListener(e,t,r){const n=this.listenerWrappers.get(e);if(!n)return;const o=n.get(t);o&&(o.delete(r),0===o.size&&n.delete(t),0===n.size&&this.listenerWrappers.delete(e))}removeAllKernelListeners(e){const t=this.listenerWrappers.get(e);if(t){for(const[e,r]of t.entries())for(const t of r.values())super.removeListener(e,t.wrapped);this.listenerWrappers.delete(e)}}getListeners(e,t){const r=this.listenerWrappers.get(e);if(!r)return[];const n=r.get(t);return n?Array.from(n.keys()):[]}async*executeStream(e,t,r={}){const n=this.getKernel(e);if(!n)throw new Error(`Kernel with ID ${e} not found`);this.updateKernelActivity(e);const o=this.trackExecution(e,t),s=new AbortController;this.storeAbortController(e,o,s);try{if(n.mode===a.MAIN_THREAD){const s=n.kernel;if("function"==typeof s.executeStream)try{return yield*s.executeStream(t,r),this.updateKernelActivity(e),this.completeExecution(e,o),{success:!0}}catch(t){return console.error("Error in main thread executeStream:",t),this.updateKernelActivity(e),this.completeExecution(e,o),{success:!1,error:t instanceof Error?t:new Error(String(t))}}}try{const i=[];let a=!1,l={success:!0};const u=new Map,d=()=>{for(const[e,t]of u.entries())super.off(e,t);u.clear()},p=t=>{const r=r=>{r.kernelId!==e||a||(i.push({type:t,data:r.data,executionId:o}),this.updateKernelActivity(e))};return u.set(t,r),r},m=p("stream"),h=p("display_data"),y=p("update_display_data"),f=p("execute_result"),g=p("execute_error");super.on(c.z.STREAM,m),super.on(c.z.DISPLAY_DATA,h),super.on(c.z.UPDATE_DISPLAY_DATA,y),super.on(c.z.EXECUTE_RESULT,f),super.on(c.z.EXECUTE_ERROR,g);const E=new Promise((d,p)=>{const m=t=>{t.kernelId!==e||a||(a=!0,l={success:!1,error:new Error(`${t.data.ename}: ${t.data.evalue}`),result:t.data},this.updateKernelActivity(e),d(l))};if(u.set("execute_error_completion",m),super.on(c.z.EXECUTE_ERROR,m),s.signal.aborted)return a=!0,void d({success:!1,error:new Error("Execution was aborted")});s.signal.addEventListener("abort",()=>{a||(console.log(`üö´ Execution ${o} aborted`),a=!0,d({success:!1,error:new Error("Execution was aborted")}))});try{n.kernel.execute(t,r).then(t=>{if(!a){if(t.success&&t.result&&"error"===t.result.status){const e={status:t.result.status,ename:t.result.ename,evalue:t.result.evalue,traceback:t.result.traceback};i.push({type:"error",data:e,executionId:o}),l={success:!1,error:new Error(`${t.result.ename}: ${t.result.evalue}`),result:t.result}}else l=t;a=!0,this.updateKernelActivity(e),d(l)}}).catch(t=>{if(!a){let r;console.error(`Error in execute for kernel ${e}:`,t),this.isKeyboardInterrupt(t)?(console.log(`KeyboardInterrupt caught in executeStream for kernel ${e}`),r=this.createKeyboardInterruptResult(),i.push({type:"error",data:r.result,executionId:o})):r={success:!1,error:t instanceof Error?t:new Error(String(t))},a=!0,l=r,this.updateKernelActivity(e),d(r)}})}catch(t){if(!a){console.error(`Error calling execute for kernel ${e}:`,t);const r={success:!1,error:t instanceof Error?t:new Error(String(t))};a=!0,l=r,this.updateKernelActivity(e),d(r)}}});try{for(;(!a||i.length>0)&&!s.signal.aborted;){if(i.length>0){const e=i.shift();yield e;continue}if(!a)try{await new Promise((e,t)=>{const r=setTimeout(e,10);s.signal.addEventListener("abort",()=>{clearTimeout(r),t(new Error("Aborted"))})})}catch(e){if(s.signal.aborted)break}}if(s.signal.aborted&&!a)throw new Error("Execution was aborted during stream monitoring");return await E}finally{d(),this.removeAbortController(e,o),this.completeExecution(e,o)}}catch(t){return this.completeExecution(e,o),console.error("Unexpected error in executeStream:",t),{success:!1,error:t instanceof Error?t:new Error(String(t))}}}catch(t){return this.completeExecution(e,o),console.error("Unexpected error in executeStream:",t),{success:!1,error:t instanceof Error?t:new Error(String(t))}}}trackExecution(e,t){const r=`exec-${crypto.randomUUID()}`,n=Date.now(),o=this.kernels.get(e);if(o&&o.mode===a.WORKER&&this.interruptBuffers.has(e)&&(this.interruptBuffers.get(e)[0]=0),this.ongoingExecutions.has(e)||this.ongoingExecutions.set(e,new Set),this.ongoingExecutions.get(e).add(r),this.executionStartTimes.has(e)||this.executionStartTimes.set(e,new Map),this.executionStartTimes.get(e).set(r,n),this.executionMetadata.has(e)||this.executionMetadata.set(e,new Map),this.updateKernelActivity(e),o&&o.options.maxExecutionTime&&o.options.maxExecutionTime>0){this.executionTimeouts.has(e)||this.executionTimeouts.set(e,new Map);const s=setTimeout(()=>{console.warn(`Execution ${r} on kernel ${e} has been running for ${o.options.maxExecutionTime}ms and may be stuck/dead.`);const s=this.executionMetadata.get(e)?.get(r),i=Date.now()-(s?.startTime||n);super.emit("execution_stalled",{kernelId:e,executionId:r,maxExecutionTime:o.options.maxExecutionTime,actualRuntime:i,code:s?.code||t,startTime:s?.startTime||n}),this.handleStuckExecution(e,r,i,s?.code||t)},o.options.maxExecutionTime);this.executionTimeouts.get(e).set(r,s),this.executionMetadata.get(e).set(r,{startTime:n,code:t,timeoutId:s})}else this.executionMetadata.get(e).set(r,{startTime:n,code:t});return r}completeExecution(e,t){if(this.executionTimeouts.has(e)){const r=this.executionTimeouts.get(e);r.has(t)&&(clearTimeout(r.get(t)),r.delete(t)),0===r.size&&this.executionTimeouts.delete(e)}if(this.executionStartTimes.has(e)){const r=this.executionStartTimes.get(e);r.delete(t),0===r.size&&this.executionStartTimes.delete(e)}if(this.executionMetadata.has(e)){const r=this.executionMetadata.get(e);r.delete(t),0===r.size&&this.executionMetadata.delete(e)}if(this.ongoingExecutions.has(e)){const r=this.ongoingExecutions.get(e);r.delete(t),0===r.size&&(this.ongoingExecutions.delete(e),this.updateKernelActivity(e))}}hasOngoingExecutions(e){return this.ongoingExecutions.has(e)&&this.ongoingExecutions.get(e).size>0}getOngoingExecutionCount(e){return this.ongoingExecutions.has(e)?this.ongoingExecutions.get(e).size:0}setupInactivityTimeout(e,t){if(t<=0)return;this.clearInactivityTimeout(e);const r=this.lastActivityTime.get(e)||Date.now(),n=Date.now()-r,o=Math.max(0,t-n);if(0===o)return this.hasOngoingExecutions(e)?void this.setupInactivityTimeout(e,t):void this.destroyKernel(e).catch(t=>{console.error(`Error destroying inactive kernel ${e}:`,t)});const s=setTimeout(()=>{this.hasOngoingExecutions(e)?this.setupInactivityTimeout(e,t):this.destroyKernel(e).catch(t=>{console.error(`Error destroying inactive kernel ${e}:`,t)})},o);this.inactivityTimers.set(e,s)}clearInactivityTimeout(e){if(this.inactivityTimers.has(e)){const t=this.inactivityTimers.get(e);clearTimeout(t),this.inactivityTimers.delete(e)}}updateKernelActivity(e){this.lastActivityTime.set(e,Date.now());const t=this.kernels.get(e);if(!t)return;const r=t.options.inactivityTimeout;r&&r>0&&this.setupInactivityTimeout(e,r)}getLastActivityTime(e){return this.lastActivityTime.get(e)}getInactivityTimeout(e){const t=this.kernels.get(e);if(t)return t.options.inactivityTimeout}setInactivityTimeout(e,t){const r=this.kernels.get(e);return!!r&&(r.options.inactivityTimeout=t,this.clearInactivityTimeout(e),t>0&&this.setupInactivityTimeout(e,t),!0)}getTimeUntilShutdown(e){const t=this.kernels.get(e);if(!t)return;const r=t.options.inactivityTimeout;if(!r||r<=0)return;const n=this.lastActivityTime.get(e);if(!n)return;const o=r-(Date.now()-n);return Math.max(0,o)}getInactivityTimers(){const e={};return this.inactivityTimers.forEach((t,r)=>{e[r]=t}),e}setupStalledExecutionHandler(e){super.on(c.z.EXECUTION_STALLED,t=>{t.kernelId===e&&(console.warn(`Handling stalled execution ${t.executionId} on kernel ${e} (running longer than ${t.maxExecutionTime}ms)`),this.kernels.get(e)&&super.emit(c.z.EXECUTE_ERROR,{kernelId:e,data:{ename:"ExecutionStalledError",evalue:`Execution stalled or potentially deadlocked (running > ${t.maxExecutionTime}ms)`,traceback:["Execution may be stuck in an infinite loop or deadlocked."]}}))})}async forceTerminateKernel(e,t="Force terminated due to stalled execution"){if(!this.kernels.get(e))return!1;try{return console.warn(`Force terminating kernel ${e}: ${t}`),super.emit(c.z.EXECUTE_ERROR,{kernelId:e,data:{ename:"KernelForcedTermination",evalue:t,traceback:["Kernel was forcefully terminated by the system."]}}),await this.destroyKernel(e),!0}catch(t){return console.error(`Error during forced termination of kernel ${e}:`,t),!1}}getExecutionInfo(e){const t=this.kernels.get(e);if(!t)return{count:0,isStuck:!1,executionIds:[],executions:[]};if(!t.options)return{count:0,isStuck:!1,executionIds:[],executions:[]};const r=this.ongoingExecutions.get(e)?Array.from(this.ongoingExecutions.get(e)):[],n=r.length,o=Date.now(),s=t.options.maxExecutionTime,i=[];let a,l=!1;const c=this.executionStartTimes.get(e),u=this.executionMetadata.get(e);for(const t of r){const r=c?.get(t),n=u?.get(t);if(void 0!==r){const e=o-r,c=void 0!==s&&e>s;i.push({id:t,startTime:r,runtime:e,code:n?.code,isStuck:c}),(void 0===a||e>a)&&(a=e),c&&(l=!0)}else console.warn(`No start time found for execution ${t} on kernel ${e}`),i.push({id:t,startTime:0,runtime:0,code:n?.code,isStuck:!1})}return i.sort((e,t)=>e.startTime-t.startTime),{count:n,isStuck:l,executionIds:r,longestRunningTime:a,executions:i}}async execute(e,t,r={}){const n=this.getKernel(e);if(!n)throw new Error(`Kernel with ID ${e} not found`);return await n.kernel.execute(t,r)}isKernelTypeAllowed(e,t){return this.allowedKernelTypes.some(r=>r.mode===e&&r.language===t)}getAllowedKernelTypes(){return[...this.allowedKernelTypes]}pingKernel(e){return!!this.kernels.get(e)&&(this.updateKernelActivity(e),!0)}async restartKernel(e){const t=this.kernels.get(e);if(!t)return console.warn(`Cannot restart kernel ${e}: kernel not found`),!1;try{const r={mode:t.mode,language:t.language,options:{...t.options}};let n,o;if(e.includes(":")){const t=e.split(":");n=t[0],o=t[1]}else o=e;await this.destroyKernel(e);const s={id:o,mode:r.mode,lang:r.language,namespace:n,deno:r.options.deno,filesystem:r.options.filesystem,inactivityTimeout:r.options.inactivityTimeout,maxExecutionTime:r.options.maxExecutionTime},i=await this.createKernel(s);return i===e||(console.error(`Kernel restart failed: expected ID ${e}, got ${i}`),!1)}catch(t){return console.error(`Error restarting kernel ${e}:`,t),!1}}async interruptKernel(e){const t=this.kernels.get(e);if(!t)return console.warn(`Cannot interrupt kernel ${e}: kernel not found`),!1;try{return t.mode===a.WORKER&&t.worker?await this.interruptWorkerKernel(e,t):await this.interruptMainThreadKernel(e,t)}catch(t){return console.error(`Error interrupting kernel ${e}:`,t instanceof Error?t.message:String(t)),!1}}async interruptMainThreadKernel(e,t){throw new Error(`Main thread kernel ${e} does not support reliable interruption. Use worker kernels for interruptible execution.`)}async interruptWorkerKernel(e,t){try{const r=t.worker;if(!r)return console.error(`Worker not found for kernel ${e}`),!1;if("kernel-interrupt"===this.interruptionMode)return await this.interruptWorkerKernelFallback(e,r);let n=this.interruptBuffers.get(e);if(!n)try{const t=new SharedArrayBuffer(1);n=new Uint8Array(t),n[0]=0,this.interruptBuffers.set(e,n),r.postMessage({type:"SET_INTERRUPT_BUFFER",buffer:n}),await new Promise((e,t)=>{const n=setTimeout(()=>{t(new Error("Timeout waiting for interrupt buffer setup"))},2e3),o=t=>{"INTERRUPT_BUFFER_SET"===t.data?.type&&(r.removeEventListener("message",o),clearTimeout(n),e())};r.addEventListener("message",o)}),console.log(`Interrupt buffer set up for kernel ${e}`)}catch(t){if("shared-array-buffer"===this.interruptionMode)throw console.error(`‚ùå Cannot create SharedArrayBuffer for interrupt handling in kernel ${e}`),new Error("SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })");return console.info(`‚ÑπÔ∏è Using message-based interrupt for kernel ${e} (SharedArrayBuffer not available)`),await this.interruptWorkerKernelFallback(e,r)}console.log(`Setting interrupt signal for kernel ${e}...`),n[0]=2;let o=0;const s=50;for(;o<s&&0!==n[0];)await new Promise(e=>setTimeout(e,100)),o++;return 0===n[0]?(console.log(`Interrupt processed successfully for kernel ${e} after ${100*o}ms`),!0):(console.warn(`Interrupt signal not processed for kernel ${e} after ${100*s}ms`),!0)}catch(t){return console.error(`Error interrupting worker kernel ${e}:`,t),!1}}async interruptWorkerKernelFallback(e,t){return new Promise(r=>{const n=e=>{if("INTERRUPT_TRIGGERED"===e.data?.type){t.removeEventListener("message",n);const o=e.data.data?.success||!1;r(o)}};t.addEventListener("message",n),t.postMessage({type:"INTERRUPT_KERNEL"}),setTimeout(()=>{t.removeEventListener("message",n),console.warn(`‚è±Ô∏è Interrupt request timed out for kernel ${e} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`),r(!1)},5e3)})}async handleStuckExecution(e,t,r,n){const o=this.kernels.get(e);if(o){if(console.warn(`Handling stuck execution ${t} on kernel ${e} (runtime: ${r}ms)`),await this.interruptKernel(e))return console.log(`Successfully interrupted kernel ${e}`),void super.emit(c.z.EXECUTE_ERROR,{kernelId:e,data:{ename:"ExecutionInterrupted",evalue:`Execution automatically interrupted after ${r}ms (exceeded maxExecutionTime)`,traceback:["Execution was automatically interrupted due to timeout.",`Runtime: ${r}ms`,`Max allowed: ${o.options.maxExecutionTime}ms`,n?`Code: ${n.substring(0,200)}${n.length>200?"...":""}`:"Code: <unknown>"]}});if(console.warn(`Interrupt failed for kernel ${e}, attempting restart...`),await this.restartKernel(e))return console.log(`Successfully restarted kernel ${e}`),void super.emit(c.z.EXECUTE_ERROR,{kernelId:e,data:{ename:"KernelRestarted",evalue:`Kernel automatically restarted due to stuck execution (runtime: ${r}ms)`,traceback:["Kernel was automatically restarted due to stuck execution.",`Runtime: ${r}ms`,`Max allowed: ${o.options.maxExecutionTime}ms`,"Interrupt attempt failed, kernel was restarted instead.",n?`Code: ${n.substring(0,200)}${n.length>200?"...":""}`:"Code: <unknown>"]}});console.error(`Restart failed for kernel ${e}, force terminating...`),await this.forceTerminateKernel(e,`Stuck execution could not be interrupted or restarted (runtime: ${r}ms)`)?console.log(`Successfully terminated kernel ${e}`):(console.error(`Failed to terminate kernel ${e} - manual intervention may be required`),super.emit("kernel_unrecoverable",{kernelId:e,executionId:t,actualRuntime:r,code:n,message:"Kernel is stuck and could not be recovered through interrupt, restart, or termination"}))}}getStuckExecutions(){const e=[],t=Date.now();for(const[r,n]of this.kernels.entries()){if(r.startsWith("pool-"))continue;if(!n.options?.maxExecutionTime||n.options.maxExecutionTime<=0)continue;const o=n.options.maxExecutionTime,s=this.executionStartTimes.get(r),i=this.executionMetadata.get(r),a=this.ongoingExecutions.get(r);if(a&&0!==a.size)for(const l of a){const a=s?.get(l);if(void 0===a)continue;const c=t-a;if(c>o){const t=i?.get(l);e.push({kernelId:r,executionId:l,startTime:a,runtime:c,maxAllowed:o,code:t?.code,kernelMode:n.mode,kernelLanguage:n.language})}}}return e.sort((e,t)=>t.runtime-e.runtime),e}async handleAllStuckExecutions(){const e=this.getStuckExecutions(),t=[];console.log(`Found ${e.length} stuck executions to handle`);const r=new Map;for(const t of e)r.has(t.kernelId)||r.set(t.kernelId,[]),r.get(t.kernelId).push(t);for(const[e,n]of r)try{const r=n[0];console.log(`Handling stuck kernel ${e} with ${n.length} stuck executions (primary: ${r.runtime}ms)`),await this.handleStuckExecution(e,r.executionId,r.runtime,r.code);for(const e of n)t.push({kernelId:e.kernelId,executionId:e.executionId,action:"interrupted",success:!0})}catch(r){console.error(`Error handling stuck executions for kernel ${e}:`,r);for(const e of n)t.push({kernelId:e.kernelId,executionId:e.executionId,action:"failed",success:!1,error:r instanceof Error?r.message:String(r)})}return t}async setupWorkerInterruptBuffer(e,t){if("kernel-interrupt"!==this.interruptionMode)try{const r=new SharedArrayBuffer(1),n=new Uint8Array(r);n[0]=0,this.interruptBuffers.set(e,n),t.postMessage({type:"SET_INTERRUPT_BUFFER",buffer:n}),await new Promise((e,r)=>{const n=setTimeout(()=>{r(new Error("Timeout waiting for interrupt buffer setup"))},5e3),o=r=>{"INTERRUPT_BUFFER_SET"===r.data?.type&&(t.removeEventListener("message",o),clearTimeout(n),e())};t.addEventListener("message",o)})}catch(t){if("shared-array-buffer"===this.interruptionMode)throw console.error(`‚ùå SharedArrayBuffer required but not available for kernel ${e}`),new Error("SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.");console.info(`‚ÑπÔ∏è SharedArrayBuffer not available for kernel ${e}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`)}else console.log(`Skipping SharedArrayBuffer setup for kernel ${e} - using kernel.interrupt() mode`)}async getMountedFileSystems(e){const t=this.kernels.get(e);if(!t)throw new Error(`Kernel ${e} not found`);try{return"function"==typeof t.kernel.getMountedFileSystems?t.kernel.getMountedFileSystems():(console.warn(`Kernel ${e} does not support getMountedFileSystems method`),[])}catch(t){throw console.error(`Error getting mounted filesystems for kernel ${e}:`,t),t}}async syncFileSystem(e,t){const r=this.kernels.get(e);if(!r)throw new Error(`Kernel ${e} not found`);try{return"function"==typeof r.kernel.syncFileSystem?await r.kernel.syncFileSystem(t):(console.warn(`Kernel ${e} does not support syncFileSystem method`),{success:!1,error:"syncFileSystem is not supported by this kernel"})}catch(t){return console.error(`Error syncing filesystem for kernel ${e}:`,t),{success:!1,error:t instanceof Error?t.message:String(t)}}}async upgradeFileSystemPermission(e,t){const r=this.kernels.get(e);if(!r)throw new Error(`Kernel ${e} not found`);try{return"function"==typeof r.kernel.upgradeFileSystemPermission?await r.kernel.upgradeFileSystemPermission(t):(console.warn(`Kernel ${e} does not support upgradeFileSystemPermission method`),{success:!1,error:"upgradeFileSystemPermission is not supported by this kernel"})}catch(t){return console.error(`Error upgrading filesystem permission for kernel ${e}:`,t),{success:!1,error:t instanceof Error?t.message:String(t)}}}}class m{constructor(){this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}off(e,t){if(!this.events[e])return;const r=this.events[e].indexOf(t);r>-1&&this.events[e].splice(r,1)}emit(e,...t){this.events[e]&&this.events[e].forEach(e=>e(...t))}setMaxListeners(e){}}class h extends m{constructor(){super(),this.initialized=!1,this.initPromise=null,this.filesystemOptions={enabled:!1,root:".",mountPoint:"/home/pyodide"},this._resolveInputReply=null,this._parent_header={},this.executionCount=0,this._status="unknown",this._interruptBuffer=null,this._interruptSupported=!1,this.environmentVariables={},this.nativeFsHandles=new Map,this.autoSyncFs=!1,super.setMaxListeners(20),this.kernelId=`kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`}async getStatus(){return this._status}async initialize(e){if(!this.initialized)return this.initPromise||(e?.filesystem&&(this.filesystemOptions={...this.filesystemOptions,...e.filesystem}),e?.env&&(this.environmentVariables={...e.env}),e?.lockFileURL&&(this.lockFileURL=e.lockFileURL),void 0!==e?.autoSyncFs&&(this.autoSyncFs=e.autoSyncFs),this.initPromise=this._initializeInternal()),this.initPromise}async _initializeInternal(){const e=Date.now();console.log("üöÄ Starting optimized kernel initialization...");try{const t=Date.now(),r={};this.lockFileURL&&(r.lockFileURL=this.lockFileURL,console.log(`üîí Using lockFileURL: ${this.lockFileURL}`)),this.pyodide=await async function(e={}){return i||(i=(async()=>{try{"undefined"!=typeof importScripts?await new Promise((e,t)=>{try{if("undefined"==typeof importScripts)return void t(new Error("importScripts is not available - not in a worker context"));if(void 0!==globalThis.loadPyodide)return void e();importScripts(o),e()}catch(e){t(new Error(`Failed to import Pyodide in worker: ${e}`))}}):await new Promise((e,t)=>{if(void 0!==globalThis.loadPyodide)return void e();const r=document.createElement("script");r.src=o,r.onload=()=>e(),r.onerror=()=>t(new Error(`Failed to load Pyodide from ${o}`)),document.head.appendChild(r)});const t=globalThis.loadPyodide;if(!t)throw new Error("loadPyodide function not found after script load");const r={indexURL:"https://cdn.jsdelivr.net/pyodide/v0.28.0/full/",...e},n=await t(r);return s=!0,console.log("‚úÖ Pyodide loaded successfully from CDN"),n}catch(e){throw i=null,e}})(),i)}(r);const n=Date.now()-t;if(console.log(`‚úÖ Pyodide loaded in ${n}ms`),this.lockFileURL){console.log("üöÄ Using lock file - skipping package installation");const[,]=await Promise.all([this.filesystemOptions.enabled?this.mountFileSystem():Promise.resolve(),this.setEnvironmentVariables()]);await this.initGlobals()}else{const[,,]=await Promise.all([this.filesystemOptions.enabled?this.mountFileSystem():Promise.resolve(),this.initPackageManager(),this.setEnvironmentVariables()]);await this.initKernel(),await this.initGlobals()}const a=Date.now()-e;console.log(`üéØ KERNEL INITIALIZATION COMPLETE in ${a}ms`),console.log(`‚ö° Performance: Pyodide(${n}ms) + Setup(${a-n}ms)`),this.initialized=!0,this._status="active",console.log("üü¢ Kernel is now ACTIVE and ready for execution!")}catch(e){throw console.error("‚ùå Kernel initialization failed:",e),this._status="unknown",e}}async mountFileSystem(){try{console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`),await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS,{root:this.filesystemOptions.root||"."},this.filesystemOptions.mountPoint||"/home/pyodide"),console.log("FileSystem mounted successfully");try{const e=this.pyodide.FS.readdir(this.filesystemOptions.mountPoint||"/home/pyodide");console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${e.join(", ")}`)}catch(e){console.error(`Error listing mounted directory: ${e}`)}}catch(e){throw console.error("Error mounting filesystem:",e),e}}async initPackageManager(){const e=Date.now();console.log("‚ö° Initializing optimized package manager...");try{let t;console.log("üì¶ Loading micropip, packaging..."),await this.pyodide.loadPackage(["micropip","packaging"]),console.log("‚úÖ Loaded micropip, packaging"),t="undefined"!=typeof window&&window.location?new URL(".",window.location.href).href:"undefined"!=typeof self&&self.location?new URL(".",self.location.href).href:"/";const r=new URL("pypi/all.json",t).href,n=[new URL("pypi/piplite-0.6.0a5-py3-none-any.whl",t).href,new URL("pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl",t).href,new URL("pypi/ipykernel-6.9.2-py3-none-any.whl",t).href,new URL("pypi/widgetsnbextension-3.6.999-py3-none-any.whl",t).href,new URL("pypi/widgetsnbextension-4.0.999-py3-none-any.whl",t).href];console.log(`üöÄ Installing ${n.length} wheel packages in parallel...`);const o=n.map(async(e,t)=>{const r=Date.now();try{await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${e}', keep_going=True)\nprint(f"‚úÖ Wheel ${t+1}/${n.length} installed")\n`);const o=Date.now()-r;return console.log(`‚ö° Wheel ${t+1} installed in ${o}ms`),{index:t,success:!0,time:o}}catch(e){const n=Date.now()-r;return console.warn(`‚ö†Ô∏è Wheel ${t+1} failed after ${n}ms:`,e),{index:t,success:!1,time:n,error:e}}}),s=await Promise.all(o),i=s.filter(e=>e.success),a=s.filter(e=>!e.success);console.log(`üìä Wheels: ${i.length}/${n.length} successful`),a.length>0&&console.warn(`‚ö†Ô∏è Failed wheels: ${a.map(e=>e.index+1).join(", ")}`);try{await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = "${r}"\n        # Pre-load package index for faster installation\n        print("üìã Package index configured")\n    except Exception as e:\n        print(f"‚ö†Ô∏è Package index setup warning: {e}")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print("‚ö° Piplite optimized for performance")\nexcept ImportError:\n    print("‚ö†Ô∏è Piplite not available, continuing without it")\nexcept Exception as e:\n    print(f"‚ö†Ô∏è Piplite setup failed: {e}")\n`)}catch(e){console.warn("‚ö†Ô∏è Piplite configuration failed, continuing without it:",e)}const l=Date.now()-e;console.log(`üéØ Package manager initialized in ${l}ms`)}catch(e){throw console.error("‚ùå Package manager initialization failed:",e),e}}async initKernel(){const e=Date.now();console.log("üöÄ Initializing kernel packages with maximum optimization...");const t=[{name:"pure-eval",priority:1,source:"pyodide"},{name:"stack-data",priority:1,source:"pyodide"},{name:"pygments",priority:1,source:"pyodide"},{name:"ssl",priority:1,source:"pyodide"},{name:"sqlite3",priority:1,source:"pyodide"},{name:"prompt_toolkit",priority:1,source:"pyodide"},{name:"jedi",priority:1,source:"pyodide"},{name:"ipython",priority:1,source:"pyodide"},{name:"comm",priority:2,source:"pip"},{name:"hypha-rpc",priority:2,source:"pip"},{name:"nbformat",priority:2,source:"pip"},{name:"ipykernel",priority:3,source:"pip"},{name:"pyodide_kernel",priority:3,source:"pip"}];try{console.log(`üì¶ Installing ${t.length} packages with intelligent optimization...`),await this.installPackagesWithIntelligentOptimization(t),console.log("üì• Importing pyodide_kernel...");const r=Date.now();await this.pyodide.runPythonAsync("import pyodide_kernel");const n=Date.now()-r;console.log(`‚úÖ pyodide_kernel imported in ${n}ms`);const o=Date.now()-e;console.log(`üéØ Kernel packages initialized in ${o}ms`)}catch(e){throw console.error("‚ùå Kernel package initialization failed:",e),e}}async installPackagesWithIntelligentOptimization(e){console.log(`‚ö° Starting intelligent parallel installation of ${e.length} packages...`);const t=e.map(async e=>{const t=Date.now();try{if(console.log(`üîÑ Installing ${e.name} (priority: ${e.priority}, preferred: ${e.source})...`),"pyodide"!==e.source){await this.installViaPipWithOptimizations(e.name);const r=Date.now()-t;return console.log(`‚úÖ ${e.name} installed via pip (${r}ms)`),{package:e.name,method:"pip",duration:r,success:!0,priority:e.priority}}try{await this.pyodide.loadPackage([e.name]);const r=Date.now()-t;return console.log(`‚úÖ ${e.name} loaded from Pyodide CDN (${r}ms)`),{package:e.name,method:"pyodide",duration:r,success:!0,priority:e.priority}}catch(r){console.log(`üì¶ ${e.name} not available on CDN, trying pip...`),await this.installViaPipWithOptimizations(e.name);const n=Date.now()-t;return console.log(`‚úÖ ${e.name} installed via pip fallback (${n}ms)`),{package:e.name,method:"pip-fallback",duration:n,success:!0,priority:e.priority}}}catch(r){const n=Date.now()-t;return console.warn(`‚ùå Failed to install ${e.name} after ${n}ms:`,r),{package:e.name,method:"failed",duration:n,success:!1,priority:e.priority,error:r}}}),r=await Promise.all(t);this.analyzeInstallationResults(r)}async installViaPipWithOptimizations(e){await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${e}', keep_going=True, deps=True)\n    print("‚úÖ Successfully installed ${e} via optimized pip")\nexcept Exception as e:\n    print("‚ö†Ô∏è Warning: Failed to install ${e}:", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${e}', keep_going=True)\n        print("‚úÖ Successfully installed ${e} via micropip fallback")\n    except Exception as e2:\n        print("‚ùå Both pip methods failed for ${e}:", str(e2))\n        raise e2\n`)}analyzeInstallationResults(e){const t=e.filter(e=>e.success),r=e.filter(e=>!e.success),n=t.filter(e=>"pyodide"===e.method),o=t.filter(e=>"pip"===e.method),s=t.filter(e=>"pip-fallback"===e.method),i=Math.max(...e.map(e=>e.duration)),a=e.reduce((e,t)=>e+t.duration,0)/e.length,l=e.reduce((e,t)=>e+t.duration,0);console.log("üéØ INTELLIGENT INSTALLATION COMPLETE!"),console.log(`üìä Results: ${t.length}/${e.length} successful`),console.log(`‚ö° Pyodide CDN: ${n.length} packages`),console.log(`üì¶ Direct pip: ${o.length} packages`),console.log(`üîÑ Pip fallback: ${s.length} packages`),console.log(`‚ùå Failed: ${r.length} packages`),console.log(`‚è±Ô∏è  Total time: ${i}ms (vs ~${l}ms sequential)`),console.log(`üöÄ Speed improvement: ~${Math.round(l/i)}x faster`),console.log(`üìà Average per package: ${Math.round(a)}ms`),r.length>0&&(console.warn(`‚ö†Ô∏è  Failed packages: ${r.map(e=>e.package).join(", ")}`),r.forEach(e=>{console.warn(`   - ${e.package}: ${e.error?.message||"Unknown error"}`)}));const c=Math.min(...t.map(e=>e.duration)),u=Math.max(...t.map(e=>e.duration));console.log(`üìä Performance range: ${c}ms (fastest) to ${u}ms (slowest)`)}async initGlobals(){console.log("Initializing globals...");const{globals:e}=this.pyodide;this._kernel=e.get("pyodide_kernel").kernel_instance.copy(),this._stdout_stream=e.get("pyodide_kernel").stdout_stream.copy(),this._stderr_stream=e.get("pyodide_kernel").stderr_stream.copy(),this._interpreter=this._kernel.interpreter.copy(),this._interpreter.send_comm=this.sendComm.bind(this),this.setupCallbacks()}setupCallbacks(){const e=(e,t)=>{const r={name:this.formatResult(e),text:this.formatResult(t)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:r,type:"stream"})};this._stdout_stream.publish_stream_callback=e,this._stderr_stream.publish_stream_callback=e,this._interpreter.display_pub.clear_output_callback=e=>{const t={wait:this.formatResult(e)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:t,type:"clear_output"})},this._interpreter.display_pub.display_data_callback=(e,t,r)=>{const n={data:this.formatResult(e),metadata:this.formatResult(t),transient:this.formatResult(r)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:n,type:"display_data"})},this._interpreter.display_pub.update_display_data_callback=(e,t,r)=>{const n={data:this.formatResult(e),metadata:this.formatResult(t),transient:this.formatResult(r)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:n,type:"update_display_data"})},this._interpreter.displayhook.publish_execution_result=(e,t,r)=>{const n={execution_count:e,data:this.formatResult(t),metadata:this.formatResult(r)};this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:n,type:"execute_result"})},this._interpreter.input=this.input.bind(this),this._interpreter.getpass=this.getpass.bind(this)}_sendMessage(e){this._processMessage(e)}_processMessage(e){if(!e.type)return;let t;switch(e.type){case"stream":{const r=e.bundle??{name:"stdout",text:""};super.emit(c.z.STREAM,r),t=r;break}case"input_request":{const r=e.content??{prompt:"",password:!1};super.emit(c.z.INPUT_REQUEST,r),t=r;break}case"display_data":{const r=e.bundle??{data:{},metadata:{},transient:{}};super.emit(c.z.DISPLAY_DATA,r),t=r;break}case"update_display_data":{const r=e.bundle??{data:{},metadata:{},transient:{}};super.emit(c.z.UPDATE_DISPLAY_DATA,r),t=r;break}case"clear_output":{const r=e.bundle??{wait:!1};super.emit(c.z.CLEAR_OUTPUT,r),t=r;break}case"execute_result":{const r=e.bundle??{execution_count:this.executionCount,data:{},metadata:{}};super.emit(c.z.EXECUTE_RESULT,r),t=r;break}case"execute_error":{const r=e.bundle??{ename:"",evalue:"",traceback:[]};super.emit(c.z.EXECUTE_ERROR,r),t=r;break}case"comm_open":case"comm_msg":case"comm_close":{const r=e.content??{};super.emit(e.type,r,e.metadata,e.buffers),t={content:r,metadata:e.metadata,buffers:e.buffers};break}}t&&super.emit(c.z.ALL,{type:e.type,data:t})}isInitialized(){return this.initialized}async setup(e){await this.initialize(),this._parent_header=this.pyodide.toPy(e||{})}async execute(e,t={}){const r=[];try{for await(const n of this.executeStream(e,t))r.push(n);const n={outputs:[],data:{},metadata:{},execution_count:this.executionCount};for(const e of r)if("stream"===e.type)n.stdout||(n.stdout=""),n.stderr||(n.stderr=""),"stdout"===e.data.name?n.stdout+=e.data.text:"stderr"===e.data.name&&(n.stderr+=e.data.text),n.outputs.push(e.data);else if("display_data"===e.type||"execute_result"===e.type)e.data.data&&Object.assign(n.data,e.data.data),e.data.metadata&&Object.assign(n.metadata,e.data.metadata),n.outputs.push(e.data);else{if("execute_error"===e.type||"error"===e.type){const t=e.data;return{success:!1,error:new Error(`${t.ename}: ${t.evalue}`),ename:t.ename,evalue:t.evalue,traceback:t.traceback,outputs:n.outputs}}n.outputs.push(e)}return n.success=!0,this.autoSyncFs&&await this.syncAllNativeFs(),n}catch(e){return console.error("[KERNEL] Execute error:",e),{success:!1,error:e instanceof Error?e:new Error(String(e))}}}formatResult(e){if(!(e instanceof this.pyodide.ffi.PyProxy))return e;try{const t=e.toJs();return this.mapToObject(t)}catch(e){return console.error("Error formatting result:",e),{status:"error",error:String(e)}}}mapToObject(e){const t=e instanceof Array?[]:{};return e.forEach((e,r)=>{t[r]=e instanceof Map||e instanceof Array?this.mapToObject(e):e}),t}async inputReply(e){this._resolveInputReply&&(this._resolveInputReply(e),this._resolveInputReply=null)}async sendInputRequest(e,t){const r={prompt:e,password:t};this._sendMessage({type:"input_request",content:r,parentHeader:this.formatResult(this._parent_header).header})}async getpass(e){e=void 0===e?"":e,await this.sendInputRequest(e,!0);const t=new Promise(e=>{this._resolveInputReply=e});return(await t).value}async input(e){e=void 0===e?"":e,await this.sendInputRequest(e,!1);const t=new Promise(e=>{this._resolveInputReply=e});return(await t).value}async sendComm(e,t,r,n,o){this._sendMessage({type:e,content:this.formatResult(t),metadata:this.formatResult(r),ident:this.formatResult(n),buffers:this.formatResult(o),parentHeader:this.formatResult(this._parent_header).header})}async complete(e,t,r={}){await this.setup(r);const n=this._kernel.complete(e,t);return this.formatResult(n)}async inspect(e,t,r,n={}){await this.setup(n);const o=this._kernel.inspect(e,t,r);return this.formatResult(o)}async isComplete(e,t={}){await this.setup(t);const r=this._kernel.is_complete(e);return this.formatResult(r)}async commInfo(e,t={}){await this.setup(t);const r=this._kernel.comm_info(e);return{comms:this.formatResult(r),status:"ok"}}async commOpen(e,t={}){await this.setup(t);const r=this._kernel.comm_manager.comm_open(this.pyodide.toPy(null),this.pyodide.toPy(null),this.pyodide.toPy(e));return this.formatResult(r)}async commMsg(e,t={}){await this.setup(t);const r=this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null),this.pyodide.toPy(null),this.pyodide.toPy(e));return this.formatResult(r)}async commClose(e,t={}){await this.setup(t);const r=this._kernel.comm_manager.comm_close(this.pyodide.toPy(null),this.pyodide.toPy(null),this.pyodide.toPy(e));return this.formatResult(r)}async*executeStream(e,t={}){this.initialized||await this.initialize();try{this._status="busy",super.emit(c.z.KERNEL_BUSY,{}),await this.setup(t);const r=[];let n=!1,o=null,s=null;const i=e=>{r.push(e)};super.on(c.z.ALL,i);try{for(this._kernel.run(e).then(e=>{console.log("[KERNEL] Python execution finished"),o=this.formatResult(e),o&&"error"===o.status&&(console.log("[KERNEL] Execution completed with error status, emitting execute_error event"),this._sendMessage({parentHeader:this.formatResult(this._parent_header).header,bundle:{ename:o.ename||"Error",evalue:o.evalue||"Unknown error",traceback:o.traceback||[]},type:"execute_error"})),setTimeout(()=>{n=!0},100)}).catch(e=>{console.error("[KERNEL] Python execution error:",e),s=e instanceof Error?e:new Error(String(e)),setTimeout(()=>{n=!0},100)});!n||r.length>0;)if(r.length>0){const e=r.shift();yield e}else n||await new Promise(e=>setTimeout(e,10));if(this._status="active",super.emit(c.z.KERNEL_IDLE,{}),s)return{success:!1,error:s,result:o};if(o&&"error"===o.status){const e=`${o.ename||"Error"}: ${o.evalue||"Unknown error"}`;return{success:!1,error:new Error(e),result:o}}return this.autoSyncFs&&await this.syncAllNativeFs(),{success:!0,result:o}}finally{super.off(c.z.ALL,i)}}catch(e){return console.error("[KERNEL] ExecuteStream error:",e),this._status="active",super.emit(c.z.KERNEL_IDLE,{}),{success:!1,error:e instanceof Error?e:new Error(String(e))}}}async interrupt(){if(!this.initialized||!this.pyodide)return console.warn("[KERNEL] Cannot interrupt: kernel not initialized"),!1;console.log("[KERNEL] Attempting to interrupt execution...");try{if(this._interruptBuffer&&this._interruptSupported&&(console.log("[KERNEL] Using interrupt buffer method"),this._interruptBuffer[0]=2,await new Promise(e=>setTimeout(e,100)),0===this._interruptBuffer[0]))return console.log("[KERNEL] Interrupt processed successfully via buffer"),!0;try{return console.log("[KERNEL] Attempting Python-level interrupt"),await this.pyodide.runPythonAsync("\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n"),console.log("[KERNEL] Python interrupt signal sent"),!0}catch(e){console.log("[KERNEL] Python interrupt attempt failed:",e)}return this._interpreter&&"function"==typeof this._interpreter.interrupt?(console.log("[KERNEL] Using interpreter interrupt method"),this._interpreter.interrupt(),!0):(console.log("[KERNEL] Sending interrupt messages for UI feedback"),this._sendMessage({type:"stream",bundle:{name:"stderr",text:"KeyboardInterrupt: Execution interrupted by user\n"}}),this._sendMessage({type:"execute_error",bundle:{ename:"KeyboardInterrupt",evalue:"Execution interrupted by user",traceback:["KeyboardInterrupt: Execution interrupted by user"]}}),!1)}catch(e){return console.error("[KERNEL] Error during interrupt:",e),!1}}setInterruptBuffer(e){this._interruptBuffer=e;try{this.pyodide&&"function"==typeof this.pyodide.setInterruptBuffer?(this.pyodide.setInterruptBuffer(e),this._interruptSupported=!0):(console.warn("[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited"),this._interruptSupported=!1)}catch(e){console.error("[KERNEL] Error setting interrupt buffer:",e),this._interruptSupported=!1}}async verifyPermission(e,t){const r={};if("readwrite"===t&&(r.mode="readwrite"),console.log(`[KERNEL] Verifying ${t} permission for file handle...`),"function"!=typeof e.queryPermission)return console.warn("[KERNEL] queryPermission not supported, assuming permission granted"),!0;try{const n=await e.queryPermission(r);if(console.log("[KERNEL] Query result:",n),"granted"===n)return console.log(`[KERNEL] Permission already granted for ${t} access`),!0;if("function"==typeof e.requestPermission){console.log(`[KERNEL] Requesting ${t} permission from user...`);try{const n=await e.requestPermission(r);if(console.log("[KERNEL] Request result:",n),"granted"===n)return console.log(`[KERNEL] Permission granted for ${t} access`),!0}catch(e){console.log("[KERNEL] Permission request failed or was dismissed:",e)}}return console.log(`[KERNEL] ${t} permission not granted`),!1}catch(e){return console.error("[KERNEL] Error checking permission:",e),console.warn("[KERNEL] Permission check failed, assuming granted as fallback"),!0}}async mountFS(e,t,r="read"){if(!this.initialized||!this.pyodide)throw new Error("Kernel must be initialized before mounting filesystem");if("function"!=typeof this.pyodide.mountNativeFS)throw new Error("pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.");let n=t;if(!n){if("undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope)throw new Error("Cannot show directory picker in worker context. Please provide a dirHandle parameter.");if("undefined"==typeof window||!("showDirectoryPicker"in window))throw new Error("showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.");try{n=await window.showDirectoryPicker({mode:"readwrite"})}catch(e){throw new Error(`Failed to show directory picker: ${e instanceof Error?e.message:String(e)}`)}}if(!n)throw new Error("No directory handle available");if(console.log(`[KERNEL] Verifying ${r} permissions before mounting...`),!await this.verifyPermission(n,r))throw"readwrite"===r?new Error("Failed to obtain write permission for directory. The browser may only be offering read permission. Try mounting with permission: 'read' if you only need to read files, or ensure the browser supports write access to this directory."):new Error(`Failed to obtain ${r} permission for directory.`);const o=r;try{console.log(`[KERNEL] Mounting native filesystem at ${e} with ${o} permission`);try{if(this.pyodide.FS.analyzePath(e).exists){console.log(`[KERNEL] Path ${e} exists, checking if it's a mount point`);try{await this.pyodide.FS.unmount(e),console.log(`[KERNEL] Successfully unmounted existing filesystem at ${e}`)}catch(e){console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${e}`)}try{this.pyodide.FS.rmdir(e),console.log(`[KERNEL] Removed existing directory at ${e}`)}catch(e){console.log(`[KERNEL] Could not remove directory (this is normal): ${e}`)}}}catch(e){console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${e}`)}const t=e.substring(0,e.lastIndexOf("/"))||"/";try{"/"===t||this.pyodide.FS.analyzePath(t).exists||(this.pyodide.FS.mkdir(t),console.log(`[KERNEL] Created parent directory ${t}`))}catch(e){console.log(`[KERNEL] Parent directory handling: ${e}`)}const r=await this.pyodide.mountNativeFS(e,n);console.log(`[KERNEL] Successfully mounted native filesystem at ${e} with ${o} permission`);const s={syncfs:async()=>{if("read"===o)throw new Error(`Cannot sync read-only filesystem at ${e}. Use upgradeFileSystemPermission() to request write access.`);try{await r.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${e}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},dirHandle:n,permission:o,nativefs:r};return this.nativeFsHandles.set(e,s),{syncfs:s.syncfs}}catch(e){throw new Error(`Failed to mount native filesystem: ${e instanceof Error?e.message:String(e)}`)}}async syncAllNativeFs(){if(0===this.nativeFsHandles.size)return;const e=[];for(const[t,r]of this.nativeFsHandles.entries())if("read"!==r.permission)try{await r.syncfs(),e.push({mountPath:t,success:!0}),console.log(`[KERNEL] Successfully synced filesystem at ${t}`)}catch(n){const o=n instanceof Error?n.message:String(n);if(o.includes("not allowed by the user agent")||o.includes("getFileHandle")||o.includes("permission")){console.warn(`[KERNEL] Permission error syncing ${t}, attempting recovery...`);try{if(await this.verifyPermission(r.dirHandle,r.permission)){console.log(`[KERNEL] Permission recovered for ${t}, attempting remount...`);const n=await this.pyodide.mountNativeFS(t,r.dirHandle);r.nativefs=n,r.syncfs=async()=>{try{await n.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${t}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},await r.syncfs(),e.push({mountPath:t,success:!0}),console.log(`[KERNEL] Successfully recovered and synced filesystem at ${t}`)}else e.push({mountPath:t,success:!1,error:"Permission denied by user"}),console.warn(`[KERNEL] User denied permission for ${t}, skipping sync`)}catch(r){const n=r instanceof Error?r.message:String(r);e.push({mountPath:t,success:!1,error:`Recovery failed: ${n}`}),console.error(`[KERNEL] Failed to recover permissions for ${t}:`,r)}}else e.push({mountPath:t,success:!1,error:o}),console.error(`[KERNEL] Non-permission error syncing ${t}:`,n)}else e.push({mountPath:t,success:!0,skipped:!0}),console.log(`[KERNEL] Skipping sync for read-only filesystem at ${t}`);const t=e.filter(e=>e.success&&!e.skipped).length,r=e.filter(e=>e.skipped).length,n=e.filter(e=>!e.success);if(t>0||r>0){const n=[];t>0&&n.push(`${t} synced`),r>0&&n.push(`${r} read-only skipped`),console.log(`[KERNEL] Auto-sync completed: ${n.join(", ")} (${e.length} total filesystems)`)}n.length>0&&console.warn("[KERNEL] Auto-sync issues:",n.map(e=>`${e.mountPath}: ${e.error}`))}getMountedFileSystems(){const e=[];for(const[t,r]of this.nativeFsHandles.entries())e.push({mountPath:t,permission:r.permission,canSync:"readwrite"===r.permission});return e}async syncFileSystem(e){const t=this.nativeFsHandles.get(e);if(!t)return{success:!1,error:`No filesystem mounted at ${e}`};if("read"===t.permission)return{success:!1,error:`Cannot sync read-only filesystem at ${e}. Mount with 'readwrite' permission to enable syncing.`};try{return await t.syncfs(),{success:!0}}catch(r){const n=r instanceof Error?r.message:String(r);if(n.includes("not allowed by the user agent")||n.includes("getFileHandle")||n.includes("permission")){console.log(`[KERNEL] Permission error syncing ${e}, attempting recovery...`);try{if(await this.verifyPermission(t.dirHandle,t.permission)){const r=await this.pyodide.mountNativeFS(e,t.dirHandle);return t.nativefs=r,t.syncfs=async()=>{try{await r.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${e}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},await t.syncfs(),{success:!0}}return{success:!1,error:"Permission denied by user"}}catch(e){return{success:!1,error:`Recovery failed: ${e instanceof Error?e.message:String(e)}`}}}return{success:!1,error:n}}}async upgradeFileSystemPermission(e){const t=this.nativeFsHandles.get(e);if(!t)return{success:!1,error:`No filesystem mounted at ${e}`};if("readwrite"===t.permission)return{success:!0,error:`FileSystem at ${e} already has readwrite permission`};try{if(console.log(`[KERNEL] Attempting to upgrade ${e} to readwrite permission...`),!await this.verifyPermission(t.dirHandle,"readwrite"))return{success:!1,error:"User denied write permission or browser does not support write access to this directory"};const r=await this.pyodide.mountNativeFS(e,t.dirHandle);return t.permission="readwrite",t.nativefs=r,t.syncfs=async()=>{try{await r.syncfs(),console.log(`[KERNEL] Synced changes to native filesystem at ${e}`)}catch(e){throw new Error(`Failed to sync filesystem: ${e instanceof Error?e.message:String(e)}`)}},console.log(`[KERNEL] Successfully upgraded ${e} to readwrite permission`),{success:!0}}catch(e){return{success:!1,error:`Failed to upgrade permission: ${e instanceof Error?e.message:String(e)}`}}}async setEnvironmentVariables(){if(0===Object.keys(this.environmentVariables).length)return;const e=Date.now();console.log(`üåç Setting ${Object.keys(this.environmentVariables).length} environment variables...`);try{for(const[e,t]of Object.entries(this.environmentVariables)){let r;r=null==t?"":String(t),await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(e)}] = ${JSON.stringify(r)}\n`)}const t=Date.now()-e;console.log(`‚ö° Environment variables set in ${t}ms`)}catch(e){throw console.error("‚ùå Failed to set environment variables:",e),e}}}const y=n.MB,f=n.zZ,g=n.y9,E=n.dR,w=n.J9;export{y as Kernel,f as KernelEvents,g as KernelLanguage,E as KernelManager,w as KernelMode};
//# sourceMappingURL=web-python-kernel.min.mjs.map