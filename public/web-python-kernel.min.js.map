{"version":3,"file":"web-python-kernel.min.js","mappings":"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","sources":["webpack://WebPythonKernel/webpack/universalModuleDefinition","webpack://WebPythonKernel/./node_modules/comlink/dist/esm/comlink.mjs","webpack://WebPythonKernel/./src/types.ts","webpack://WebPythonKernel/webpack/bootstrap","webpack://WebPythonKernel/webpack/runtime/define property getters","webpack://WebPythonKernel/webpack/runtime/hasOwnProperty shorthand","webpack://WebPythonKernel/webpack/runtime/make namespace object","webpack://WebPythonKernel/./src/pyodide-loader.ts","webpack://WebPythonKernel/./src/manager.ts","webpack://WebPythonKernel/./src/index.ts","webpack://WebPythonKernel/./src/_pypi.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebPythonKernel\"] = factory();\n\telse\n\t\troot[\"WebPythonKernel\"] = factory();\n})(self, () => {\nreturn ","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously \\_()_/\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnt happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n\n// Events enum\nexport enum KernelEvents {\n  // IOPub Channel Messages\n  STREAM = \"stream\",\n  DISPLAY_DATA = \"display_data\",\n  UPDATE_DISPLAY_DATA = \"update_display_data\",\n  EXECUTE_RESULT = \"execute_result\",\n  EXECUTE_ERROR = \"execute_error\",\n  EXECUTE_REQUEST = \"execute_request\",\n  \n  // Input request\n  INPUT_REQUEST = \"input_request\",\n  \n  // Output control\n  CLEAR_OUTPUT = \"clear_output\",\n  \n  // Comm messages\n  COMM_OPEN = \"comm_open\",\n  COMM_MSG = \"comm_msg\",\n  COMM_CLOSE = \"comm_close\",\n  \n  // Internal Events\n  KERNEL_READY = \"kernel_ready\",\n  KERNEL_BUSY = \"kernel_busy\",\n  KERNEL_IDLE = \"kernel_idle\",\n  \n  // Special catchall for internal use\n  ALL = \"*\", // Wildcard event type\n  \n  // Execution monitoring events\n  EXECUTION_STALLED = \"execution_stalled\",\n  \n  // Enhanced stuck kernel handling events\n  KERNEL_UNRECOVERABLE = \"kernel_unrecoverable\",\n  EXECUTION_INTERRUPTED = \"execution_interrupted\",\n  KERNEL_RESTARTED = \"kernel_restarted\",\n  KERNEL_TERMINATED = \"kernel_terminated\"\n}\n\n// EventEmitter interface for typing\nexport interface IEventEmitter {\n  on(eventName: string, listener: Function): void;\n  off(eventName: string, listener: Function): void;\n  emit(eventName: string, ...args: any[]): void;\n  setMaxListeners(n: number): void;\n}\n\n// FileSystem mount options\nexport interface IFileSystemMountOptions {\n  enabled?: boolean;\n  root?: string;\n  mountPoint?: string;\n}\n\n// Kernel options interface\nexport interface IKernelOptions {\n  filesystem?: IFileSystemMountOptions;\n  env?: Record<string, string>; // Environment variables to set in the kernel\n  lockFileURL?: string; // URL to pyodide-lock.json file for faster loading\n  autoSyncFs?: boolean; // Automatically sync native filesystem after code execution (default: false)\n}\n\n// Native filesystem handle type\nexport interface INativeFSHandle {\n  syncfs(): Promise<void>;\n}\n\n// Kernel interface\nexport interface IKernel extends IEventEmitter {\n  initialize(options?: IKernelOptions): Promise<void>;\n  execute(code: string, parent?: any): Promise<{ success: boolean, result?: any, error?: Error }>;\n  executeStream?(code: string, parent?: any): AsyncGenerator<any, { success: boolean, result?: any, error?: Error }, void>;\n  isInitialized(): boolean;\n  inputReply(content: { value: string }): Promise<void>;\n  getStatus(): Promise<\"active\" | \"busy\" | \"unknown\">;\n\n  // Interrupt functionality\n  interrupt?(): Promise<boolean>;\n  setInterruptBuffer?(buffer: Uint8Array): void;\n\n  // Native filesystem mounting\n  mountFS?(mountPath: string, dirHandle?: FileSystemDirectoryHandle | null, permission?: 'read' | 'readwrite'): Promise<INativeFSHandle>;\n  getMountedFileSystems?(): Array<{ mountPath: string; permission: 'read' | 'readwrite'; canSync: boolean; }>;\n  syncFileSystem?(mountPath: string): Promise<{ success: boolean; error?: string }>;\n  upgradeFileSystemPermission?(mountPath: string): Promise<{ success: boolean; error?: string }>;\n\n  // Optional methods\n  complete?(code: string, cursor_pos: number, parent?: any): Promise<any>;\n  inspect?(code: string, cursor_pos: number, detail_level: 0 | 1, parent?: any): Promise<any>;\n  isComplete?(code: string, parent?: any): Promise<any>;\n  commInfo?(target_name: string | null, parent?: any): Promise<any>;\n  commOpen?(content: any, parent?: any): Promise<void>;\n  commMsg?(content: any, parent?: any): Promise<void>;\n  commClose?(content: any, parent?: any): Promise<void>;\n}\n\n// Execute options interface\nexport interface IKernelExecuteOptions {\n  code: string;\n  silent?: boolean;\n  storeHistory?: boolean;\n}\n\n// Message interface\nexport interface IMessage {\n  type: string;\n  bundle?: any;\n  content?: any;\n  metadata?: any;\n  parentHeader?: any;\n  buffers?: any;\n  ident?: any;\n}\n\n// Event data interface\nexport interface IEventData {\n  type: string;\n  data: any;\n} ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\n\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise: Promise<any> | null = null;\n\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Check if script is already loaded\n    if (typeof (globalThis as any).loadPyodide !== 'undefined') {\n      resolve();\n      return;\n    }\n\n    const script = document.createElement('script');\n    script.src = PYODIDE_CDN_URL;\n    script.onload = () => resolve();\n    script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n    document.head.appendChild(script);\n  });\n}\n\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    try {\n      // Check if we're in a worker environment\n      if (typeof importScripts === 'undefined') {\n        reject(new Error('importScripts is not available - not in a worker context'));\n        return;\n      }\n\n      // Check if already loaded\n      if (typeof (globalThis as any).loadPyodide !== 'undefined') {\n        resolve();\n        return;\n      }\n\n      importScripts(PYODIDE_CDN_URL);\n      resolve();\n    } catch (error) {\n      reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n    }\n  });\n}\n\n/**\n * Initialize Pyodide with proper configuration\n */\nexport async function loadPyodide(config: any = {}): Promise<any> {\n  // Return existing promise if already loading\n  if (pyodideLoadPromise) {\n    return pyodideLoadPromise;\n  }\n\n  pyodideLoadPromise = (async () => {\n    try {\n      // Determine if we're in a worker or main thread\n      const isWorker = typeof importScripts !== 'undefined';\n      \n      // Load the Pyodide script\n      if (isWorker) {\n        await loadPyodideInWorker();\n      } else {\n        await loadPyodideScript();\n      }\n\n      // Get the global loadPyodide function\n      const globalLoadPyodide = (globalThis as any).loadPyodide;\n      if (!globalLoadPyodide) {\n        throw new Error('loadPyodide function not found after script load');\n      }\n\n      // Configure default options\n      const defaultConfig = {\n        indexURL: PYODIDE_INDEX_URL,\n        ...config\n      };\n\n      // Initialize Pyodide\n      const pyodide = await globalLoadPyodide(defaultConfig);\n      pyodideLoaded = true;\n      \n      console.log(' Pyodide loaded successfully from CDN');\n      return pyodide;\n    } catch (error) {\n      pyodideLoadPromise = null; // Reset on failure\n      throw error;\n    }\n  })();\n\n  return pyodideLoadPromise;\n}\n\n/**\n * Check if Pyodide is already loaded\n */\nexport function isPyodideLoaded(): boolean {\n  return pyodideLoaded && typeof (globalThis as any).loadPyodide !== 'undefined';\n}\n\n/**\n * Get Pyodide CDN URL for external use\n */\nexport function getPyodideCDNUrl(): string {\n  return PYODIDE_CDN_URL;\n}\n\n/**\n * Get Pyodide index URL for external use\n */\nexport function getPyodideIndexUrl(): string {\n  return PYODIDE_INDEX_URL;\n} ","// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\nimport * as Comlink from \"comlink\";\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n  private events: { [key: string]: Function[] } = {};\n\n  on(eventName: string, listener: Function) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(listener);\n  }\n\n  off(eventName: string, listener: Function) {\n    if (!this.events[eventName]) return;\n    const index = this.events[eventName].indexOf(listener);\n    if (index > -1) {\n      this.events[eventName].splice(index, 1);\n    }\n  }\n\n  removeListener(eventName: string, listener: Function) {\n    this.off(eventName, listener);\n  }\n\n  emit(eventName: string, ...args: any[]) {\n    if (!this.events[eventName]) return;\n    this.events[eventName].forEach(listener => listener(...args));\n  }\n\n  setMaxListeners(n: number) {\n    // No-op for browser compatibility\n  }\n}\nimport { KernelEvents, IKernel, IKernelOptions, IFileSystemMountOptions } from \"./types\";\nimport { Kernel } from \"./index\";\n\n// Re-export KernelEvents for test usage\nexport { KernelEvents };\n\n// Execution mode enum\nexport enum KernelMode {\n  MAIN_THREAD = \"main_thread\",\n  WORKER = \"worker\"\n}\n\n// Kernel language enum\nexport enum KernelLanguage {\n  PYTHON = \"python\"\n}\n\n// Extended WorkerOptions interface to include Deno permissions\ninterface WorkerOptions {\n  type?: \"classic\" | \"module\";\n  name?: string;\n  deno?: {\n    permissions?: IDenoPermissions;\n  };\n}\n\n// Interface for kernel pool configuration\nexport interface IKernelPoolConfig {\n  enabled: boolean;\n  poolSize: number; // Number of kernels to keep ready per configuration\n  autoRefill: boolean; // Whether to automatically refill the pool when kernels are taken\n  preloadConfigs: Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }>; // Configurations to preload in the pool\n}\n\n// Interface for kernel manager options\nexport interface IKernelManagerOptions {\n  pool?: IKernelPoolConfig;\n  allowedKernelTypes?: Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }>; // Restrict which kernel types can be created\n  interruptionMode?: 'shared-array-buffer' | 'kernel-interrupt' | 'auto'; // Default: 'auto'\n  workerUrl?: string; // Optional custom URL for the worker script\n}\n\n// Interface for kernel instance\nexport interface IKernelInstance {\n  id: string;\n  kernel: IKernel;\n  mode: KernelMode;\n  language: KernelLanguage;\n  worker?: Worker;\n  created: string;\n  options: IManagerKernelOptions;\n  isFromPool?: boolean; // Track if this kernel came from the pool\n  destroy(): Promise<void>;\n}\n\n// Interface for Deno worker permissions\nexport interface IDenoPermissions {\n  read?: (string | URL)[];\n  write?: (string | URL)[];\n  net?: string[];\n  env?: string[];\n  run?: string[];\n  ffi?: string[];\n  hrtime?: boolean;\n}\n\n// Interface for kernel creation options\nexport interface IManagerKernelOptions {\n  id?: string;\n  mode?: KernelMode;\n  lang?: KernelLanguage;\n  namespace?: string;\n  deno?: {\n    permissions?: IDenoPermissions;\n  };\n  filesystem?: IFileSystemMountOptions;\n  env?: Record<string, string>; // Environment variables to set in the kernel\n  lockFileURL?: string; // URL to pyodide-lock.json file for faster loading\n  autoSyncFs?: boolean; // Automatically sync native filesystem after code execution (default: false)\n  inactivityTimeout?: number; // Time in milliseconds after which an inactive kernel will be shut down\n  maxExecutionTime?: number; // Maximum time in milliseconds a single execution can run before considered stuck/dead\n}\n\n// Helper type for listener management\ntype ListenerWrapper = {\n  original: (data: any) => void;\n  wrapped: (event: { kernelId: string, data: any }) => void;\n};\n\n/**\n * KernelManager class manages multiple kernel instances \n * in either main thread or worker mode\n */\nexport class KernelManager extends EventEmitter {\n  private kernels: Map<string, IKernelInstance> = new Map();\n  // Track listeners for each kernel to enable individual removal\n  private listenerWrappers: Map<string, Map<string, Map<Function, ListenerWrapper>>> = new Map();\n  // Track last activity time for each kernel\n  private lastActivityTime: Map<string, number> = new Map();\n  // Store inactivity timers for each kernel\n  private inactivityTimers: Map<string, any> = new Map();\n  // Track ongoing executions for each kernel\n  private ongoingExecutions: Map<string, Set<string>> = new Map();\n  // Track execution timeouts for detecting stuck/dead kernels\n  private executionTimeouts: Map<string, Map<string, any>> = new Map();\n  // Track execution start times for accurate duration calculation\n  private executionStartTimes: Map<string, Map<string, number>> = new Map();\n  // Track execution metadata for better monitoring\n  private executionMetadata: Map<string, Map<string, { startTime: number; code?: string; timeoutId?: any }>> = new Map();\n  \n  // Track AbortControllers for each kernel's ongoing operations\n  private abortControllers: Map<string, Map<string, AbortController>> = new Map();\n  \n  // Pool management - now using promises for immediate response\n  private pool: Map<string, Promise<IKernelInstance>[]> = new Map();\n  private poolConfig: IKernelPoolConfig;\n  private isPreloading: boolean = false;\n  // Track which pool keys are currently being prefilled to prevent duplicates\n  private prefillingInProgress: Map<string, boolean> = new Map();\n  \n  // Allowed kernel types configuration\n  private allowedKernelTypes: Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }>;\n  \n  // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n  private interruptBuffers: Map<string, Uint8Array> = new Map();\n  \n  // Interruption mode configuration\n  private interruptionMode: 'shared-array-buffer' | 'kernel-interrupt' | 'auto';\n  \n  // Worker URL configuration\n  private workerUrl: string | undefined;\n  \n  /**\n   * Resolve the worker URL based on the current environment\n   * @private\n   * @returns The resolved worker URL\n   */\n  private resolveWorkerUrl(): string {\n    // If a custom worker URL is provided, use it\n    if (this.workerUrl) {\n      return this.workerUrl;\n    }\n    \n    // Try to detect the current script location and derive the worker URL\n    if (typeof window !== 'undefined' && window.location) {\n      // Browser environment\n      const currentScript = (document.currentScript as HTMLScriptElement) || \n                           Array.from(document.getElementsByTagName('script')).pop();\n      \n      if (currentScript && currentScript.src) {\n        // Get the base URL from the current script\n        const scriptUrl = new URL(currentScript.src);\n        const baseUrl = scriptUrl.href.substring(0, scriptUrl.href.lastIndexOf('/'));\n        \n        // Check if we're loading from a CDN (jsdelivr, unpkg, etc.)\n        if (scriptUrl.hostname.includes('jsdelivr.net') || \n            scriptUrl.hostname.includes('unpkg.com') ||\n            scriptUrl.hostname.includes('cdnjs.cloudflare.com')) {\n          // For CDN, the worker should be at the same path\n          return `${baseUrl}/kernel.worker.js`;\n        }\n        \n        // For local development or custom deployments\n        return `${baseUrl}/kernel.worker.js`;\n      }\n      \n      // Fallback to relative path from current location\n      const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n      return `${baseUrl}/dist/kernel.worker.js`;\n    }\n    \n    // Node.js or unknown environment - use relative path\n    // This may not work in Node.js but is provided as a fallback\n    return './kernel.worker.js';\n  }\n  \n  /**\n   * Helper function to check if an error is a KeyboardInterrupt\n   * @private\n   */\n  private isKeyboardInterrupt(error: any): boolean {\n    return error && \n           typeof error === 'object' && \n           (('type' in error && error.type === \"KeyboardInterrupt\") ||\n            ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n  }\n  \n  /**\n   * Helper function to create a standardized KeyboardInterrupt error result\n   * @private\n   */\n  private createKeyboardInterruptResult(): { success: boolean; error: Error; result: any } {\n    return {\n      success: false,\n      error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n      result: {\n        status: \"error\",\n        ename: \"KeyboardInterrupt\",\n        evalue: \"Execution interrupted by user\",\n        traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n      }\n    };\n  }\n  \n  /**\n   * Store an AbortController for a specific kernel execution\n   * @private\n   */\n  private storeAbortController(kernelId: string, executionId: string, controller: AbortController): void {\n    if (!this.abortControllers.has(kernelId)) {\n      this.abortControllers.set(kernelId, new Map());\n    }\n    this.abortControllers.get(kernelId)!.set(executionId, controller);\n  }\n\n  /**\n   * Remove and return an AbortController for a specific kernel execution\n   * @private\n   */\n  private removeAbortController(kernelId: string, executionId: string): AbortController | undefined {\n    const kernelControllers = this.abortControllers.get(kernelId);\n    if (!kernelControllers) return undefined;\n    \n    const controller = kernelControllers.get(executionId);\n    if (controller) {\n      kernelControllers.delete(executionId);\n      if (kernelControllers.size === 0) {\n        this.abortControllers.delete(kernelId);\n      }\n    }\n    return controller;\n  }\n\n  /**\n   * Abort all ongoing operations for a specific kernel\n   * @private\n   */\n  private abortAllKernelOperations(kernelId: string): void {\n    const kernelControllers = this.abortControllers.get(kernelId);\n    if (!kernelControllers) return;\n\n    for (const [executionId, controller] of kernelControllers) {\n      try {\n        controller.abort();\n        console.log(` Aborted execution ${executionId} for kernel ${kernelId}`);\n      } catch (error) {\n        console.warn(` Error aborting execution ${executionId}:`, error);\n      }\n    }\n    \n    // Clear all controllers for this kernel\n    this.abortControllers.delete(kernelId);\n  }\n  \n  constructor(options: IKernelManagerOptions = {}) {\n    super();\n    super.setMaxListeners(100); // Allow many listeners for kernel events\n    \n    // Set interruption mode (default to 'auto')\n    this.interruptionMode = options.interruptionMode || 'auto';\n    \n    // Set worker URL if provided\n    this.workerUrl = options.workerUrl;\n    \n    // Set default allowed kernel types (worker mode only for security)\n    this.allowedKernelTypes = options.allowedKernelTypes || [\n      { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n    ];\n    \n    // Initialize pool configuration with defaults based on allowed types\n    const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => \n      type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n    );\n    \n    this.poolConfig = {\n      enabled: false,\n      poolSize: 2,\n      autoRefill: true,\n      preloadConfigs: defaultPreloadConfigs,\n      ...options.pool\n    };\n    \n    // Validate that pool preload configs are within allowed types\n    if (this.poolConfig.preloadConfigs) {\n      this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n        const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n        if (!isAllowed) {\n          console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n        }\n        return isAllowed;\n      });\n    }\n    \n    // Start preloading if pool is enabled\n    if (this.poolConfig.enabled) {\n      this.preloadPool().catch(error => {\n        console.error(\"Error preloading kernel pool:\", error);\n      });\n    }\n  }\n  \n  \n  /**\n   * Generate a pool key for a given mode and language combination\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Pool key string\n   * @private\n   */\n  private getPoolKey(mode: KernelMode, language: KernelLanguage): string {\n    return `${mode}-${language}`;\n  }\n  \n  /**\n   * Get a kernel promise from the pool if available\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Kernel promise or null if none available\n   * @private\n   */\n  private getFromPool(mode: KernelMode, language: KernelLanguage): Promise<IKernelInstance> | null {\n    if (!this.poolConfig.enabled) {\n      return null;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    const poolPromises = this.pool.get(poolKey);\n    \n    if (!poolPromises || poolPromises.length === 0) {\n      return null;\n    }\n    \n    // Remove and return the first promise from the pool (FIFO)\n    const kernelPromise = poolPromises.shift()!;\n    \n    // Immediately trigger background refill to add one promise back\n    if (this.poolConfig.autoRefill) {\n      setTimeout(() => {\n        this.refillPoolSingle(mode, language).catch(error => {\n          console.error(`Error refilling single kernel for ${poolKey}:`, error);\n        });\n      }, 0);\n    }\n    \n    return kernelPromise;\n  }\n  \n  /**\n   * Add a kernel promise to the pool\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @param kernelPromise Kernel promise\n   * @private\n   */\n  private addToPool(mode: KernelMode, language: KernelLanguage, kernelPromise: Promise<IKernelInstance>): void {\n    if (!this.poolConfig.enabled) {\n      return;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    \n    if (!this.pool.has(poolKey)) {\n      this.pool.set(poolKey, []);\n    }\n    \n    const poolPromises = this.pool.get(poolKey)!;\n    \n    // Only add if we haven't reached the pool size limit\n    if (poolPromises.length < this.poolConfig.poolSize) {\n      poolPromises.push(kernelPromise);\n      \n      // Handle promise rejection to prevent unhandled rejections\n      kernelPromise.catch(error => {\n        console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n        // Remove the failed promise from the pool\n        const index = poolPromises.indexOf(kernelPromise);\n        if (index !== -1) {\n          poolPromises.splice(index, 1);\n        }\n      });\n    } else {\n      // Pool is full, let the excess promise resolve and then destroy the kernel\n      kernelPromise.then(kernel => {\n        kernel.destroy().catch(error => {\n          console.error(\"Error destroying excess pool kernel:\", error);\n        });\n      }).catch(error => {\n        console.error(\"Excess pool kernel promise rejected:\", error);\n      });\n    }\n  }\n  \n  /**\n   * Refill the pool with a single kernel promise\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @private\n   */\n  private async refillPoolSingle(mode: KernelMode, language: KernelLanguage): Promise<void> {\n    if (!this.poolConfig.enabled) {\n      return;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    const poolPromises = this.pool.get(poolKey) || [];\n    \n    // Only add one if we're below the pool size\n    if (poolPromises.length < this.poolConfig.poolSize) {\n      const kernelPromise = this.createPoolKernelPromise(mode, language);\n      this.addToPool(mode, language, kernelPromise);\n    }\n  }\n\n  /**\n   * Refill the pool for a specific configuration with parallel creation\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @private\n   */\n  private async refillPool(mode: KernelMode, language: KernelLanguage): Promise<void> {\n    if (!this.poolConfig.enabled) {\n      return;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    \n    // Check if already prefilling this pool key to prevent duplicates\n    if (this.prefillingInProgress.get(poolKey)) {\n      return;\n    }\n    \n    // Set prefilling flag\n    this.prefillingInProgress.set(poolKey, true);\n    \n    try {\n      const poolPromises = this.pool.get(poolKey) || [];\n      const needed = this.poolConfig.poolSize - poolPromises.length;\n      \n      if (needed <= 0) {\n        return;\n      }\n      \n      // Create all needed kernel promises in parallel\n      const newPromises = Array.from({ length: needed }, () => \n        this.createPoolKernelPromise(mode, language)\n      );\n      \n      // Add all promises to the pool\n      for (const kernelPromise of newPromises) {\n        this.addToPool(mode, language, kernelPromise);\n      }\n      \n    } catch (error) {\n      console.error(`Error refilling pool for ${poolKey}:`, error);\n    } finally {\n      // Always clear the prefilling flag\n      this.prefillingInProgress.set(poolKey, false);\n    }\n  }\n  \n  /**\n   * Create a kernel promise for the pool\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Promise that resolves to a kernel instance\n   * @private\n   */\n  private createPoolKernelPromise(mode: KernelMode, language: KernelLanguage): Promise<IKernelInstance> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const kernel = await this.createPoolKernel(mode, language);\n        // Mark as taken from pool\n        kernel.isFromPool = true;\n        resolve(kernel);\n      } catch (error) {\n        console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Create a kernel specifically for the pool\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Kernel instance\n   * @private\n   */\n  private async createPoolKernel(mode: KernelMode, language: KernelLanguage): Promise<IKernelInstance> {\n    // Generate a temporary ID for the pool kernel\n    const tempId = `pool-${crypto.randomUUID()}`;\n    \n    // Create kernel with minimal configuration\n    const options: IManagerKernelOptions = {\n      mode,\n      lang: language\n    };\n    \n    // Store options temporarily - but don't store incomplete instance in kernels map\n    // Instead, we'll pass the options directly to the creation methods\n    let instance: IKernelInstance;\n    \n    try {\n      if (mode === KernelMode.MAIN_THREAD) {\n        // For main thread, we need to temporarily store the instance for createMainThreadKernel\n        const tempInstance = {\n          id: tempId,\n          options,\n          mode,\n          language\n        };\n        this.kernels.set(tempId, tempInstance as unknown as IKernelInstance);\n        \n        try {\n          instance = await this.createMainThreadKernel(tempId);\n        } finally {\n          // Always clean up the temporary instance\n          this.kernels.delete(tempId);\n        }\n      } else {\n        // For worker mode, we need to temporarily store the instance for createWorkerKernel\n        const tempInstance = {\n          id: tempId,\n          options,\n          mode,\n          language\n        };\n        this.kernels.set(tempId, tempInstance as unknown as IKernelInstance);\n        \n        try {\n          instance = await this.createWorkerKernel(tempId);\n        } finally {\n          // Always clean up the temporary instance\n          this.kernels.delete(tempId);\n        }\n      }\n    } catch (error) {\n      // Ensure cleanup on any error\n      this.kernels.delete(tempId);\n      throw error;\n    }\n    \n    return instance;\n  }\n  \n  /**\n   * Preload the kernel pool with configured kernel types\n   * @private\n   */\n  private async preloadPool(): Promise<void> {\n    if (!this.poolConfig.enabled || this.isPreloading) {\n      return;\n    }\n    \n    this.isPreloading = true;\n    \n    try {\n      // Preload kernels for each configured type\n      for (const config of this.poolConfig.preloadConfigs) {\n        try {\n          await this.refillPool(config.mode, config.language);\n        } catch (error) {\n          console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n          // Continue with other configurations\n        }\n      }\n    } catch (error) {\n      console.error(\"Error during kernel pool preloading:\", error);\n    } finally {\n      this.isPreloading = false;\n    }\n  }\n  \n  /**\n   * Check if a kernel request can use the pool\n   * @param options Kernel creation options\n   * @returns True if the request can use pool\n   * @private\n   */\n  private canUsePool(options: IManagerKernelOptions): boolean {\n    // Don't use pool if it's disabled\n    if (!this.poolConfig.enabled) {\n      return false;\n    }\n    \n    // Don't use pool if custom filesystem or permissions are specified\n    if (options.filesystem || options.deno?.permissions) {\n      return false;\n    }\n    \n    // Don't use pool if custom timeouts are specified\n    if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n      return false;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Reassign a pool kernel with new ID and options\n   * @param poolKernel Kernel from pool\n   * @param newId New kernel ID\n   * @param options Kernel options\n   * @returns Updated kernel instance\n   * @private\n   */\n  private reassignPoolKernel(\n    poolKernel: IKernelInstance, \n    newId: string, \n    options: IManagerKernelOptions\n  ): IKernelInstance {\n    // Create a new instance object explicitly to avoid spread operator issues\n    const updatedInstance: IKernelInstance = {\n      id: newId,\n      kernel: poolKernel.kernel,\n      mode: poolKernel.mode,\n      language: poolKernel.language,\n      worker: poolKernel.worker,\n      created: new Date().toISOString(), // Update creation time\n      options: { ...poolKernel.options, ...options },\n      isFromPool: true,\n      destroy: poolKernel.destroy // Preserve the original destroy function\n    };\n    \n    // Verify the destroy function is properly set\n    if (typeof updatedInstance.destroy !== 'function') {\n      console.error('Failed to preserve destroy function during pool kernel reassignment');\n      console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n      console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n      throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n    }\n    \n    return updatedInstance;\n  }\n  \n  /**\n   * Get pool statistics for debugging/monitoring\n   * @returns Pool statistics\n   */\n  public getPoolStats(): Record<string, { available: number; total: number }> {\n    const stats: Record<string, { available: number; total: number }> = {};\n    \n    for (const [poolKey, promises] of this.pool.entries()) {\n      stats[poolKey] = {\n        available: promises.length,\n        total: this.poolConfig.poolSize\n      };\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Get pool configuration information\n   * @returns Pool configuration details\n   */\n  public getPoolConfig(): {\n    enabled: boolean;\n    poolSize: number;\n    autoRefill: boolean;\n    preloadConfigs: Array<{\n      mode: KernelMode;\n      language: KernelLanguage;\n    }>;\n    isPreloading: boolean;\n  } {\n    return {\n      enabled: this.poolConfig.enabled,\n      poolSize: this.poolConfig.poolSize,\n      autoRefill: this.poolConfig.autoRefill,\n      preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n      isPreloading: this.isPreloading\n    };\n  }\n  \n  /**\n   * Get the current worker URL configuration\n   * @returns The worker URL or undefined if using auto-detection\n   */\n  public getWorkerUrl(): string | undefined {\n    return this.workerUrl;\n  }\n  \n  /**\n   * Set a custom worker URL for kernel workers\n   * @param url The URL to the kernel.worker.js file\n   * @example\n   * // For CDN usage:\n   * manager.setWorkerUrl('https://cdn.jsdelivr.net/npm/web-python-kernel@latest/dist/kernel.worker.js');\n   * // For local development:\n   * manager.setWorkerUrl('/dist/kernel.worker.js');\n   */\n  public setWorkerUrl(url: string | undefined): void {\n    this.workerUrl = url;\n  }\n  \n  /**\n   * Create a new kernel instance\n   * @param options Options for creating the kernel\n   * @param options.id Optional custom ID for the kernel\n   * @param options.mode Optional kernel mode (main_thread or worker)\n   * @param options.lang Optional kernel language (python or typescript)\n   * @param options.namespace Optional namespace prefix for the kernel ID\n   * @param options.deno.permissions Optional Deno permissions for worker mode\n   * @param options.filesystem Optional filesystem mounting options\n   * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n   * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n   * @returns Promise resolving to the kernel instance ID\n   */\n  public async createKernel(options: IManagerKernelOptions = {}): Promise<string> {\n    // make sure the options.id does not contain colons because it will be used as a namespace prefix\n    if (options.id && options.id.includes(':')) {\n      throw new Error('Kernel ID cannot contain colons');\n    }\n    const baseId = options.id || crypto.randomUUID();\n    const mode = options.mode || KernelMode.WORKER;\n    const language = options.lang || KernelLanguage.PYTHON;\n    \n    // Check if the requested kernel type is allowed\n    if (!this.isKernelTypeAllowed(mode, language)) {\n      throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${\n        this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')\n      }`);\n    }\n    \n    // Apply namespace prefix if provided\n    const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n    \n    // Check if kernel with this ID already exists\n    if (this.kernels.has(id)) {\n      throw new Error(`Kernel with ID ${id} already exists`);\n    }\n    \n    // Try to get from pool if possible\n    if (this.canUsePool(options)) {\n      const poolKey = this.getPoolKey(mode, language);\n      \n      // Check if this kernel type is configured for pooling\n      const isPooledType = this.poolConfig.preloadConfigs.some(config => \n        config.mode === mode && config.language === language\n      );\n      \n      if (isPooledType) {\n        // First try to get from existing pool\n        let poolKernelPromise = this.getFromPool(mode, language);\n        \n        if (poolKernelPromise) {\n          return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n        }\n        \n        // Pool is empty, but this type should be pooled\n        // Create a new promise immediately and trigger background refill\n        try {\n          // Create a new kernel promise specifically for this request\n          const newKernelPromise = this.createPoolKernelPromise(mode, language);\n          \n          // Trigger background refill to replenish the pool for future requests\n          if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n              this.refillPool(mode, language).catch(error => {\n                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n              });\n            }, 0);\n          }\n          \n          return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n        } catch (error) {\n          console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n          // Fall through to on-demand creation as last resort\n        }\n      } else {\n        // This kernel type is not configured for pooling, try to get from pool anyway\n        // in case there are kernels available from previous configurations\n        const poolKernelPromise = this.getFromPool(mode, language);\n        if (poolKernelPromise) {\n          return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n        }\n      }\n    }\n    \n    // Fall back to creating a new kernel on-demand\n    return this.createOnDemandKernel(id, mode, language, options);\n  }\n  \n  /**\n   * Setup a pool kernel from a promise with new ID and options\n   * @param poolKernelPromise Kernel promise from pool\n   * @param id New kernel ID\n   * @param options Kernel options\n   * @returns Kernel ID (returned after kernel is ready)\n   * @private\n   */\n  private async setupPoolKernelFromPromise(\n    poolKernelPromise: Promise<IKernelInstance>, \n    id: string, \n    options: IManagerKernelOptions\n  ): Promise<string> {\n    try {\n      // Wait for the pool kernel to be ready\n      const poolKernel = await poolKernelPromise;\n      \n      // Reassign the pool kernel with the new ID and options\n      const instance = this.reassignPoolKernel(poolKernel, id, options);\n      \n      // For worker kernels, we need to recreate the event handler with the new ID\n      if (instance.mode === KernelMode.WORKER && instance.worker) {\n        // Get the worker and create new message channel\n        const worker = instance.worker;\n        \n        // Create a new message channel for the reassigned kernel\n        const { port1, port2 } = new MessageChannel();\n        \n        // Send the new event port to the worker\n        worker.postMessage({\n          type: \"SET_EVENT_PORT\",\n          port: port2\n        }, [port2]);\n        \n        // Create a new event handler with the correct kernel ID\n        const eventHandler = (event: MessageEvent) => {\n          if (event.data && event.data.type) {\n            // Emit the event from the manager with kernel ID\n            // This structure matches the setupEventForwarding method for main thread kernels\n            super.emit(event.data.type, {\n              kernelId: id,\n              data: event.data.data\n            });\n          }\n        };\n        \n        // Listen for events from the worker with the new handler\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        \n        // Update the destroy function to clean up the new event handler\n        const originalDestroy = instance.destroy;\n        instance.destroy = async () => {\n          port1.removeEventListener('message', eventHandler);\n          port1.close();\n          return originalDestroy();\n        };\n      }\n      \n      // Store the kernel instance\n      this.kernels.set(id, instance);\n      \n      // Forward kernel events to manager (for main thread kernels)\n      this.setupEventForwarding(instance);\n      \n      // Initialize activity tracking\n      this.updateKernelActivity(id);\n      \n      // Set up inactivity timeout if specified and greater than 0\n      if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n        this.setupInactivityTimeout(id, options.inactivityTimeout);\n      }\n      \n      // Setup handlers for stalled executions if maxExecutionTime is specified\n      if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n        this.setupStalledExecutionHandler(id);\n      }\n      \n      return id;\n    } catch (error) {\n      console.error(`Error setting up pool kernel ${id}:`, error);\n      // Emit an error event for this kernel\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: id,\n        data: {\n          ename: \"KernelSetupError\",\n          evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n          traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n        }\n      });\n      throw error; // Re-throw to let the caller handle it\n    }\n  }\n\n  /**\n   * Setup a pool kernel with new ID and options (for already resolved kernels)\n   * @param poolKernel Kernel from pool\n   * @param id New kernel ID\n   * @param options Kernel options\n   * @returns Kernel ID\n   * @private\n   */\n  private setupPoolKernel(\n    poolKernel: IKernelInstance, \n    id: string, \n    options: IManagerKernelOptions\n  ): string {\n    // Reassign the pool kernel with the new ID and options\n    const instance = this.reassignPoolKernel(poolKernel, id, options);\n    \n    // For worker kernels, we need to recreate the event handler with the new ID\n    if (instance.mode === KernelMode.WORKER && instance.worker) {\n      // Get the worker and create new message channel\n      const worker = instance.worker;\n      \n      // Create a new message channel for the reassigned kernel\n      const { port1, port2 } = new MessageChannel();\n      \n      // Send the new event port to the worker\n      worker.postMessage({\n        type: \"SET_EVENT_PORT\",\n        port: port2\n      }, [port2]);\n      \n      // Create a new event handler with the correct kernel ID\n      const eventHandler = (event: MessageEvent) => {\n        if (event.data && event.data.type) {\n          // Emit the event from the manager with kernel ID\n          // This structure matches the setupEventForwarding method for main thread kernels\n          super.emit(event.data.type, {\n            kernelId: id,\n            data: event.data.data\n          });\n        }\n      };\n      \n      // Listen for events from the worker with the new handler\n      port1.addEventListener('message', eventHandler);\n      port1.start();\n      \n      // Update the destroy function to clean up the new event handler\n      const originalDestroy = instance.destroy;\n      instance.destroy = async () => {\n        port1.removeEventListener('message', eventHandler);\n        port1.close();\n        return originalDestroy();\n      };\n    }\n    \n    // Store the kernel instance\n    this.kernels.set(id, instance);\n    \n    // Forward kernel events to manager (for main thread kernels)\n    this.setupEventForwarding(instance);\n    \n    // Initialize activity tracking\n    this.updateKernelActivity(id);\n    \n    // Set up inactivity timeout if specified and greater than 0\n    if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n      this.setupInactivityTimeout(id, options.inactivityTimeout);\n    }\n    \n    // Setup handlers for stalled executions if maxExecutionTime is specified\n    if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n      this.setupStalledExecutionHandler(id);\n    }\n    \n    return id;\n  }\n  \n  /**\n   * Create a kernel on-demand (not from pool)\n   * @param id Kernel ID\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @param options Kernel options\n   * @returns Kernel ID\n   * @private\n   */\n  private async createOnDemandKernel(\n    id: string, \n    mode: KernelMode, \n    language: KernelLanguage, \n    options: IManagerKernelOptions\n  ): Promise<string> {\n    // Store options temporarily to be used in createWorkerKernel\n    const tempInstance = {\n      id,\n      options: { ...options, lang: language },\n      mode,\n      language\n    };\n    this.kernels.set(id, tempInstance as unknown as IKernelInstance);\n    \n    // Create the appropriate kernel instance\n    let instance: IKernelInstance;\n    \n    if (mode === KernelMode.MAIN_THREAD) {\n      instance = await this.createMainThreadKernel(id);\n    } else {\n      instance = await this.createWorkerKernel(id);\n    }\n    \n    // Store the kernel instance\n    this.kernels.set(id, instance);\n    \n    // Forward kernel events to manager\n    this.setupEventForwarding(instance);\n    \n    // Initialize activity tracking\n    this.updateKernelActivity(id);\n    \n    // Set up inactivity timeout if specified and greater than 0\n    if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n      this.setupInactivityTimeout(id, options.inactivityTimeout);\n    }\n    \n    // Setup handlers for stalled executions if maxExecutionTime is specified\n    if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n      this.setupStalledExecutionHandler(id);\n    }\n    \n    return id;\n  }\n  \n  /**\n   * Create a kernel instance running in the main thread\n   * @param id Kernel ID\n   * @returns Kernel instance\n   */\n  private async createMainThreadKernel(id: string): Promise<IKernelInstance> {\n    // Get options from the temporary instance\n    const options = this.kernels.get(id)?.options || {};\n    const language = options.lang || KernelLanguage.PYTHON;\n    \n    // Create the Python kernel\n    const kernel = new Kernel();\n    \n    // Create the kernel instance\n    const instance: IKernelInstance = {\n      id,\n      kernel,\n      mode: KernelMode.MAIN_THREAD,\n      language,\n      created: new Date().toISOString(),\n      options,\n      destroy: async () => {\n        // Nothing special to do for main thread kernel\n        return Promise.resolve();\n      }\n    };\n    \n    // Initialize the kernel with filesystem options\n    const kernelOptions: IKernelOptions = {};\n\n    // Add filesystem options if provided\n    if (options.filesystem) {\n      kernelOptions.filesystem = options.filesystem;\n    }\n\n    // Add environment variables if provided\n    if (options.env) {\n      kernelOptions.env = options.env;\n    }\n\n    // Add lockFileURL if provided\n    if (options.lockFileURL) {\n      kernelOptions.lockFileURL = options.lockFileURL;\n    }\n\n    // Add autoSyncFs if provided\n    if (options.autoSyncFs !== undefined) {\n      kernelOptions.autoSyncFs = options.autoSyncFs;\n    }\n\n    // Initialize the kernel\n    await kernel.initialize(kernelOptions);\n    \n    return instance;\n  }\n  \n  /**\n   * Create a kernel instance running in a worker\n   * @param id Kernel ID\n   * @returns Kernel instance\n   */\n  private async createWorkerKernel(id: string): Promise<IKernelInstance> {\n    // Get permissions from options when creating the kernel\n    const options = this.kernels.get(id)?.options || {};\n    const language = options.lang || KernelLanguage.PYTHON;\n    \n    // Create a new worker with optional permissions\n    const workerOptions: WorkerOptions = {\n      type: \"module\",\n    };\n    \n    // If Deno permissions are provided, use them.\n    // Otherwise don't specify Deno permissions at all to inherit from host script\n    if (options.deno?.permissions) {\n      workerOptions.deno = {\n        permissions: options.deno.permissions\n      };\n    }\n    \n    // Determine the worker URL based on the environment\n    const workerUrl = this.resolveWorkerUrl();\n    const worker = new Worker(workerUrl, { type: 'classic' });\n    \n    // Create a message channel for events\n    const { port1, port2 } = new MessageChannel();\n    \n    // Create a promise that will resolve when the kernel is initialized\n    const initPromise = new Promise<void>((resolve, reject) => {\n      const initHandler = (event: MessageEvent) => {\n        if (event.data?.type === \"KERNEL_INITIALIZED\") {\n          if (event.data.data.success) {\n            port1.removeEventListener('message', initHandler);\n            resolve();\n          } else {\n            port1.removeEventListener('message', initHandler);\n            reject(new Error(\"Kernel initialization failed\"));\n          }\n        }\n      };\n      port1.addEventListener('message', initHandler);\n    });\n    \n    // Send the port to the worker\n    worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n    \n    // Create a proxy to the worker using Comlink\n    const kernelProxy = Comlink.wrap<IKernel>(worker);\n    \n    // Add a local event handler to bridge the worker events\n    // This works around the limitation that Comlink doesn't proxy event emitters\n    const eventHandler = (event: MessageEvent) => {\n      if (event.data && event.data.type) {\n        // Emit the event from the manager with kernel ID\n        // This structure matches the setupEventForwarding method for main thread kernels\n        super.emit(event.data.type, {\n          kernelId: id,\n          data: event.data.data\n        });\n      }\n    };\n    \n    // Listen for events from the worker\n    port1.addEventListener('message', eventHandler);\n    port1.start();\n    \n    // Initialize the kernel with filesystem options\n    // We need to pass these options to the worker\n    worker.postMessage({\n      type: \"INITIALIZE_KERNEL\",\n      options: {\n        filesystem: options.filesystem,\n        env: options.env,\n        lockFileURL: options.lockFileURL,\n        autoSyncFs: options.autoSyncFs,\n        lang: language\n      }\n    });\n    \n    // Wait for kernel initialization\n    await initPromise;\n    \n    // Set up interrupt buffer automatically for worker kernels\n    await this.setupWorkerInterruptBuffer(id, worker);\n    \n    // Create the kernel instance\n    const instance: IKernelInstance = {\n      id,\n      kernel: {\n        // Map methods from the Comlink proxy to the IKernel interface\n        initialize: async (options?: IKernelOptions) => {\n          return kernelProxy.initialize(options);\n        },\n        execute: async (code: string, parent?: any) => {\n          const result = await kernelProxy.execute(code, parent);\n          \n          // Handle Python worker results (no special display reconstruction needed)\n          \n          return result;\n        },\n        isInitialized: () => {\n          return kernelProxy.isInitialized();\n        },\n        inputReply: async (content: { value: string }) => {\n          return kernelProxy.inputReply(content);\n        },\n        // Map async getStatus method\n        getStatus: async () => {\n          try {\n            if (typeof kernelProxy.getStatus === 'function') {\n              return await kernelProxy.getStatus();\n            } else {\n              return \"unknown\";\n            }\n          } catch (error) {\n            return \"unknown\";\n          }\n        },\n        // Map completion methods\n        complete: async (code: string, cursor_pos: number, parent?: any) => {\n          try {\n            if (typeof kernelProxy.complete === 'function') {\n              return await kernelProxy.complete(code, cursor_pos, parent);\n            } else {\n              return { status: 'error', error: 'Completion not supported' };\n            }\n          } catch (error) {\n            return { status: 'error', error: String(error) };\n          }\n        },\n        inspect: async (code: string, cursor_pos: number, detail_level: 0 | 1, parent?: any) => {\n          try {\n            if (typeof kernelProxy.inspect === 'function') {\n              return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n            } else {\n              return { status: 'error', error: 'Inspection not supported' };\n            }\n          } catch (error) {\n            return { status: 'error', error: String(error) };\n          }\n        },\n        isComplete: async (code: string, parent?: any) => {\n          try {\n            if (typeof kernelProxy.isComplete === 'function') {\n              return await kernelProxy.isComplete(code, parent);\n            } else {\n              return { status: 'unknown' };\n            }\n          } catch (error) {\n            return { status: 'error', error: String(error) };\n          }\n        },\n        // Map interrupt methods\n        interrupt: async () => {\n          try {\n            if (typeof kernelProxy.interrupt === 'function') {\n              return await kernelProxy.interrupt();\n            } else {\n              return false;\n            }\n          } catch (error) {\n            return false;\n          }\n        },\n        setInterruptBuffer: (buffer: Uint8Array) => {\n          try {\n            if (typeof kernelProxy.setInterruptBuffer === 'function') {\n              kernelProxy.setInterruptBuffer(buffer);\n            }\n          } catch (error) {\n            console.warn('Failed to set interrupt buffer:', error);\n          }\n        },\n        // Map mountFS method\n        mountFS: async (mountPath: string, dirHandle?: FileSystemDirectoryHandle | null, permission?: 'read' | 'readwrite') => {\n          try {\n            if (typeof kernelProxy.mountFS === 'function') {\n              return await kernelProxy.mountFS(mountPath, dirHandle, permission);\n            } else {\n              throw new Error('mountFS is not supported by this kernel');\n            }\n          } catch (error) {\n            throw error;\n          }\n        },\n        // Map filesystem sync methods\n        getMountedFileSystems: () => {\n          try {\n            if (typeof kernelProxy.getMountedFileSystems === 'function') {\n              return kernelProxy.getMountedFileSystems();\n            } else {\n              return [];\n            }\n          } catch (error) {\n            console.warn('Failed to get mounted filesystems:', error);\n            return [];\n          }\n        },\n        syncFileSystem: async (mountPath: string) => {\n          try {\n            if (typeof kernelProxy.syncFileSystem === 'function') {\n              return await kernelProxy.syncFileSystem(mountPath);\n            } else {\n              return { success: false, error: 'syncFileSystem is not supported by this kernel' };\n            }\n          } catch (error) {\n            return { success: false, error: error instanceof Error ? error.message : String(error) };\n          }\n        },\n        upgradeFileSystemPermission: async (mountPath: string) => {\n          try {\n            if (typeof kernelProxy.upgradeFileSystemPermission === 'function') {\n              return await kernelProxy.upgradeFileSystemPermission(mountPath);\n            } else {\n              return { success: false, error: 'upgradeFileSystemPermission is not supported by this kernel' };\n            }\n          } catch (error) {\n            return { success: false, error: error instanceof Error ? error.message : String(error) };\n          }\n        },\n        // Map comm methods\n        commInfo: async (target_name: string | null, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commInfo === 'function') {\n              return await kernelProxy.commInfo(target_name, parent);\n            } else {\n              return { comms: {}, status: 'ok' };\n            }\n          } catch (error) {\n            return { comms: {}, status: 'error', error: String(error) };\n          }\n        },\n        commOpen: async (content: any, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commOpen === 'function') {\n              return await kernelProxy.commOpen(content, parent);\n            }\n          } catch (error) {\n            console.warn('Failed to open comm:', error);\n          }\n        },\n        commMsg: async (content: any, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commMsg === 'function') {\n              return await kernelProxy.commMsg(content, parent);\n            }\n          } catch (error) {\n            console.warn('Failed to send comm message:', error);\n          }\n        },\n        commClose: async (content: any, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commClose === 'function') {\n              return await kernelProxy.commClose(content, parent);\n            }\n          } catch (error) {\n            console.warn('Failed to close comm:', error);\n          }\n        }\n      } as unknown as IKernel,\n      mode: KernelMode.WORKER,\n      language,\n      worker,\n      created: new Date().toISOString(),\n      options, // Store the options for reference\n      destroy: async () => {\n        // Clean up the worker and event listeners\n        port1.removeEventListener('message', eventHandler);\n        port1.close();\n        worker.terminate();\n        return Promise.resolve();\n      }\n    };\n    \n    return instance;\n  }\n  \n  /**\n   * Setup event forwarding from kernel to manager\n   * @param instance Kernel instance\n   */\n  private setupEventForwarding(instance: IKernelInstance): void {\n    // Only needed for main thread kernels as worker events are handled directly\n    if (instance.mode === KernelMode.MAIN_THREAD) {\n      // Forward all kernel events to the manager with kernel ID\n      Object.values(KernelEvents).forEach((eventType) => {\n        // Access the kernel as a Kernel instance which extends EventEmitter\n        const kernelEmitter = instance.kernel as unknown as EventEmitter;\n        \n        // Add event listener to forward events\n        kernelEmitter.on(eventType, (data: any) => {\n          super.emit(eventType, {\n            kernelId: instance.id,\n            data\n          });\n        });\n      });\n    }\n  }\n  \n  /**\n   * Get a kernel instance by ID\n   * @param id Kernel ID\n   * @returns Kernel instance or undefined if not found\n   */\n  public getKernel(id: string): IKernelInstance | undefined {\n    return this.kernels.get(id);\n  }\n  \n  /**\n   * Get a list of all kernel IDs\n   * @returns Array of kernel IDs\n   */\n  public getKernelIds(): string[] {\n    return Array.from(this.kernels.keys());\n  }\n  \n  /**\n   * Get a list of all kernels with their details\n   * @param namespace Optional namespace to filter kernels by\n   * @returns Array of kernel information objects\n   */\n  public async listKernels(namespace?: string): Promise<Array<{\n    id: string;\n    mode: KernelMode;\n    language: KernelLanguage;\n    status: \"active\" | \"busy\" | \"unknown\";\n    created: string;\n    namespace?: string;\n    deno?: {\n      permissions?: IDenoPermissions;\n    };\n  }>> {\n          const filteredKernels = Array.from(this.kernels.entries())\n        .filter(([id]) => {\n          // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n          if (id.startsWith(\"pool-\")) return false;\n          \n          if (!namespace) return true;\n          return id.startsWith(`${namespace}:`);\n        });\n\n      // Use Promise.all to get all statuses concurrently\n      const kernelInfos = await Promise.all(\n        filteredKernels.map(async ([id, instance]) => {\n          // Extract namespace from id if present\n          const namespaceMatch = id.match(/^([^:]+):/);\n          const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n          \n          // Get status using async getStatus method\n          let status: \"active\" | \"busy\" | \"unknown\" = \"unknown\";\n          try {\n            if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n              status = await instance.kernel.getStatus();\n            }\n          } catch (error) {\n            console.warn(`Error getting status for kernel ${id}:`, error);\n            status = \"unknown\";\n          }\n          \n          return {\n            id,\n            mode: instance.mode,\n            language: instance.language,\n            status,\n            created: instance.created || new Date().toISOString(),\n            namespace: extractedNamespace,\n            deno: instance.options?.deno\n          };\n        })\n      );\n\n      return kernelInfos;\n  }\n  \n  /**\n   * Destroy a kernel instance\n   * @param id Kernel ID\n   * @returns Promise resolving when kernel is destroyed\n   */\n  public async destroyKernel(id: string): Promise<void> {\n    const instance = this.kernels.get(id);\n    \n    if (!instance) {\n      // Handle gracefully - kernel may already be destroyed\n      return;\n    }\n    \n    // Verify the destroy function exists\n    if (typeof instance.destroy !== 'function') {\n      throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n    }\n    \n    // Abort all ongoing operations for this kernel first\n    this.abortAllKernelOperations(id);\n    \n    // Clear any inactivity timer\n    this.clearInactivityTimeout(id);\n    \n    // Clean up execution timeouts\n    if (this.executionTimeouts.has(id)) {\n      const timeouts = this.executionTimeouts.get(id)!;\n      for (const timeoutId of timeouts.values()) {\n        clearTimeout(timeoutId);\n      }\n      this.executionTimeouts.delete(id);\n    }\n    \n    // Clean up execution start times\n    if (this.executionStartTimes.has(id)) {\n      this.executionStartTimes.delete(id);\n    }\n    \n    // Clean up execution metadata\n    if (this.executionMetadata.has(id)) {\n      this.executionMetadata.delete(id);\n    }\n    \n    // Clean up interrupt buffers\n    if (this.interruptBuffers.has(id)) {\n      this.interruptBuffers.delete(id);\n    }\n    \n    // Clean up ongoing executions tracking\n    this.ongoingExecutions.delete(id);\n    \n    // Clean up activity tracking\n    this.lastActivityTime.delete(id);\n    \n    // Remove all event listeners for this kernel\n    this.removeAllKernelListeners(id);\n    \n    // Destroy the kernel instance\n    await instance.destroy();\n    \n    // Remove the kernel from the map\n    this.kernels.delete(id);\n  }\n  \n  /**\n   * Destroy all kernel instances\n   * @param namespace Optional namespace to filter kernels to destroy\n   * @returns Promise resolving when all kernels are destroyed\n   */\n  public async destroyAll(namespace?: string): Promise<void> {\n    const ids = Array.from(this.kernels.keys())\n      .filter(id => {\n        if (!namespace) return true;\n        return id.startsWith(`${namespace}:`);\n      });\n    \n    // Destroy all kernels, but skip incomplete instances\n    const destroyPromises = ids.map(async (id) => {\n      const instance = this.kernels.get(id);\n      if (!instance || typeof instance.destroy !== 'function') {\n        console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n        // Just remove it from the map\n        this.kernels.delete(id);\n        return;\n      }\n      return this.destroyKernel(id);\n    });\n    \n    await Promise.all(destroyPromises);\n    \n    // If no namespace specified, also clean up the pool\n    if (!namespace) {\n      await this.destroyPool();\n    }\n  }\n  \n  /**\n   * Destroy all kernels in the pool\n   * @private\n   */\n  private async destroyPool(): Promise<void> {\n    \n    const destroyPromises: Promise<void>[] = [];\n    \n    for (const [poolKey, promises] of this.pool.entries()) {\n      \n      for (const kernelPromise of promises) {\n        // Handle each promise - if it resolves, destroy the kernel\n        const destroyPromise = kernelPromise.then(kernel => {\n          return kernel.destroy();\n        }).catch(error => {\n          console.error(`Error destroying pool kernel from promise:`, error);\n          // Don't re-throw to avoid unhandled rejections\n        });\n        \n        destroyPromises.push(destroyPromise);\n      }\n    }\n    \n    // Wait for all pool kernels to be destroyed\n    await Promise.all(destroyPromises);\n    \n    // Clear the pool and prefilling flags\n    this.pool.clear();\n    this.prefillingInProgress.clear();\n  }\n  \n  /**\n   * Register an event listener for a specific kernel's events\n   * @param kernelId Kernel ID\n   * @param eventType Event type\n   * @param listener Event listener\n   */\n  public onKernelEvent(kernelId: string, eventType: KernelEvents, listener: (data: any) => void): void {\n    // Check if kernel exists\n    if (!this.kernels.has(kernelId)) {\n      throw new Error(`Kernel with ID ${kernelId} not found`);\n    }\n    \n    // Create wrapper that filters events for this specific kernel\n    const wrapper: ListenerWrapper = {\n      original: listener,\n      wrapped: (event: { kernelId: string, data: any }) => {\n        if (event.kernelId === kernelId) {\n          // Pass just the data to the listener\n          // The data structure is consistent across main thread and worker modes\n          listener(event.data);\n        }\n      }\n    };\n    \n    // Store the wrapper for later removal\n    this.storeListener(kernelId, eventType, listener, wrapper);\n    \n    // Add the wrapped listener to the manager\n    super.on(eventType, wrapper.wrapped);\n  }\n  \n  /**\n   * Remove an event listener for a specific kernel\n   * @param kernelId Kernel ID\n   * @param eventType Event type\n   * @param listener Event listener\n   */\n  public offKernelEvent(kernelId: string, eventType: KernelEvents, listener: (data: any) => void): void {\n    const wrapper = this.getListener(kernelId, eventType, listener);\n    \n    if (wrapper) {\n      // Remove the wrapped listener from the manager\n      super.removeListener(eventType, wrapper.wrapped);\n      \n      // Remove the wrapper from our tracking map\n      this.removeStoredListener(kernelId, eventType, listener);\n    }\n  }\n  \n  /**\n   * Store a listener wrapper for later removal\n   */\n  private storeListener(\n    kernelId: string, \n    eventType: string, \n    original: Function, \n    wrapper: ListenerWrapper\n  ): void {\n    // Get or create kernel map\n    if (!this.listenerWrappers.has(kernelId)) {\n      this.listenerWrappers.set(kernelId, new Map());\n    }\n    const kernelMap = this.listenerWrappers.get(kernelId)!;\n    \n    // Get or create event type map\n    if (!kernelMap.has(eventType)) {\n      kernelMap.set(eventType, new Map());\n    }\n    const eventMap = kernelMap.get(eventType)!;\n    \n    // Store the wrapper\n    eventMap.set(original, wrapper);\n  }\n  \n  /**\n   * Get a stored listener wrapper\n   */\n  private getListener(\n    kernelId: string, \n    eventType: string, \n    original: Function\n  ): ListenerWrapper | undefined {\n    const kernelMap = this.listenerWrappers.get(kernelId);\n    if (!kernelMap) return undefined;\n    \n    const eventMap = kernelMap.get(eventType);\n    if (!eventMap) return undefined;\n    \n    return eventMap.get(original);\n  }\n  \n  /**\n   * Remove a stored listener wrapper\n   */\n  private removeStoredListener(\n    kernelId: string, \n    eventType: string, \n    original: Function\n  ): void {\n    const kernelMap = this.listenerWrappers.get(kernelId);\n    if (!kernelMap) return;\n    \n    const eventMap = kernelMap.get(eventType);\n    if (!eventMap) return;\n    \n    // Remove the listener\n    eventMap.delete(original);\n    \n    // Clean up empty maps\n    if (eventMap.size === 0) {\n      kernelMap.delete(eventType);\n    }\n    \n    if (kernelMap.size === 0) {\n      this.listenerWrappers.delete(kernelId);\n    }\n  }\n  \n  /**\n   * Remove all listeners for a specific kernel\n   */\n  private removeAllKernelListeners(kernelId: string): void {\n    const kernelMap = this.listenerWrappers.get(kernelId);\n    if (!kernelMap) return;\n    \n    // For each event type\n    for (const [eventType, eventMap] of kernelMap.entries()) {\n      // For each original listener\n      for (const wrapper of eventMap.values()) {\n        // Remove the wrapped listener from the manager\n        super.removeListener(eventType, wrapper.wrapped);\n      }\n    }\n    \n    // Clear the kernel's listener map\n    this.listenerWrappers.delete(kernelId);\n  }\n  \n  /**\n   * Get all listeners for a specific kernel and event type\n   * @param kernelId Kernel ID\n   * @param eventType Event type\n   * @returns Array of listeners\n   */\n  public getListeners(kernelId: string, eventType: KernelEvents): ((data: any) => void)[] {\n    const kernelListeners = this.listenerWrappers.get(kernelId);\n    if (!kernelListeners) {\n      return [];\n    }\n    \n    const eventListeners = kernelListeners.get(eventType);\n    if (!eventListeners) {\n      return [];\n    }\n    \n    return Array.from(eventListeners.keys()) as ((data: any) => void)[];\n  }\n\n  /**\n   * Execute Python code with streaming output\n   * This method works in both main thread and worker modes\n   * @param kernelId ID of the kernel to use\n   * @param code The Python code to execute\n   * @param parent Optional parent message header\n   * @returns AsyncGenerator yielding intermediate outputs\n   */\n  public async* executeStream(\n    kernelId: string, \n    code: string, \n    parent: any = {}\n  ): AsyncGenerator<any, { success: boolean, result?: any, error?: Error }, void> {\n    const instance = this.getKernel(kernelId);\n    \n    if (!instance) {\n      throw new Error(`Kernel with ID ${kernelId} not found`);\n    }\n    \n    // Update kernel activity\n    this.updateKernelActivity(kernelId);\n    \n    // Track this execution with the code for better monitoring\n    const executionId = this.trackExecution(kernelId, code);\n    \n    // Create AbortController for this execution to enable cancellation\n    const abortController = new AbortController();\n    this.storeAbortController(kernelId, executionId, abortController);\n    \n    try {\n      // For main thread kernels, we can use the executeStream method directly\n      if (instance.mode === KernelMode.MAIN_THREAD) {\n        const kernel = instance.kernel as unknown as { \n          executeStream: (code: string, parent: any) => AsyncGenerator<any, any, void> \n        };\n        \n        // Forward to the kernel's executeStream method\n        if (typeof kernel.executeStream === 'function') {\n          try {\n            yield* kernel.executeStream(code, parent);\n            \n            // Update activity after execution completes\n            this.updateKernelActivity(kernelId);\n            \n            // Complete execution tracking\n            this.completeExecution(kernelId, executionId);\n            \n            return { success: true };\n          } catch (error) {\n            console.error(`Error in main thread executeStream:`, error);\n            \n            // Update activity even if there's an error\n            this.updateKernelActivity(kernelId);\n            \n            // Complete execution tracking even on error\n            this.completeExecution(kernelId, executionId);\n            \n            return { \n              success: false, \n              error: error instanceof Error ? error : new Error(String(error))\n            };\n          }\n        }\n      }\n      \n      // For worker mode, we need to implement streaming via events with proper isolation\n      try {\n        // Event-based approach for worker kernels or main thread kernels without executeStream\n        const streamQueue: any[] = [];\n        let executionComplete = false;\n        let executionResult: { success: boolean, result?: any, error?: Error } = { success: true };\n        \n        // Store handler references for guaranteed cleanup\n        const eventHandlers = new Map<string, (event: { kernelId: string, data: any }) => void>();\n        \n        // Helper function to clean up all event handlers\n        const cleanupHandlers = () => {\n          for (const [eventType, handler] of eventHandlers.entries()) {\n            super.off(eventType as any, handler);\n          }\n          eventHandlers.clear();\n        };\n        \n        // Create execution-specific event handlers that include executionId check\n        const createHandler = (eventType: string) => {\n          const handler = (event: { kernelId: string, data: any }) => {\n            // Only process events for this specific kernel and while this execution is active\n            if (event.kernelId === kernelId && !executionComplete) {\n              streamQueue.push({\n                type: eventType,\n                data: event.data,\n                executionId // Include execution ID for debugging\n              });\n              \n              // Events also count as activity\n              this.updateKernelActivity(kernelId);\n            }\n          };\n          eventHandlers.set(eventType, handler);\n          return handler;\n        };\n        \n        // Create and register all event handlers\n        const handleStreamEvent = createHandler('stream');\n        const handleDisplayEvent = createHandler('display_data');\n        const handleUpdateDisplayEvent = createHandler('update_display_data');\n        const handleResultEvent = createHandler('execute_result');\n        const handleErrorEvent = createHandler('execute_error');\n        \n        // Register handlers\n        super.on(KernelEvents.STREAM, handleStreamEvent);\n        super.on(KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n        super.on(KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n        super.on(KernelEvents.EXECUTE_RESULT, handleResultEvent);\n        super.on(KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n        \n        // Create a promise that will resolve when execution is complete\n        const executionPromise = new Promise<{ success: boolean, result?: any, error?: Error }>((resolve, reject) => {\n          // Set up a handler for execution errors specifically\n          const handleExecutionError = (event: { kernelId: string, data: any }) => {\n            if (event.kernelId === kernelId && !executionComplete) {\n              // Mark execution as complete to stop processing more events\n              executionComplete = true;\n              \n              // Store the error for the final result\n              executionResult = {\n                success: false,\n                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                result: event.data\n              };\n              \n              // Update activity\n              this.updateKernelActivity(kernelId);\n              \n              resolve(executionResult);\n            }\n          };\n          \n          // Add error handler to our cleanup list\n          eventHandlers.set('execute_error_completion', handleExecutionError);\n          super.on(KernelEvents.EXECUTE_ERROR, handleExecutionError);\n          \n          // Check if already aborted\n          if (abortController.signal.aborted) {\n            executionComplete = true;\n            resolve({\n              success: false,\n              error: new Error('Execution was aborted')\n            });\n            return;\n          }\n          \n          // Set up abort handler\n          const abortHandler = () => {\n            if (!executionComplete) {\n              console.log(` Execution ${executionId} aborted`);\n              executionComplete = true;\n              \n              resolve({\n                success: false,\n                error: new Error('Execution was aborted')\n              });\n            }\n          };\n          \n          abortController.signal.addEventListener('abort', abortHandler);\n          \n          // Execute the code\n          // We know the execute method is available directly on the kernel object\n          try {\n            const executePromise = instance.kernel.execute(code, parent);\n            \n            executePromise.then((result) => {\n              // Only process if execution hasn't been marked complete already\n              if (!executionComplete) {\n                // Check if the execution result indicates an error (for Python kernels)\n                if (result.success && result.result && result.result.status === \"error\") {\n                  // Handle as error\n                  const errorData = {\n                    status: result.result.status,\n                    ename: result.result.ename,\n                    evalue: result.result.evalue,\n                    traceback: result.result.traceback\n                  };\n                  \n                  // Push error to stream queue directly \n                  streamQueue.push({\n                    type: 'error',\n                    data: errorData,\n                    executionId\n                  });\n                  \n                  // Update execution result to reflect the error\n                  executionResult = {\n                    success: false,\n                    error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                    result: result.result\n                  };\n                } else {\n                  executionResult = result;\n                }\n                \n                executionComplete = true;\n                \n                // Update activity when execution completes\n                this.updateKernelActivity(kernelId);\n                \n                resolve(executionResult);\n              }\n            }).catch((error) => {\n              // Only process if execution hasn't been marked complete already\n              if (!executionComplete) {\n                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                \n                // Check if this is a KeyboardInterrupt and handle it specially\n                let errorResult;\n                if (this.isKeyboardInterrupt(error)) {\n                  console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                  errorResult = this.createKeyboardInterruptResult();\n                  \n                  // Also push to stream queue for immediate feedback\n                  streamQueue.push({\n                    type: 'error',\n                    data: errorResult.result,\n                    executionId\n                  });\n                } else {\n                  // Handle other errors normally\n                  errorResult = {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                  };\n                }\n                \n                executionComplete = true;\n                executionResult = errorResult;\n                \n                // Update activity even on error\n                this.updateKernelActivity(kernelId);\n                \n                resolve(errorResult);\n              }\n            });\n          } catch (error) {\n            // Only process if execution hasn't been marked complete already\n            if (!executionComplete) {\n              console.error(`Error calling execute for kernel ${kernelId}:`, error);\n              \n              // Simple error handling\n              const errorResult = {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n              };\n              \n              executionComplete = true;\n              executionResult = errorResult;\n              \n              // Update activity even on direct error\n              this.updateKernelActivity(kernelId);\n              \n              resolve(errorResult);\n            }\n          }\n        });\n        \n        // Use try/finally to guarantee cleanup\n        try {\n          // Monitor the stream queue and yield results\n          // Continue until execution is complete AND all queued events have been yielded\n          while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n            // If there are items in the queue, yield them\n            if (streamQueue.length > 0) {\n              const event = streamQueue.shift();\n              yield event;\n              continue;\n            }\n            \n            // If no more events but execution is not complete, wait a little\n            if (!executionComplete) {\n              // Use abort signal to cancel the wait\n              try {\n                await new Promise((resolve, reject) => {\n                  const timeoutId = setTimeout(resolve, 10);\n                  abortController.signal.addEventListener('abort', () => {\n                    clearTimeout(timeoutId);\n                    reject(new Error('Aborted'));\n                  });\n                });\n              } catch (error) {\n                // If aborted, break out of loop\n                if (abortController.signal.aborted) {\n                  break;\n                }\n              }\n            }\n          }\n          \n          // Check if execution was aborted during stream monitoring\n          if (abortController.signal.aborted && !executionComplete) {\n            throw new Error('Execution was aborted during stream monitoring');\n          }\n          \n          // Wait for the final result\n          const result = await executionPromise;\n          return result;\n        } finally {\n          // ALWAYS clean up event handlers regardless of how execution ends\n          cleanupHandlers();\n          \n          // Remove AbortController to prevent memory leaks\n          this.removeAbortController(kernelId, executionId);\n          \n          // Complete execution tracking\n          this.completeExecution(kernelId, executionId);\n        }\n      } catch (error) {\n        // Complete execution tracking on any outer error\n        this.completeExecution(kernelId, executionId);\n        \n        console.error(`Unexpected error in executeStream:`, error);\n        return {\n          success: false, \n          error: error instanceof Error ? error : new Error(String(error))\n        };\n      }\n    } catch (error) {\n      // Complete execution tracking on any outer error\n      this.completeExecution(kernelId, executionId);\n      \n      console.error(`Unexpected error in executeStream:`, error);\n      return {\n        success: false, \n        error: error instanceof Error ? error : new Error(String(error))\n      };\n    }\n  }\n\n  /**\n   * Track a new execution task for a kernel\n   * @param kernelId Kernel ID\n   * @param code Optional code being executed for metadata\n   * @returns Unique execution ID\n   * @private\n   */\n  private trackExecution(kernelId: string, code?: string): string {\n    // Create a unique execution ID\n    const executionId = `exec-${crypto.randomUUID()}`;\n    const startTime = Date.now();\n    \n    // Reset interrupt buffer for worker kernels before each new execution\n    // This ensures the kernel can be interrupted multiple times\n    const instance = this.kernels.get(kernelId);\n    if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n      const interruptBuffer = this.interruptBuffers.get(kernelId)!;\n      // Reset buffer to 0 (no interrupt signal) to ensure clean state\n      interruptBuffer[0] = 0;\n    }\n    \n    // Get or create the set of ongoing executions for this kernel\n    if (!this.ongoingExecutions.has(kernelId)) {\n      this.ongoingExecutions.set(kernelId, new Set());\n    }\n    \n    // Add this execution to the set\n    this.ongoingExecutions.get(kernelId)!.add(executionId);\n    \n    // Track execution start time\n    if (!this.executionStartTimes.has(kernelId)) {\n      this.executionStartTimes.set(kernelId, new Map());\n    }\n    this.executionStartTimes.get(kernelId)!.set(executionId, startTime);\n    \n    // Track execution metadata\n    if (!this.executionMetadata.has(kernelId)) {\n      this.executionMetadata.set(kernelId, new Map());\n    }\n    \n    // Update activity timestamp\n    this.updateKernelActivity(kernelId);\n    \n    // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n    if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n      // Get or create the map of execution timeouts for this kernel\n      if (!this.executionTimeouts.has(kernelId)) {\n        this.executionTimeouts.set(kernelId, new Map());\n      }\n      \n      // Set a timeout for this execution with enhanced handling\n      const timeoutId = setTimeout(() => {\n        console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n        \n        // Get execution metadata for better error reporting\n        const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n        const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n        \n        // Emit a stalled execution event with enhanced information\n        super.emit('execution_stalled', {\n          kernelId,\n          executionId,\n          maxExecutionTime: instance.options.maxExecutionTime,\n          actualRuntime,\n          code: metadata?.code || code,\n          startTime: metadata?.startTime || startTime\n        });\n        \n        // Auto-handle stuck execution if configured\n        this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n      }, instance.options.maxExecutionTime);\n      \n      // Store the timeout ID\n      this.executionTimeouts.get(kernelId)!.set(executionId, timeoutId);\n      \n      // Store metadata including timeout ID\n      this.executionMetadata.get(kernelId)!.set(executionId, {\n        startTime,\n        code,\n        timeoutId\n      });\n    } else {\n      // Store metadata without timeout ID\n      this.executionMetadata.get(kernelId)!.set(executionId, {\n        startTime,\n        code\n      });\n    }\n    \n    return executionId;\n  }\n  \n  /**\n   * Complete tracking for an execution\n   * @param kernelId Kernel ID\n   * @param executionId Execution ID\n   * @private\n   */\n  private completeExecution(kernelId: string, executionId: string): void {\n    // Clear any execution timeout\n    if (this.executionTimeouts.has(kernelId)) {\n      const timeouts = this.executionTimeouts.get(kernelId)!;\n      if (timeouts.has(executionId)) {\n        clearTimeout(timeouts.get(executionId));\n        timeouts.delete(executionId);\n      }\n      \n      // Clean up empty maps\n      if (timeouts.size === 0) {\n        this.executionTimeouts.delete(kernelId);\n      }\n    }\n    \n    // Clean up execution start times\n    if (this.executionStartTimes.has(kernelId)) {\n      const startTimes = this.executionStartTimes.get(kernelId)!;\n      startTimes.delete(executionId);\n      \n      // Clean up empty maps\n      if (startTimes.size === 0) {\n        this.executionStartTimes.delete(kernelId);\n      }\n    }\n    \n    // Clean up execution metadata\n    if (this.executionMetadata.has(kernelId)) {\n      const metadata = this.executionMetadata.get(kernelId)!;\n      metadata.delete(executionId);\n      \n      // Clean up empty maps\n      if (metadata.size === 0) {\n        this.executionMetadata.delete(kernelId);\n      }\n    }\n    \n    // Remove from ongoing executions\n    if (this.ongoingExecutions.has(kernelId)) {\n      const executions = this.ongoingExecutions.get(kernelId)!;\n      executions.delete(executionId);\n      \n      // Clean up empty sets\n      if (executions.size === 0) {\n        this.ongoingExecutions.delete(kernelId);\n        \n        // Update activity timestamp for completed execution\n        this.updateKernelActivity(kernelId);\n      }\n    }\n  }\n  \n  /**\n   * Check if a kernel has any ongoing executions\n   * @param kernelId Kernel ID\n   * @returns True if the kernel has ongoing executions\n   * @private\n   */\n  private hasOngoingExecutions(kernelId: string): boolean {\n    return this.ongoingExecutions.has(kernelId) && \n           this.ongoingExecutions.get(kernelId)!.size > 0;\n  }\n  \n  /**\n   * Get the count of ongoing executions for a kernel\n   * @param id Kernel ID\n   * @returns Number of ongoing executions\n   */\n  public getOngoingExecutionCount(id: string): number {\n    if (!this.ongoingExecutions.has(id)) {\n      return 0;\n    }\n    return this.ongoingExecutions.get(id)!.size;\n  }\n  \n  /**\n   * Set up an inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @param timeout Timeout in milliseconds\n   * @private\n   */\n  private setupInactivityTimeout(id: string, timeout: number): void {\n    // Don't set up a timer if timeout is 0 or negative\n    if (timeout <= 0) {\n      return;\n    }\n    \n    // Always clear any existing timer first\n    this.clearInactivityTimeout(id);\n    \n    // Calculate remaining time based on last activity\n    const lastActivity = this.lastActivityTime.get(id) || Date.now();\n    const elapsed = Date.now() - lastActivity;\n    const remainingTime = Math.max(0, timeout - elapsed);\n    \n    // If no time remaining, destroy immediately\n    if (remainingTime === 0) {\n      // Check if the kernel has ongoing executions before shutting down\n      if (this.hasOngoingExecutions(id)) {\n        // Reset the timer to check again later\n        this.setupInactivityTimeout(id, timeout);\n        return;\n      }\n      \n      // Destroy immediately\n      this.destroyKernel(id).catch(error => {\n        console.error(`Error destroying inactive kernel ${id}:`, error);\n      });\n      return;\n    }\n    \n    // Create a timer to destroy the kernel after the remaining timeout\n    const timer = setTimeout(() => {\n      // Check if the kernel has ongoing executions before shutting down\n      if (this.hasOngoingExecutions(id)) {\n        // Reset the timer to check again later\n        this.setupInactivityTimeout(id, timeout);\n        return;\n      }\n      \n      this.destroyKernel(id).catch(error => {\n        console.error(`Error destroying inactive kernel ${id}:`, error);\n      });\n    }, remainingTime);\n    \n    // Store the timer ID\n    this.inactivityTimers.set(id, timer);\n  }\n  \n  /**\n   * Clear any existing inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @private\n   */\n  private clearInactivityTimeout(id: string): void {\n    if (this.inactivityTimers.has(id)) {\n      const timerId = this.inactivityTimers.get(id);\n      clearTimeout(timerId);\n      this.inactivityTimers.delete(id);\n    }\n  }\n\n  /**\n   * Update activity timestamp for a kernel and reset inactivity timer if present\n   * @param id Kernel ID\n   * @private\n   */\n  private updateKernelActivity(id: string): void {\n    // Update the last activity time\n    this.lastActivityTime.set(id, Date.now());\n    \n    // Get the kernel options\n    const instance = this.kernels.get(id);\n    if (!instance) return;\n    \n    const timeout = instance.options.inactivityTimeout;\n    \n    // Reset the inactivity timer if timeout is enabled (greater than 0)\n    if (timeout && timeout > 0) {\n      this.setupInactivityTimeout(id, timeout);\n    }\n  }\n\n  /**\n   * Get the last activity time for a kernel\n   * @param id Kernel ID\n   * @returns Last activity time in milliseconds since epoch, or undefined if not found\n   */\n  public getLastActivityTime(id: string): number | undefined {\n    return this.lastActivityTime.get(id);\n  }\n\n  /**\n   * Get the inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @returns Inactivity timeout in milliseconds, or undefined if not set\n   */\n  public getInactivityTimeout(id: string): number | undefined {\n    const instance = this.kernels.get(id);\n    if (!instance) return undefined;\n    \n    return instance.options.inactivityTimeout;\n  }\n\n  /**\n   * Set or update the inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @param timeout Timeout in milliseconds, or 0 to disable\n   * @returns True if the timeout was set, false if the kernel was not found\n   */\n  public setInactivityTimeout(id: string, timeout: number): boolean {\n    const instance = this.kernels.get(id);\n    if (!instance) return false;\n    \n    // Update the timeout in the options\n    instance.options.inactivityTimeout = timeout;\n    \n    // Clear any existing timer\n    this.clearInactivityTimeout(id);\n    \n    // If timeout is greater than 0, set up a new timer\n    if (timeout > 0) {\n      this.setupInactivityTimeout(id, timeout);\n    }\n    \n    return true;\n  }\n\n  /**\n   * Get time until auto-shutdown for a kernel\n   * @param id Kernel ID\n   * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n   */\n  public getTimeUntilShutdown(id: string): number | undefined {\n    const instance = this.kernels.get(id);\n    if (!instance) return undefined;\n    \n    const timeout = instance.options.inactivityTimeout;\n    if (!timeout || timeout <= 0) return undefined;\n    \n    const lastActivity = this.lastActivityTime.get(id);\n    if (!lastActivity) return undefined;\n    \n    const elapsedTime = Date.now() - lastActivity;\n    const remainingTime = timeout - elapsedTime;\n    \n    return Math.max(0, remainingTime);\n  }\n\n  /**\n   * Get the map of inactivity timers (for debugging/testing only)\n   * @returns Object with kernel IDs as keys and timer IDs as values\n   */\n  public getInactivityTimers(): Record<string, number> {\n    // Convert Map to Object for easier inspection\n    const timers: Record<string, number> = {};\n    this.inactivityTimers.forEach((value, key) => {\n      timers[key] = value;\n    });\n    return timers;\n  }\n\n  /**\n   * Set up a handler for stalled executions\n   * @param id Kernel ID\n   * @private\n   */\n  private setupStalledExecutionHandler(id: string): void {\n    // Listen for stalled execution events\n    super.on(KernelEvents.EXECUTION_STALLED, (event: { kernelId: string, executionId: string, maxExecutionTime: number }) => {\n      if (event.kernelId === id) {\n        console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n        \n        // Emit an event for clients to handle\n        const instance = this.kernels.get(id);\n        if (instance) {\n          super.emit(KernelEvents.EXECUTE_ERROR, {\n            kernelId: id,\n            data: {\n              ename: \"ExecutionStalledError\",\n              evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n              traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n            }\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Force terminate a potentially stuck kernel\n   * @param id Kernel ID\n   * @param reason Optional reason for termination\n   * @returns Promise resolving to true if the kernel was terminated\n   */\n  public async forceTerminateKernel(id: string, reason = \"Force terminated due to stalled execution\"): Promise<boolean> {\n    const instance = this.kernels.get(id);\n    \n    if (!instance) {\n      return false;\n    }\n    \n    try {\n      // Log the forced termination\n      console.warn(`Force terminating kernel ${id}: ${reason}`);\n      \n      // Emit an error event to notify clients\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: id,\n        data: {\n          ename: \"KernelForcedTermination\",\n          evalue: reason,\n          traceback: [\"Kernel was forcefully terminated by the system.\"]\n        }\n      });\n      \n      // Destroy the kernel\n      await this.destroyKernel(id);\n      return true;\n    } catch (error) {\n      console.error(`Error during forced termination of kernel ${id}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get information about ongoing executions for a kernel\n   * @param id Kernel ID\n   * @returns Information about ongoing executions with accurate timing\n   */\n  public getExecutionInfo(id: string): { \n    count: number; \n    isStuck: boolean; \n    executionIds: string[];\n    longestRunningTime?: number;\n    executions: Array<{\n      id: string;\n      startTime: number;\n      runtime: number;\n      code?: string;\n      isStuck: boolean;\n    }>;\n  } {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      return { count: 0, isStuck: false, executionIds: [], executions: [] };\n    }\n    \n    // Handle partially initialized kernels where options may not be fully set\n    if (!instance.options) {\n      return { count: 0, isStuck: false, executionIds: [], executions: [] };\n    }\n    \n    const executionIds = this.ongoingExecutions.get(id) \n      ? Array.from(this.ongoingExecutions.get(id)!)\n      : [];\n    \n    const count = executionIds.length;\n    const currentTime = Date.now();\n    const maxExecutionTime = instance.options.maxExecutionTime;\n    \n    // Build detailed execution information\n    const executions: Array<{\n      id: string;\n      startTime: number;\n      runtime: number;\n      code?: string;\n      isStuck: boolean;\n    }> = [];\n    \n    let longestRunningTime: number | undefined = undefined;\n    let anyStuck = false;\n    \n    // Get execution start times and metadata\n    const startTimes = this.executionStartTimes.get(id);\n    const metadata = this.executionMetadata.get(id);\n    \n    for (const executionId of executionIds) {\n      const startTime = startTimes?.get(executionId);\n      const execMetadata = metadata?.get(executionId);\n      \n      if (startTime !== undefined) {\n        const runtime = currentTime - startTime;\n        const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n        \n        executions.push({\n          id: executionId,\n          startTime,\n          runtime,\n          code: execMetadata?.code,\n          isStuck\n        });\n        \n        // Track longest running time\n        if (longestRunningTime === undefined || runtime > longestRunningTime) {\n          longestRunningTime = runtime;\n        }\n        \n        // Track if any execution is stuck\n        if (isStuck) {\n          anyStuck = true;\n        }\n      } else {\n        // Fallback for executions without start time tracking\n        console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n        executions.push({\n          id: executionId,\n          startTime: 0,\n          runtime: 0,\n          code: execMetadata?.code,\n          isStuck: false\n        });\n      }\n    }\n    \n    // Sort executions by start time (oldest first)\n    executions.sort((a, b) => a.startTime - b.startTime);\n    \n    return {\n      count,\n      isStuck: anyStuck,\n      executionIds,\n      longestRunningTime,\n      executions\n    };\n  }\n\n  /**\n   * Execute Python code in a kernel\n   * Uses executeStream to collect all outputs and return them\n   * @param kernelId ID of the kernel to use\n   * @param code Python code to execute\n   * @param parent Optional parent message header\n   * @returns Promise resolving to execution result with collected outputs\n   */\n  public async execute(\n    kernelId: string,\n    code: string,\n    parent: any = {}\n  ): Promise<{ success: boolean, outputs?: any, error?: Error, ename?: string, evalue?: string, traceback?: any }> {\n    const instance = this.getKernel(kernelId);\n    \n    if (!instance) {\n      throw new Error(`Kernel with ID ${kernelId} not found`);\n    }\n    return await instance.kernel.execute(code, parent);\n  }\n\n  /**\n   * Check if a kernel type is allowed\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns True if the kernel type is allowed\n   * @private\n   */\n  private isKernelTypeAllowed(mode: KernelMode, language: KernelLanguage): boolean {\n    return this.allowedKernelTypes.some(type => \n      type.mode === mode && type.language === language\n    );\n  }\n  \n  /**\n   * Get the list of allowed kernel types\n   * @returns Array of allowed kernel type configurations\n   */\n  public getAllowedKernelTypes(): Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }> {\n    return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n  }\n\n  /**\n   * Ping a kernel to reset its activity timer and extend the deadline\n   * @param id Kernel ID\n   * @returns True if the kernel was pinged successfully, false if not found\n   */\n  public pingKernel(id: string): boolean {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      return false;\n    }\n    \n    // Update kernel activity (this will reset the inactivity timer)\n    this.updateKernelActivity(id);\n    \n    return true;\n  }\n\n  /**\n   * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n   * @param id Kernel ID\n   * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n   */\n  public async restartKernel(id: string): Promise<boolean> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      console.warn(`Cannot restart kernel ${id}: kernel not found`);\n      return false;\n    }\n    \n    try {\n      // Store the current configuration\n      const currentConfig = {\n        mode: instance.mode,\n        language: instance.language,\n        options: { ...instance.options }\n      };\n      \n      // Extract namespace from ID if present\n      let namespace: string | undefined;\n      let baseId: string;\n      \n      if (id.includes(':')) {\n        const parts = id.split(':');\n        namespace = parts[0];\n        baseId = parts[1];\n      } else {\n        baseId = id;\n      }\n      \n      // Destroy the existing kernel\n      await this.destroyKernel(id);\n      \n      // Create a new kernel with the same configuration\n      const restartOptions: IManagerKernelOptions = {\n        id: baseId,\n        mode: currentConfig.mode,\n        lang: currentConfig.language,\n        namespace,\n        deno: currentConfig.options.deno,\n        filesystem: currentConfig.options.filesystem,\n        inactivityTimeout: currentConfig.options.inactivityTimeout,\n        maxExecutionTime: currentConfig.options.maxExecutionTime\n      };\n      \n      // Create the new kernel\n      const newKernelId = await this.createKernel(restartOptions);\n      \n      // Verify the new kernel has the same ID\n      if (newKernelId !== id) {\n        console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n        return false;\n      }\n      \n      return true;\n      \n    } catch (error) {\n      console.error(`Error restarting kernel ${id}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Interrupt a running kernel execution\n   * @param id Kernel ID\n   * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n   */\n  public async interruptKernel(id: string): Promise<boolean> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n      return false;\n    }\n    \n    try {\n      if (instance.mode === KernelMode.WORKER && instance.worker) {\n        // For worker kernels, use SharedArrayBuffer interrupt method\n        return await this.interruptWorkerKernel(id, instance);\n      } else {\n        // For main thread kernels, try to interrupt (will throw error if not supported)\n        return await this.interruptMainThreadKernel(id, instance);\n      }\n    } catch (error) {\n      console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n      return false;\n    }\n  }\n  \n  /**\n   * Interrupt a main thread kernel\n   * @param id Kernel ID\n   * @param instance Kernel instance\n   * @returns Promise resolving to interrupt success\n   * @private\n   */\n  private async interruptMainThreadKernel(id: string, instance: IKernelInstance): Promise<boolean> {\n    // Main thread kernels don't support proper interruption like worker kernels do\n    // Even if they have an interrupt method, it's limited and unreliable\n    throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n  }\n  \n  /**\n   * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n   * @param id Kernel ID\n   * @param instance Kernel instance\n   * @returns Promise resolving to interrupt success\n   * @private\n   */\n  private async interruptWorkerKernel(id: string, instance: IKernelInstance): Promise<boolean> {\n    try {\n      const worker = instance.worker;\n      if (!worker) {\n        console.error(`Worker not found for kernel ${id}`);\n        return false;\n      }\n      \n      // If interruption mode is 'kernel-interrupt', use fallback directly\n      if (this.interruptionMode === 'kernel-interrupt') {\n        return await this.interruptWorkerKernelFallback(id, worker);\n      }\n      \n      // Check if we already have an interrupt buffer for this kernel\n      let interruptBuffer = this.interruptBuffers.get(id);\n      \n      if (!interruptBuffer) {\n        // Create a new SharedArrayBuffer for interrupt control\n        try {\n          // Try to create SharedArrayBuffer (requires specific security headers)\n          const sharedBuffer = new SharedArrayBuffer(1);\n          interruptBuffer = new Uint8Array(sharedBuffer);\n          \n          // Initialize buffer to 0 (no interrupt signal)\n          interruptBuffer[0] = 0;\n          \n          // Store the buffer for future use\n          this.interruptBuffers.set(id, interruptBuffer);\n          \n          // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n          worker.postMessage({\n            type: \"SET_INTERRUPT_BUFFER\",\n            buffer: interruptBuffer\n          });\n          \n          // Wait for the worker to confirm buffer setup\n          await new Promise<void>((resolve, reject) => {\n            const timeout = setTimeout(() => {\n              reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n            }, 2000);\n            \n            const handler = (event: MessageEvent) => {\n              if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                worker.removeEventListener(\"message\", handler);\n                clearTimeout(timeout);\n                resolve();\n              }\n            };\n            \n            worker.addEventListener(\"message\", handler);\n          });\n          \n          console.log(`Interrupt buffer set up for kernel ${id}`);\n          \n        } catch (error) {\n          // Handle based on interruption mode\n          if (this.interruptionMode === 'shared-array-buffer') {\n            // If explicitly set to shared-array-buffer, this is an error\n            console.error(` Cannot create SharedArrayBuffer for interrupt handling in kernel ${id}`);\n            throw new Error(`SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })`);\n          } else {\n            // Auto mode: fall back to kernel.interrupt()\n            console.info(` Using message-based interrupt for kernel ${id} (SharedArrayBuffer not available)`);\n            \n            // Fallback: use message-based interrupt\n            return await this.interruptWorkerKernelFallback(id, worker);\n          }\n        }\n      }\n      \n      // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n      console.log(`Setting interrupt signal for kernel ${id}...`);\n      interruptBuffer[0] = 2;\n      \n      // Wait for Pyodide to process the interrupt\n      // Pyodide will reset the buffer to 0 when it processes the interrupt\n      let attempts = 0;\n      const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n      \n      while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        attempts++;\n      }\n      \n      if (interruptBuffer[0] === 0) {\n        console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n        return true;\n      } else {\n        console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n        // Still return true as we set the signal - the interrupt may be processed later\n        return true;\n      }\n      \n    } catch (error) {\n      console.error(`Error interrupting worker kernel ${id}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n   * @param id Kernel ID\n   * @param worker Worker instance\n   * @returns Promise resolving to interrupt success\n   * @private\n   */\n  private async interruptWorkerKernelFallback(id: string, worker: Worker): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      // Set up a listener for the interrupt response\n      const responseHandler = (event: MessageEvent) => {\n        if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n          worker.removeEventListener(\"message\", responseHandler);\n          const success = event.data.data?.success || false;\n          resolve(success);\n        }\n      };\n      \n      // Listen for the response\n      worker.addEventListener(\"message\", responseHandler);\n      \n      // Send the interrupt message\n      worker.postMessage({\n        type: \"INTERRUPT_KERNEL\"\n      });\n      \n      // Set a timeout in case we don't get a response\n      setTimeout(() => {\n        worker.removeEventListener(\"message\", responseHandler);\n        console.warn(` Interrupt request timed out for kernel ${id} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`);\n        resolve(false);\n      }, 5000); // 5 second timeout\n    });\n  }\n\n  /**\n   * Handle a stuck execution with configurable strategies\n   * @param kernelId Kernel ID\n   * @param executionId Execution ID that's stuck\n   * @param actualRuntime How long the execution has been running\n   * @param code The code that was being executed\n   * @private\n   */\n  private async handleStuckExecution(kernelId: string, executionId: string, actualRuntime: number, code?: string): Promise<void> {\n    const instance = this.kernels.get(kernelId);\n    if (!instance) {\n      return;\n    }\n    \n    console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n    \n    // Strategy 1: Try to interrupt the kernel first\n    const interruptSuccess = await this.interruptKernel(kernelId);\n    \n    if (interruptSuccess) {\n      console.log(`Successfully interrupted kernel ${kernelId}`);\n      \n      // Emit an execution error to notify clients\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: kernelId,\n        data: {\n          ename: \"ExecutionInterrupted\",\n          evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n          traceback: [\n            `Execution was automatically interrupted due to timeout.`,\n            `Runtime: ${actualRuntime}ms`,\n            `Max allowed: ${instance.options.maxExecutionTime}ms`,\n            code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n          ]\n        }\n      });\n      \n      return;\n    }\n    \n    // Strategy 2: If interrupt failed, try restarting the kernel\n    console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n    const restartSuccess = await this.restartKernel(kernelId);\n    \n    if (restartSuccess) {\n      console.log(`Successfully restarted kernel ${kernelId}`);\n      \n      // Emit a restart notification\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: kernelId,\n        data: {\n          ename: \"KernelRestarted\",\n          evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n          traceback: [\n            `Kernel was automatically restarted due to stuck execution.`,\n            `Runtime: ${actualRuntime}ms`,\n            `Max allowed: ${instance.options.maxExecutionTime}ms`,\n            `Interrupt attempt failed, kernel was restarted instead.`,\n            code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n          ]\n        }\n      });\n      \n      return;\n    }\n    \n    // Strategy 3: If restart failed, force terminate the kernel\n    console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n    const terminateSuccess = await this.forceTerminateKernel(\n      kernelId, \n      `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`\n    );\n    \n    if (terminateSuccess) {\n      console.log(`Successfully terminated kernel ${kernelId}`);\n    } else {\n      console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n      \n      // Emit a critical error\n      super.emit('kernel_unrecoverable', {\n        kernelId: kernelId,\n        executionId: executionId,\n        actualRuntime: actualRuntime,\n        code: code,\n        message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n      });\n    }\n  }\n\n  /**\n   * Get detailed information about stuck executions across all kernels\n   * @returns Array of stuck execution details\n   */\n  public getStuckExecutions(): Array<{\n    kernelId: string;\n    executionId: string;\n    startTime: number;\n    runtime: number;\n    maxAllowed: number;\n    code?: string;\n    kernelMode: KernelMode;\n    kernelLanguage: KernelLanguage;\n  }> {\n    const stuckExecutions: Array<{\n      kernelId: string;\n      executionId: string;\n      startTime: number;\n      runtime: number;\n      maxAllowed: number;\n      code?: string;\n      kernelMode: KernelMode;\n      kernelLanguage: KernelLanguage;\n    }> = [];\n    \n    const currentTime = Date.now();\n    \n    for (const [kernelId, instance] of this.kernels.entries()) {\n      // Skip pool kernels\n      if (kernelId.startsWith(\"pool-\")) continue;\n      \n      // Skip kernels without maxExecutionTime configured\n      if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n        continue;\n      }\n      \n      const maxExecutionTime = instance.options.maxExecutionTime;\n      const startTimes = this.executionStartTimes.get(kernelId);\n      const metadata = this.executionMetadata.get(kernelId);\n      const ongoingExecs = this.ongoingExecutions.get(kernelId);\n      \n      if (!ongoingExecs || ongoingExecs.size === 0) {\n        continue;\n      }\n      \n      for (const executionId of ongoingExecs) {\n        const startTime = startTimes?.get(executionId);\n        if (startTime === undefined) continue;\n        \n        const runtime = currentTime - startTime;\n        \n        // Check if this execution is stuck\n        if (runtime > maxExecutionTime) {\n          const execMetadata = metadata?.get(executionId);\n          \n          stuckExecutions.push({\n            kernelId,\n            executionId,\n            startTime,\n            runtime,\n            maxAllowed: maxExecutionTime,\n            code: execMetadata?.code,\n            kernelMode: instance.mode,\n            kernelLanguage: instance.language\n          });\n        }\n      }\n    }\n    \n    // Sort by runtime (longest running first)\n    stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n    \n    return stuckExecutions;\n  }\n\n  /**\n   * Force interrupt all stuck executions across all kernels\n   * @returns Promise resolving to array of intervention results\n   */\n  public async handleAllStuckExecutions(): Promise<Array<{\n    kernelId: string;\n    executionId: string;\n    action: 'interrupted' | 'restarted' | 'terminated' | 'failed';\n    success: boolean;\n    error?: string;\n  }>> {\n    const stuckExecutions = this.getStuckExecutions();\n    const results: Array<{\n      kernelId: string;\n      executionId: string;\n      action: 'interrupted' | 'restarted' | 'terminated' | 'failed';\n      success: boolean;\n      error?: string;\n    }> = [];\n    \n    console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n    \n    // Group by kernel to avoid multiple interventions on the same kernel\n    const kernelGroups = new Map<string, typeof stuckExecutions>();\n    for (const exec of stuckExecutions) {\n      if (!kernelGroups.has(exec.kernelId)) {\n        kernelGroups.set(exec.kernelId, []);\n      }\n      kernelGroups.get(exec.kernelId)!.push(exec);\n    }\n    \n    // Handle each kernel's stuck executions\n    for (const [kernelId, executions] of kernelGroups) {\n      try {\n        // Pick the longest running execution as the primary one\n        const primaryExec = executions[0]; // Already sorted by runtime desc\n        \n        console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n        \n        // Use the automated handling system\n        await this.handleStuckExecution(\n          kernelId, \n          primaryExec.executionId, \n          primaryExec.runtime, \n          primaryExec.code\n        );\n        \n        // Mark all executions for this kernel as handled\n        for (const exec of executions) {\n          results.push({\n            kernelId: exec.kernelId,\n            executionId: exec.executionId,\n            action: 'interrupted', // We don't know the exact action, but it was handled\n            success: true\n          });\n        }\n        \n      } catch (error) {\n        console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n        \n        // Mark all executions for this kernel as failed\n        for (const exec of executions) {\n          results.push({\n            kernelId: exec.kernelId,\n            executionId: exec.executionId,\n            action: 'failed',\n            success: false,\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Set up interrupt buffer for a worker kernel during creation\n   * @param id Kernel ID\n   * @param worker Worker instance\n   * @private\n   */\n  private async setupWorkerInterruptBuffer(id: string, worker: Worker): Promise<void> {\n    // Skip SharedArrayBuffer setup if mode is 'kernel-interrupt'\n    if (this.interruptionMode === 'kernel-interrupt') {\n      console.log(`Skipping SharedArrayBuffer setup for kernel ${id} - using kernel.interrupt() mode`);\n      return;\n    }\n    \n    try {\n      // Python kernels support interrupt buffers\n      \n      // For Python kernels, create actual SharedArrayBuffer\n      const sharedBuffer = new SharedArrayBuffer(1);\n      const interruptBuffer = new Uint8Array(sharedBuffer);\n      \n      // Initialize buffer to 0 (no interrupt signal)\n      interruptBuffer[0] = 0;\n      \n      // Store the buffer for future use\n      this.interruptBuffers.set(id, interruptBuffer);\n      \n      // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n      worker.postMessage({\n        type: \"SET_INTERRUPT_BUFFER\",\n        buffer: interruptBuffer\n      });\n      \n      // Wait for the worker to confirm buffer setup\n      await new Promise<void>((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n        }, 5000);\n        \n        const handler = (event: MessageEvent) => {\n          if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n            worker.removeEventListener(\"message\", handler);\n            clearTimeout(timeout);\n            resolve();\n          }\n        };\n        \n        worker.addEventListener(\"message\", handler);\n      });\n      \n    } catch (error) {\n      // Handle based on interruption mode\n      if (this.interruptionMode === 'shared-array-buffer') {\n        // If explicitly set to shared-array-buffer, this is an error\n        console.error(` SharedArrayBuffer required but not available for kernel ${id}`);\n        throw new Error(`SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.`);\n      } else {\n        // Auto mode: fall back to kernel.interrupt()\n        console.info(` SharedArrayBuffer not available for kernel ${id}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`);\n        // Don't throw - kernel can still work without interrupt buffer\n      }\n    }\n  }\n\n  /**\n   * Get information about mounted filesystems for a specific kernel\n   * @param id Kernel ID\n   * @returns Promise resolving to array of mounted filesystem info\n   */\n  public async getMountedFileSystems(id: string): Promise<Array<{\n    mountPath: string;\n    permission: 'read' | 'readwrite';\n    canSync: boolean;\n  }>> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      throw new Error(`Kernel ${id} not found`);\n    }\n\n    try {\n      if (typeof instance.kernel.getMountedFileSystems === 'function') {\n        return instance.kernel.getMountedFileSystems();\n      } else {\n        console.warn(`Kernel ${id} does not support getMountedFileSystems method`);\n        return [];\n      }\n    } catch (error) {\n      console.error(`Error getting mounted filesystems for kernel ${id}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Manually sync a specific mounted filesystem for a kernel\n   * @param id Kernel ID\n   * @param mountPath The path of the mounted filesystem to sync\n   * @returns Promise resolving to sync result\n   */\n  public async syncFileSystem(id: string, mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      throw new Error(`Kernel ${id} not found`);\n    }\n\n    try {\n      if (typeof instance.kernel.syncFileSystem === 'function') {\n        return await instance.kernel.syncFileSystem(mountPath);\n      } else {\n        console.warn(`Kernel ${id} does not support syncFileSystem method`);\n        return {\n          success: false,\n          error: 'syncFileSystem is not supported by this kernel'\n        };\n      }\n    } catch (error) {\n      console.error(`Error syncing filesystem for kernel ${id}:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Upgrade a mounted filesystem from read-only to read-write permission\n   * @param id Kernel ID\n   * @param mountPath The path of the mounted filesystem to upgrade\n   * @returns Promise resolving to upgrade result\n   */\n  public async upgradeFileSystemPermission(id: string, mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      throw new Error(`Kernel ${id} not found`);\n    }\n\n    try {\n      if (typeof instance.kernel.upgradeFileSystemPermission === 'function') {\n        return await instance.kernel.upgradeFileSystemPermission(mountPath);\n      } else {\n        console.warn(`Kernel ${id} does not support upgradeFileSystemPermission method`);\n        return {\n          success: false,\n          error: 'upgradeFileSystemPermission is not supported by this kernel'\n        };\n      }\n    } catch (error) {\n      console.error(`Error upgrading filesystem permission for kernel ${id}:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n}","// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n  private events: { [key: string]: Function[] } = {};\n\n  on(eventName: string, listener: Function) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(listener);\n  }\n\n  off(eventName: string, listener: Function) {\n    if (!this.events[eventName]) return;\n    const index = this.events[eventName].indexOf(listener);\n    if (index > -1) {\n      this.events[eventName].splice(index, 1);\n    }\n  }\n\n  emit(eventName: string, ...args: any[]) {\n    if (!this.events[eventName]) return;\n    this.events[eventName].forEach(listener => listener(...args));\n  }\n\n  setMaxListeners(n: number) {\n    // No-op for browser compatibility\n  }\n}\n\n// @ts-ignore Importing from npm\nimport { loadPyodide } from \"./pyodide-loader\";\n\n// Import types and enums\nimport { KernelEvents, IEventData, IMessage, IKernel, IKernelOptions, IFileSystemMountOptions, IKernelExecuteOptions, IEventEmitter } from \"./types\";\n\n// Import PyPI URLs\nimport {\n  pipliteWheelUrl,\n  pyodide_kernelWheelUrl,\n  ipykernelWheelUrl,\n  allJSONUrl,\n  widgetsnbextensionWheelUrl,\n  widgetsnbextensionWheelUrl1\n} from './_pypi';\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\nexport { KernelEvents } from \"./types\";\nexport type {\n  IKernel,\n  IKernelOptions,\n  IFileSystemMountOptions,\n  IKernelExecuteOptions,\n  IMessage,\n  IEventData,\n  IEventEmitter,\n  INativeFSHandle\n} from \"./types\";\n\nexport { KernelMode, KernelLanguage } from \"./manager\";\n\n\n\n\nexport class Kernel extends EventEmitter implements IKernel {\n  private pyodide: any;\n  private initialized = false;\n  private initPromise: Promise<void> | null = null;\n  \n  // FileSystem options\n  private filesystemOptions: IFileSystemMountOptions = {\n    enabled: false,\n    root: \".\",\n    mountPoint: \"/home/pyodide\"\n  };\n  \n  // Kernel options\n  private lockFileURL?: string;\n  \n  // Kernel components\n  private _kernel: any;\n  private _interpreter: any;\n  private _stdout_stream: any;\n  private _stderr_stream: any;\n  \n  // Input handling\n  private _resolveInputReply: ((value: any) => void) | null = null;\n  \n  // Execution state\n  private _parent_header: any = {};\n  private executionCount = 0;\n  private _status: \"active\" | \"busy\" | \"unknown\" = \"unknown\";\n  \n  // Interrupt handling\n  private _interruptBuffer: Uint8Array | null = null;\n  private _interruptSupported = false;\n  \n  // Environment variables\n  private environmentVariables: Record<string, string> = {};\n\n  // Native filesystem handles\n  private nativeFsHandles: Map<string, { \n    syncfs: () => Promise<void>; \n    dirHandle: FileSystemDirectoryHandle;\n    permission: 'read' | 'readwrite';\n    nativefs: any;\n  }> = new Map();\n  private autoSyncFs: boolean = false;\n\n  // Unique identifier for this kernel instance\n  private readonly kernelId: string;\n\n  constructor() {\n    super();\n    super.setMaxListeners(20);\n    // Generate a unique ID for this kernel instance\n    this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n  }\n\n  // Async method for kernel status\n  async getStatus(): Promise<\"active\" | \"busy\" | \"unknown\"> {\n    return this._status;\n  }\n\n  /**\n   * Initialize the kernel with maximum performance optimizations\n   * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n   */\n  public async initialize(options?: IKernelOptions): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n    \n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Set filesystem options if provided\n    if (options?.filesystem) {\n      this.filesystemOptions = {\n        ...this.filesystemOptions,\n        ...options.filesystem\n      };\n    }\n\n    // Set environment variables if provided\n    if (options?.env) {\n      this.environmentVariables = { ...options.env };\n    }\n\n    // Set lockFileURL if provided\n    if (options?.lockFileURL) {\n      this.lockFileURL = options.lockFileURL;\n    }\n\n    // Set autoSyncFs if provided\n    if (options?.autoSyncFs !== undefined) {\n      this.autoSyncFs = options.autoSyncFs;\n    }\n\n    this.initPromise = this._initializeInternal();\n    return this.initPromise;\n  }\n  \n  /**\n   * Initialize the kernel with maximum performance optimizations\n   * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n   */\n  private async _initializeInternal(): Promise<void> {\n    const startTime = Date.now();\n    console.log(\" Starting optimized kernel initialization...\");\n    \n    try {\n      // Load Pyodide from CDN\n      const pyodideStartTime = Date.now();\n      \n      // Configure pyodide options\n      const pyodideConfig: any = {};\n      if (this.lockFileURL) {\n        pyodideConfig.lockFileURL = this.lockFileURL;\n        console.log(` Using lockFileURL: ${this.lockFileURL}`);\n      }\n      \n      // Use our CDN loader - it will automatically handle main thread vs worker\n      this.pyodide = await loadPyodide(pyodideConfig);\n      const pyodideTime = Date.now() - pyodideStartTime;\n      console.log(` Pyodide loaded in ${pyodideTime}ms`);\n      \n      // Initialize core components in parallel\n      if (this.lockFileURL) {\n        // When using lockFileURL, packages are pre-installed, skip package installation\n        console.log(\" Using lock file - skipping package installation\");\n        const [,] = await Promise.all([\n          // 1. FileSystem mounting (if enabled)\n          this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n          // 2. Environment variables setup\n          this.setEnvironmentVariables()\n        ]);\n        \n        // Initialize globals directly (packages are already available)\n        await this.initGlobals();\n      } else {\n        // Standard initialization with package installation\n        const [, ,] = await Promise.all([\n          // 1. FileSystem mounting (if enabled)\n          this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n          // 2. Package manager initialization\n          this.initPackageManager(),\n          // 3. Environment variables setup\n          this.setEnvironmentVariables()\n        ]);\n        \n        // Install packages and initialize globals\n        await this.initKernel();\n        await this.initGlobals();\n      }\n      \n      const totalTime = Date.now() - startTime;\n      console.log(` KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n      console.log(` Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n      \n      // Mark as initialized\n      this.initialized = true;\n      this._status = \"active\";\n      console.log(\" Kernel is now ACTIVE and ready for execution!\");\n      \n    } catch (error) {\n      console.error(\" Kernel initialization failed:\", error);\n      this._status = \"unknown\";\n      throw error;\n    }\n  }\n  \n  /**\n   * Mount the local filesystem to the Pyodide environment\n   */\n  private async mountFileSystem(): Promise<void> {\n    try {\n      console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n      \n      // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n      // Simple and direct mounting of the filesystem\n      await this.pyodide.FS.mount(\n        this.pyodide.FS.filesystems.NODEFS,\n        { root: this.filesystemOptions.root || \".\" },\n        this.filesystemOptions.mountPoint || \"/home/pyodide\"\n      );\n      \n      console.log(\"FileSystem mounted successfully\");\n      \n      // Verify the mount by listing the directory\n      try {\n        const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n        console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n      } catch (error) {\n        console.error(`Error listing mounted directory: ${error}`);\n      }\n    } catch (error) {\n      console.error(\"Error mounting filesystem:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize the Pyodide package manager with optimized wheel loading\n   * OPTIMIZED: Smart caching and parallel wheel installation\n   */\n  private async initPackageManager(): Promise<void> {\n    const startTime = Date.now();\n    console.log(\" Initializing optimized package manager...\");\n    \n    try {\n      // Load micropip and packaging in parallel\n      console.log(\" Loading micropip, packaging...\");\n      await this.pyodide.loadPackage(['micropip', 'packaging']);\n      console.log(\" Loaded micropip, packaging\");\n      \n      // Get the base URL - use window.location for browser or fallback for worker\n      let baseUrl: string;\n      if (typeof window !== 'undefined' && window.location) {\n        // In main thread - use window.location\n        baseUrl = new URL(\".\", window.location.href).href;\n      } else if (typeof self !== 'undefined' && self.location) {\n        // In web worker - use self.location\n        baseUrl = new URL(\".\", self.location.href).href;\n      } else {\n        // Fallback - assume current origin\n        baseUrl = \"/\";\n      }\n      \n      const allJsonPath = new URL(allJSONUrl, baseUrl).href;\n      \n      // Prepare all wheel URLs for parallel loading\n      const wheelFiles = [\n        new URL(pipliteWheelUrl, baseUrl).href,\n        new URL(pyodide_kernelWheelUrl, baseUrl).href,\n        new URL(ipykernelWheelUrl, baseUrl).href,\n        new URL(widgetsnbextensionWheelUrl, baseUrl).href,\n        new URL(widgetsnbextensionWheelUrl1, baseUrl).href,\n      ];\n      \n      console.log(` Installing ${wheelFiles.length} wheel packages in parallel...`);\n      \n      // Install all wheel packages in parallel for maximum speed\n      const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n        const wheelStartTime = Date.now();\n        try {\n          await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\" Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n          const wheelTime = Date.now() - wheelStartTime;\n          console.log(` Wheel ${index + 1} installed in ${wheelTime}ms`);\n          return { index, success: true, time: wheelTime };\n        } catch (error) {\n          const wheelTime = Date.now() - wheelStartTime;\n          console.warn(` Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n          return { index, success: false, time: wheelTime, error };\n        }\n      });\n      \n      // Wait for all wheel installations\n      const wheelResults = await Promise.all(wheelPromises);\n      const successful = wheelResults.filter(r => r.success);\n      const failed = wheelResults.filter(r => !r.success);\n      \n      console.log(` Wheels: ${successful.length}/${wheelFiles.length} successful`);\n      if (failed.length > 0) {\n        console.warn(` Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n      }\n      \n      // Set up piplite configuration with performance optimizations (if available)\n      try {\n        await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\" Package index configured\")\n    except Exception as e:\n        print(f\" Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\" Piplite optimized for performance\")\nexcept ImportError:\n    print(\" Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\" Piplite setup failed: {e}\")\n`);\n      } catch (error) {\n        console.warn(\" Piplite configuration failed, continuing without it:\", error);\n      }\n      \n      const totalTime = Date.now() - startTime;\n      console.log(` Package manager initialized in ${totalTime}ms`);\n      \n    } catch (error) {\n      console.error(\" Package manager initialization failed:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize the kernel with required Python packages\n   * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n   */\n  private async initKernel(): Promise<void> {\n    const startTime = Date.now();\n    console.log(\" Initializing kernel packages with maximum optimization...\");\n    \n    // All packages to install with priority and dependency information\n    const packageConfig = [\n      // High priority: CDN packages (fastest)\n      { name: 'pure-eval', priority: 1, source: 'pyodide' },\n      { name: 'stack-data', priority: 1, source: 'pyodide' },\n      { name: 'pygments', priority: 1, source: 'pyodide' },\n      { name: 'ssl', priority: 1, source: 'pyodide' },\n      { name: 'sqlite3', priority: 1, source: 'pyodide' },\n      { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n      { name: 'jedi', priority: 1, source: 'pyodide' },\n      { name: 'ipython', priority: 1, source: 'pyodide' },\n      \n      // Medium priority: pip packages\n      { name: 'comm', priority: 2, source: 'pip' },\n      { name: 'hypha-rpc', priority: 2, source: 'pip' },\n      { name: 'nbformat', priority: 2, source: 'pip' },\n      \n      // Lower priority: complex packages\n      { name: 'ipykernel', priority: 3, source: 'pip' },\n      { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n    ];\n\n    try {\n      console.log(` Installing ${packageConfig.length} packages with intelligent optimization...`);\n      \n      // Install ALL packages in parallel with advanced error handling and caching\n      await this.installPackagesWithIntelligentOptimization(packageConfig);\n      \n      // Import the kernel (must be done after packages are installed)\n      console.log(\" Importing pyodide_kernel...\");\n      const importStartTime = Date.now();\n      await this.pyodide.runPythonAsync('import pyodide_kernel');\n      const importTime = Date.now() - importStartTime;\n      console.log(` pyodide_kernel imported in ${importTime}ms`);\n      \n      const totalTime = Date.now() - startTime;\n      console.log(` Kernel packages initialized in ${totalTime}ms`);\n      \n    } catch (error) {\n      console.error(\" Kernel package initialization failed:\", error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Install packages with intelligent optimization and advanced caching\n   * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n   */\n  private async installPackagesWithIntelligentOptimization(packageConfig: Array<{name: string, priority: number, source: string}>): Promise<void> {\n    console.log(` Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n    \n    const installPromises = packageConfig.map(async (pkg) => {\n      const startTime = Date.now();\n      try {\n        console.log(` Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n        \n        // Try preferred source first, with intelligent fallback\n        if (pkg.source === 'pyodide') {\n          try {\n            await this.pyodide.loadPackage([pkg.name]);\n            const duration = Date.now() - startTime;\n            console.log(` ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n            return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n          } catch (pyodideError) {\n            // Fallback to pip with enhanced error handling\n            console.log(` ${pkg.name} not available on CDN, trying pip...`);\n            await this.installViaPipWithOptimizations(pkg.name);\n            const duration = Date.now() - startTime;\n            console.log(` ${pkg.name} installed via pip fallback (${duration}ms)`);\n            return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n          }\n        } else {\n          // Direct pip installation with optimizations\n          await this.installViaPipWithOptimizations(pkg.name);\n          const duration = Date.now() - startTime;\n          console.log(` ${pkg.name} installed via pip (${duration}ms)`);\n          return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n        }\n      } catch (error) {\n        const duration = Date.now() - startTime;\n        console.warn(` Failed to install ${pkg.name} after ${duration}ms:`, error);\n        return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n      }\n    });\n    \n    // Wait for all installations with detailed analysis\n    const results = await Promise.all(installPromises);\n    \n    // Comprehensive performance analysis\n    this.analyzeInstallationResults(results);\n  }\n  \n  /**\n   * Install package via pip with performance optimizations\n   */\n  private async installViaPipWithOptimizations(packageName: string): Promise<void> {\n    await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\" Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\" Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\" Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\" Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n  }\n  \n  /**\n   * Analyze installation results and provide performance insights\n   */\n  private analyzeInstallationResults(results: Array<any>): void {\n    const successful = results.filter(r => r.success);\n    const failed = results.filter(r => !r.success);\n    const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n    const pipInstalls = successful.filter(r => r.method === 'pip');\n    const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n    \n    const totalDuration = Math.max(...results.map(r => r.duration));\n    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n    const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n    \n    console.log(` INTELLIGENT INSTALLATION COMPLETE!`);\n    console.log(` Results: ${successful.length}/${results.length} successful`);\n    console.log(` Pyodide CDN: ${pyodideInstalls.length} packages`);\n    console.log(` Direct pip: ${pipInstalls.length} packages`);\n    console.log(` Pip fallback: ${fallbackInstalls.length} packages`);\n    console.log(` Failed: ${failed.length} packages`);\n    console.log(`  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n    console.log(` Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n    console.log(` Average per package: ${Math.round(avgDuration)}ms`);\n    \n    if (failed.length > 0) {\n      console.warn(`  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n      // Log specific failure reasons for debugging\n      failed.forEach(f => {\n        console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n      });\n    }\n    \n    // Performance insights\n    const fastestInstall = Math.min(...successful.map(r => r.duration));\n    const slowestInstall = Math.max(...successful.map(r => r.duration));\n    console.log(` Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n  }\n  \n  /**\n   * Initialize global objects from the pyodide_kernel package\n   * Based on the PyodideRemoteKernel implementation\n   */\n  private async initGlobals(): Promise<void> {\n    console.log(\"Initializing globals...\");\n    \n    // Get the globals from the Python environment\n    const { globals } = this.pyodide;\n    \n    // Get the kernel instance and related objects\n    this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n    this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n    this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n    this._interpreter = this._kernel.interpreter.copy();\n    \n    // Set up communication handlers\n    this._interpreter.send_comm = this.sendComm.bind(this);\n    \n    // Set up callbacks\n    this.setupCallbacks();\n  }\n  \n  /**\n   * Setup all necessary callbacks for the Python environment\n   */\n  private setupCallbacks(): void {\n    // Execution result callback\n    const publishExecutionResult = (\n      prompt_count: any,\n      data: any,\n      metadata: any,\n    ): void => {\n      const bundle = {\n        execution_count: prompt_count,\n        data: this.formatResult(data),\n        metadata: this.formatResult(metadata),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'execute_result',\n      });\n    };\n\n    // Error callback\n    const publishExecutionError = (ename: any, evalue: any, traceback: any): void => {\n      const bundle = {\n        ename: ename,\n        evalue: evalue,\n        traceback: traceback,\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n          type: 'execute_error',\n      });\n    };\n\n    // Clear output callback\n    const clearOutputCallback = (wait: boolean): void => {\n      const bundle = {\n        wait: this.formatResult(wait),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n          type: 'clear_output',\n      });\n    };\n\n    // Display data callback\n    const displayDataCallback = (data: any, metadata: any, transient: any): void => {\n      const bundle = {\n        data: this.formatResult(data),\n        metadata: this.formatResult(metadata),\n        transient: this.formatResult(transient),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'display_data',\n      });\n    };\n\n    // Update display data callback\n    const updateDisplayDataCallback = (\n      data: any,\n      metadata: any,\n      transient: any,\n    ): void => {\n      const bundle = {\n        data: this.formatResult(data),\n        metadata: this.formatResult(metadata),\n        transient: this.formatResult(transient),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'update_display_data',\n      });\n    };\n\n    // Stream callback\n    const publishStreamCallback = (name: any, text: any): void => {\n      const bundle = {\n        name: this.formatResult(name),\n        text: this.formatResult(text),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'stream',\n      });\n    };\n\n    // Assign callbacks to the Python objects\n    this._stdout_stream.publish_stream_callback = publishStreamCallback;\n    this._stderr_stream.publish_stream_callback = publishStreamCallback;\n    this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n    this._interpreter.display_pub.display_data_callback = displayDataCallback;\n    this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n    this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n    this._interpreter.input = this.input.bind(this);\n    this._interpreter.getpass = this.getpass.bind(this);\n  }\n  \n  /**\n   * Process a message from Python environment\n   */\n  private _sendMessage(msg: IMessage): void {\n    this._processMessage(msg);\n  }\n  \n  /**\n   * Process a message by emitting the appropriate event\n   */\n  private _processMessage(msg: IMessage): void {\n    if (!msg.type) {\n      return;\n    }\n\n    let eventData: any;\n\n    switch (msg.type) {\n      case 'stream': {\n        const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n        super.emit(KernelEvents.STREAM, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'input_request': {\n        const content = msg.content ?? { prompt: '', password: false };\n        super.emit(KernelEvents.INPUT_REQUEST, content);\n        eventData = content;\n        break;\n      }\n      case 'display_data': {\n        const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n        super.emit(KernelEvents.DISPLAY_DATA, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'update_display_data': {\n        const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n        super.emit(KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'clear_output': {\n        const bundle = msg.bundle ?? { wait: false };\n        super.emit(KernelEvents.CLEAR_OUTPUT, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'execute_result': {\n        const bundle = msg.bundle ?? {\n          execution_count: this.executionCount,\n          data: {},\n          metadata: {},\n        };\n        super.emit(KernelEvents.EXECUTE_RESULT, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'execute_error': {\n        const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n        super.emit(KernelEvents.EXECUTE_ERROR, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'comm_open':\n      case 'comm_msg':\n      case 'comm_close': {\n        const content = msg.content ?? {};\n        super.emit(msg.type, content, msg.metadata, msg.buffers);\n        eventData = {\n          content,\n          metadata: msg.metadata,\n          buffers: msg.buffers\n        };\n        break;\n      }\n    }\n\n    // Emit the ALL event with standardized format\n    if (eventData) {\n      super.emit(KernelEvents.ALL, {\n        type: msg.type,\n        data: eventData\n      } as IEventData);\n    }\n  }\n  \n  /**\n   * Check if the kernel has been initialized\n   */\n  public isInitialized(): boolean {\n    return this.initialized;\n  }\n  \n  /**\n   * Makes sure pyodide is ready before continuing, and cache the parent message.\n   */\n  private async setup(parent: any): Promise<void> {\n    await this.initialize();\n    this._parent_header = this.pyodide.toPy(parent || {});\n  }\n  \n  /**\n   * Execute code in the kernel with proper message-based completion detection\n   * \n   * @param code The code to execute\n   * @param parent Parent message header\n   * @returns The result of the execution\n   */\n  public async execute(code: string, parent: any = {}): Promise<{ success: boolean, outputs?: any, error?: Error, ename?: string, evalue?: string, traceback?: any }> {\n    // Simple implementation that collects all outputs from executeStream\n    const outputs: any[] = [];\n    \n    try {\n      // Use executeStream to get all outputs\n      for await (const output of this.executeStream(code, parent)) {\n        outputs.push(output);\n      }\n      \n      // Process collected outputs to create a comprehensive result\n      const result: any = {\n        outputs: [],\n        data: {},\n        metadata: {},\n        execution_count: this.executionCount\n      };\n      \n      // Collect all output types\n      for (const output of outputs) {\n        if (output.type === 'stream') {\n          // Collect stdout/stderr\n          if (!result.stdout) result.stdout = '';\n          if (!result.stderr) result.stderr = '';\n          \n          if (output.data.name === 'stdout') {\n            result.stdout += output.data.text;\n          } else if (output.data.name === 'stderr') {\n            result.stderr += output.data.text;\n          }\n          result.outputs.push(output.data);\n        } else if (output.type === 'display_data' || output.type === 'execute_result') {\n          // Collect display data\n          if (output.data.data) {\n            Object.assign(result.data, output.data.data);\n          }\n          if (output.data.metadata) {\n            Object.assign(result.metadata, output.data.metadata);\n          }\n          result.outputs.push(output.data);\n        } else if (output.type === 'execute_error' || output.type === 'error') {\n          // Handle errors\n          const errorData = output.data;\n          return {\n            success: false,\n            error: new Error(`${errorData.ename}: ${errorData.evalue}`),\n            ename: errorData.ename,\n            evalue: errorData.evalue,\n            traceback: errorData.traceback,\n            outputs: result.outputs\n          };\n        } else {\n          // Store any other output type\n          result.outputs.push(output);\n        }\n      }\n      // Return collected results\n      result.success = true;\n\n      // Auto-sync native filesystems if enabled\n      if (this.autoSyncFs) {\n        await this.syncAllNativeFs();\n      }\n\n      return result;\n\n    } catch (error) {\n      console.error(\"[KERNEL] Execute error:\", error);\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error))\n      };\n    }\n  }\n  \n  /**\n   * Format the result from the Pyodide evaluation\n   * Based on PyodideRemoteKernel implementation\n   */\n  private formatResult(res: any): any {\n    if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n      return res;\n    }\n    \n    try {\n      // Convert PyProxy to JS\n      const m = res.toJs();\n      const results = this.mapToObject(m);\n      return results;\n    } catch (error) {\n      console.error(\"Error formatting result:\", error);\n      return { status: 'error', error: String(error) };\n    }\n  }\n  \n  /**\n   * Convert a Map to a JavaScript object recursively\n   * Based on PyodideRemoteKernel implementation\n   */\n  private mapToObject(obj: any) {\n    const out: any = obj instanceof Array ? [] : {};\n    \n    obj.forEach((value: any, key: string) => {\n      out[key] = \n        value instanceof Map || value instanceof Array\n          ? this.mapToObject(value)\n          : value;\n    });\n    \n    return out;\n  }\n  \n  /**\n   * Handle input reply from user\n   */\n  public async inputReply(content: { value: string }): Promise<void> {\n    if (this._resolveInputReply) {\n      this._resolveInputReply(content);\n      this._resolveInputReply = null;\n    }\n  }\n  \n  /**\n   * Send a input request to the front-end.\n   */\n  private async sendInputRequest(prompt: string, password: boolean): Promise<void> {\n    const content = {\n      prompt,\n      password,\n    };\n\n    this._sendMessage({\n      type: 'input_request',\n      content,\n      parentHeader: this.formatResult(this._parent_header)['header']\n    });\n  }\n\n  /**\n   * Get password input (with hidden input)\n   */\n  private async getpass(prompt: string): Promise<string> {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await this.sendInputRequest(prompt, true);\n    const replyPromise = new Promise<{ value: string }>((resolve) => {\n      this._resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result.value;\n  }\n\n  /**\n   * Get text input\n   */\n  private async input(prompt: string): Promise<string> {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await this.sendInputRequest(prompt, false);\n    const replyPromise = new Promise<{ value: string }>((resolve) => {\n      this._resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result.value;\n  }\n  \n  /**\n   * Send a comm message to the front-end.\n   */\n  private async sendComm(type: string, content: any, metadata: any, ident: any, buffers: any): Promise<void> {\n    this._sendMessage({\n      type: type,\n      content: this.formatResult(content),\n      metadata: this.formatResult(metadata),\n      ident: this.formatResult(ident),\n      buffers: this.formatResult(buffers),\n      parentHeader: this.formatResult(this._parent_header)['header'],\n    });\n  }\n  \n  /**\n   * Complete the code submitted by a user.\n   */\n  public async complete(code: string, cursor_pos: number, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.complete(code, cursor_pos);\n    return this.formatResult(res);\n  }\n\n  /**\n   * Inspect the code submitted by a user.\n   */\n  public async inspect(code: string, cursor_pos: number, detail_level: 0 | 1, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.inspect(code, cursor_pos, detail_level);\n    return this.formatResult(res);\n  }\n\n  /**\n   * Check code for completeness.\n   */\n  public async isComplete(code: string, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.is_complete(code);\n    return this.formatResult(res);\n  }\n\n  /**\n   * Get information about available comms.\n   */\n  public async commInfo(target_name: string | null, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_info(target_name);\n    return {\n      comms: this.formatResult(res),\n      status: 'ok',\n    };\n  }\n\n  /**\n   * Open a COMM\n   */\n  public async commOpen(content: any, parent: any = {}): Promise<void> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_manager.comm_open(\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(content)\n    );\n    \n    return this.formatResult(res);\n  }\n  \n  /**\n   * Send a message through a COMM\n   */\n  public async commMsg(content: any, parent: any = {}): Promise<void> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_manager.comm_msg(\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(content)\n    );\n    \n    return this.formatResult(res);\n  }\n  \n  /**\n   * Close a COMM\n   */\n  public async commClose(content: any, parent: any = {}): Promise<void> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_manager.comm_close(\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(content)\n    );\n    \n    return this.formatResult(res);\n  }\n\n  /**\n   * Execute Python code with streaming output\n   * @param code The Python code to execute\n   * @param parent Parent message header\n   * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n   */\n  public async* executeStream(code: string, parent: any = {}): AsyncGenerator<any, { success: boolean, result?: any, error?: Error }, void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    try {\n      this._status = \"busy\";\n      super.emit(KernelEvents.KERNEL_BUSY, {});\n      await this.setup(parent);\n      // Create event listeners for streaming\n      const eventQueue: IEventData[] = [];\n      let executionComplete = false;\n      let executionResult: any = null;\n      let executionError: Error | null = null;\n      \n      const handleAllEvents = (eventData: IEventData) => {\n        eventQueue.push(eventData);\n      };\n      \n      // Listen for all events BEFORE executing code\n      super.on(KernelEvents.ALL, handleAllEvents);\n      \n      try {\n        // Execute the code directly\n        this._kernel.run(code).then((result: any) => {\n          console.log(\"[KERNEL] Python execution finished\");\n          executionResult = this.formatResult(result);\n          \n          // Check if the result indicates an error and emit it as an event\n          if (executionResult && executionResult.status === 'error') {\n            console.log(\"[KERNEL] Execution completed with error status, emitting execute_error event\");\n            \n            // Emit the error event so the UI can display it\n            this._sendMessage({\n              parentHeader: this.formatResult(this._parent_header)['header'],\n              bundle: {\n                ename: executionResult.ename || 'Error',\n                evalue: executionResult.evalue || 'Unknown error',\n                traceback: executionResult.traceback || []\n              },\n              type: 'execute_error',\n            });\n          }\n          \n          // Wait a small amount of time for any remaining messages to be processed\n          setTimeout(() => {\n            executionComplete = true;\n          }, 100); // 100ms should be enough for message processing\n          \n        }).catch((error: any) => {\n          console.error(\"[KERNEL] Python execution error:\", error);\n          executionError = error instanceof Error ? error : new Error(String(error));\n          \n          // Still wait for messages to settle before completing\n          setTimeout(() => {\n            executionComplete = true;\n          }, 100);\n        });\n        \n        // Stream events as they arrive\n        while (!executionComplete || eventQueue.length > 0) {\n          // Yield queued events\n          if (eventQueue.length > 0) {\n            const event = eventQueue.shift()!;\n            yield event;\n          } else if (!executionComplete) {\n            // Wait a bit for more events\n            await new Promise(resolve => setTimeout(resolve, 10));\n          }\n        }\n        \n        // Process final result\n        this._status = \"active\";\n        super.emit(KernelEvents.KERNEL_IDLE, {});\n        \n        if (executionError) {\n          return {\n            success: false,\n            error: executionError,\n            result: executionResult\n          };\n        }\n        \n        // Check if result indicates an error\n        if (executionResult && executionResult.status === 'error') {\n          const errorMsg = `${executionResult.ename || 'Error'}: ${executionResult.evalue || 'Unknown error'}`;\n          return {\n            success: false,\n            error: new Error(errorMsg),\n            result: executionResult\n          };\n        }\n\n        // Auto-sync native filesystems if enabled\n        if (this.autoSyncFs) {\n          await this.syncAllNativeFs();\n        }\n\n        return {\n          success: true,\n          result: executionResult\n        };\n\n      } finally {\n        // Clean up listener\n        super.off(KernelEvents.ALL, handleAllEvents);\n      }\n      \n    } catch (error) {\n      console.error(\"[KERNEL] ExecuteStream error:\", error);\n      this._status = \"active\";\n      super.emit(KernelEvents.KERNEL_IDLE, {});\n      \n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error))\n      };\n    }\n  }\n\n  // Interrupt functionality\n  public async interrupt(): Promise<boolean> {\n    if (!this.initialized || !this.pyodide) {\n      console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n      return false;\n    }\n    \n    console.log(\"[KERNEL] Attempting to interrupt execution...\");\n    \n    try {\n      // First priority: Use interrupt buffer if available\n      if (this._interruptBuffer && this._interruptSupported) {\n        console.log(\"[KERNEL] Using interrupt buffer method\");\n        // Set interrupt signal (2 = SIGINT)\n        this._interruptBuffer[0] = 2;\n        \n        // Give the interrupt a moment to be processed\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        // Check if the interrupt was processed (buffer should be reset to 0)\n        const wasProcessed = this._interruptBuffer[0] === 0;\n        if (wasProcessed) {\n          console.log(\"[KERNEL] Interrupt processed successfully via buffer\");\n          return true;\n        }\n      }\n      \n      // Second priority: Try Python-level interrupt\n      try {\n        console.log(\"[KERNEL] Attempting Python-level interrupt\");\n        // Try to raise KeyboardInterrupt in Python\n        await this.pyodide.runPythonAsync(`\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n`);\n        console.log(\"[KERNEL] Python interrupt signal sent\");\n        return true;\n      } catch (pythonError) {\n        console.log(\"[KERNEL] Python interrupt attempt failed:\", pythonError);\n      }\n      \n      // Third priority: Try interpreter interrupt if available\n      if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n        console.log(\"[KERNEL] Using interpreter interrupt method\");\n        this._interpreter.interrupt();\n        return true;\n      }\n      \n      // Last resort: Send interrupt messages for UI feedback\n      console.log(\"[KERNEL] Sending interrupt messages for UI feedback\");\n      \n      // Send stderr stream first (for Jupyter notebook UI compatibility)\n      this._sendMessage({\n        type: 'stream',\n        bundle: {\n          name: 'stderr',\n          text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n        }\n      });\n      \n      this._sendMessage({\n        type: 'execute_error',\n        bundle: {\n          ename: 'KeyboardInterrupt',\n          evalue: 'Execution interrupted by user',\n          traceback: ['KeyboardInterrupt: Execution interrupted by user']\n        }\n      });\n      \n      // Return false since we couldn't actually interrupt the execution\n      return false;\n    } catch (error) {\n      console.error(\"[KERNEL] Error during interrupt:\", error);\n      return false;\n    }\n  }\n\n  public setInterruptBuffer(buffer: Uint8Array): void {\n    this._interruptBuffer = buffer;\n\n    try {\n      if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n        this.pyodide.setInterruptBuffer(buffer);\n        this._interruptSupported = true;\n      } else {\n        console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n        this._interruptSupported = false;\n      }\n    } catch (error) {\n      console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n      this._interruptSupported = false;\n    }\n  }\n\n  /**\n   * Verify and request permission for a file system handle\n   * @private\n   */\n  private async verifyPermission(\n    fileHandle: FileSystemDirectoryHandle,\n    permission: 'read' | 'readwrite'\n  ): Promise<boolean> {\n    const opts: any = {};\n    if (permission === 'readwrite') {\n      opts.mode = 'readwrite';\n    }\n\n    console.log(`[KERNEL] Verifying ${permission} permission for file handle...`);\n\n    // Check if permission APIs are supported\n    if (typeof (fileHandle as any).queryPermission !== 'function') {\n      console.warn('[KERNEL] queryPermission not supported, assuming permission granted');\n      return true;\n    }\n\n    try {\n      // Check if we already have permission, if so, return true.\n      const queryResult = await (fileHandle as any).queryPermission(opts);\n      console.log('[KERNEL] Query result:', queryResult);\n      \n      if (queryResult === 'granted') {\n        console.log(`[KERNEL] Permission already granted for ${permission} access`);\n        return true;\n      }\n\n      // Request permission to the file, if the user grants permission, return true.\n      if (typeof (fileHandle as any).requestPermission === 'function') {\n        console.log(`[KERNEL] Requesting ${permission} permission from user...`);\n        \n        try {\n          const requestResult = await (fileHandle as any).requestPermission(opts);\n          console.log('[KERNEL] Request result:', requestResult);\n          \n          if (requestResult === 'granted') {\n            console.log(`[KERNEL] Permission granted for ${permission} access`);\n            return true;\n          }\n        } catch (requestError) {\n          console.log('[KERNEL] Permission request failed or was dismissed:', requestError);\n        }\n      }\n\n      // The user did not grant permission, return false.\n      console.log(`[KERNEL] ${permission} permission not granted`);\n      return false;\n      \n    } catch (error) {\n      console.error('[KERNEL] Error checking permission:', error);\n      // If permission check fails, assume it's granted (more permissive approach)\n      console.warn('[KERNEL] Permission check failed, assuming granted as fallback');\n      return true;\n    }\n  }\n\n  /**\n   * Mount a native file system directory into the Pyodide filesystem\n   * @param mountPath The path where the directory should be mounted in the Python filesystem\n   * @param dirHandle Optional FileSystemDirectoryHandle. If null/undefined, shows directory picker\n   * @param permission Permission mode:\n   *   - 'read': Read-only access, no syncing capabilities, auto-sync will be skipped (default)\n   *   - 'readwrite': Full read/write access with syncing capabilities\n   * @returns Promise resolving to a handle with syncfs() method for syncing changes\n   * @note syncfs() will throw an error if called on a read-only mounted filesystem\n   * @note Many browsers only offer read permission initially. Explicitly request 'readwrite' if you need write access.\n   */\n  public async mountFS(\n    mountPath: string,\n    dirHandle?: FileSystemDirectoryHandle | null,\n    permission: 'read' | 'readwrite' = 'read'\n  ): Promise<{ syncfs: () => Promise<void> }> {\n    if (!this.initialized || !this.pyodide) {\n      throw new Error(\"Kernel must be initialized before mounting filesystem\");\n    }\n\n    // Check if mountNativeFS is available\n    if (typeof this.pyodide.mountNativeFS !== 'function') {\n      throw new Error(\"pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.\");\n    }\n\n    let handle = dirHandle;\n\n    // If no dirHandle provided, show directory picker\n    if (!handle) {\n      // Check if we're in a worker context\n      if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n        throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter.\");\n      }\n\n      // Check if showDirectoryPicker is available\n      if (typeof window !== 'undefined' && 'showDirectoryPicker' in window) {\n        try {\n          handle = await (window as any).showDirectoryPicker({\n            mode: 'readwrite',\n          });\n        } catch (error) {\n          throw new Error(`Failed to show directory picker: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      } else {\n        throw new Error(\"showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.\");\n      }\n    }\n\n    if (!handle) {\n      throw new Error(\"No directory handle available\");\n    }\n\n    // Verify and request permissions before mounting\n    console.log(`[KERNEL] Verifying ${permission} permissions before mounting...`);\n    const hasRequestedPermission = await this.verifyPermission(handle, permission);\n    \n    if (!hasRequestedPermission) {\n      if (permission === 'readwrite') {\n        throw new Error(\n          `Failed to obtain write permission for directory. ` +\n          `The browser may only be offering read permission. ` +\n          `Try mounting with permission: 'read' if you only need to read files, ` +\n          `or ensure the browser supports write access to this directory.`\n        );\n      } else {\n        throw new Error(`Failed to obtain ${permission} permission for directory.`);\n      }\n    }\n    \n    const actualPermission = permission;\n\n    // Mount the native filesystem\n    try {\n      console.log(`[KERNEL] Mounting native filesystem at ${mountPath} with ${actualPermission} permission`);\n      \n      // Check if the mount point already exists and handle cleanup\n      try {\n        const pathInfo = this.pyodide.FS.analyzePath(mountPath);\n        if (pathInfo.exists) {\n          console.log(`[KERNEL] Path ${mountPath} exists, checking if it's a mount point`);\n          \n          // Try to unmount if it's already mounted\n          try {\n            await this.pyodide.FS.unmount(mountPath);\n            console.log(`[KERNEL] Successfully unmounted existing filesystem at ${mountPath}`);\n          } catch (unmountError) {\n            // If unmount fails, it might not be a mount point or might be busy\n            console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${unmountError}`);\n          }\n          \n          // Remove the directory if it exists but is empty\n          try {\n            this.pyodide.FS.rmdir(mountPath);\n            console.log(`[KERNEL] Removed existing directory at ${mountPath}`);\n          } catch (rmdirError) {\n            // Directory might not be empty or might not exist, that's okay\n            console.log(`[KERNEL] Could not remove directory (this is normal): ${rmdirError}`);\n          }\n        }\n      } catch (analyzeError) {\n        // analyzePath might fail, that's okay - the path probably doesn't exist\n        console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${analyzeError}`);\n      }\n      \n      // Ensure the parent directory exists\n      const parentPath = mountPath.substring(0, mountPath.lastIndexOf('/')) || '/';\n      try {\n        if (parentPath !== '/' && !this.pyodide.FS.analyzePath(parentPath).exists) {\n          this.pyodide.FS.mkdir(parentPath);\n          console.log(`[KERNEL] Created parent directory ${parentPath}`);\n        }\n      } catch (parentError) {\n        console.log(`[KERNEL] Parent directory handling: ${parentError}`);\n      }\n      \n      const nativefs = await this.pyodide.mountNativeFS(mountPath, handle);\n\n      console.log(`[KERNEL] Successfully mounted native filesystem at ${mountPath} with ${actualPermission} permission`);\n\n      // Create a handle with syncfs method and permission recovery\n      const fsHandle = {\n        syncfs: async () => {\n          // Check if filesystem is read-only\n          if (actualPermission === 'read') {\n            throw new Error(`Cannot sync read-only filesystem at ${mountPath}. Use upgradeFileSystemPermission() to request write access.`);\n          }\n          \n          try {\n            await nativefs.syncfs();\n            console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n          } catch (error) {\n            throw new Error(`Failed to sync filesystem: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        },\n        dirHandle: handle,\n        permission: actualPermission,\n        nativefs: nativefs\n      };\n\n      // Store the handle for auto-sync\n      this.nativeFsHandles.set(mountPath, fsHandle);\n\n      return { syncfs: fsHandle.syncfs };\n    } catch (error) {\n      throw new Error(`Failed to mount native filesystem: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Sync all mounted native filesystems with permission recovery\n   * Only syncs filesystems mounted with 'readwrite' permission\n   * @private\n   */\n  private async syncAllNativeFs(): Promise<void> {\n    if (this.nativeFsHandles.size === 0) {\n      return;\n    }\n\n    const syncResults: Array<{ mountPath: string; success: boolean; error?: string; skipped?: boolean }> = [];\n\n    for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n      // Skip read-only filesystems\n      if (fsHandle.permission === 'read') {\n        syncResults.push({ mountPath, success: true, skipped: true });\n        console.log(`[KERNEL] Skipping sync for read-only filesystem at ${mountPath}`);\n        continue;\n      }\n\n      try {\n        // First, try to sync directly\n        await fsHandle.syncfs();\n        syncResults.push({ mountPath, success: true });\n        console.log(`[KERNEL] Successfully synced filesystem at ${mountPath}`);\n      } catch (error) {\n        // If sync fails, check if it's a permission error\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        \n        if (errorMessage.includes('not allowed by the user agent') || \n            errorMessage.includes('getFileHandle') ||\n            errorMessage.includes('permission')) {\n          \n          console.warn(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n          \n          try {\n            // Try to recover by re-verifying permissions\n            const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n            \n            if (hasPermission) {\n              // Try to remount and sync\n              console.log(`[KERNEL] Permission recovered for ${mountPath}, attempting remount...`);\n              const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n              \n              // Update the stored handle with the new nativefs\n              fsHandle.nativefs = newNativefs;\n              fsHandle.syncfs = async () => {\n                try {\n                  await newNativefs.syncfs();\n                  console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                } catch (syncError) {\n                  throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                }\n              };\n              \n              // Try sync again with the new handle\n              await fsHandle.syncfs();\n              syncResults.push({ mountPath, success: true });\n              console.log(`[KERNEL] Successfully recovered and synced filesystem at ${mountPath}`);\n            } else {\n              syncResults.push({ \n                mountPath, \n                success: false, \n                error: 'Permission denied by user' \n              });\n              console.warn(`[KERNEL] User denied permission for ${mountPath}, skipping sync`);\n            }\n          } catch (recoveryError) {\n            const recoveryMessage = recoveryError instanceof Error ? recoveryError.message : String(recoveryError);\n            syncResults.push({ \n              mountPath, \n              success: false, \n              error: `Recovery failed: ${recoveryMessage}` \n            });\n            console.error(`[KERNEL] Failed to recover permissions for ${mountPath}:`, recoveryError);\n          }\n        } else {\n          // Non-permission error\n          syncResults.push({ \n            mountPath, \n            success: false, \n            error: errorMessage \n          });\n          console.error(`[KERNEL] Non-permission error syncing ${mountPath}:`, error);\n        }\n      }\n    }\n\n    // Log summary\n    const successful = syncResults.filter(r => r.success && !r.skipped).length;\n    const skipped = syncResults.filter(r => r.skipped).length;\n    const failed = syncResults.filter(r => !r.success);\n    \n    if (successful > 0 || skipped > 0) {\n      const parts = [];\n      if (successful > 0) parts.push(`${successful} synced`);\n      if (skipped > 0) parts.push(`${skipped} read-only skipped`);\n      console.log(`[KERNEL] Auto-sync completed: ${parts.join(', ')} (${syncResults.length} total filesystems)`);\n    }\n    \n    if (failed.length > 0) {\n      console.warn(`[KERNEL] Auto-sync issues:`, failed.map(f => `${f.mountPath}: ${f.error}`));\n    }\n    \n    // Don't throw - we don't want to fail execution just because sync failed\n  }\n\n  /**\n   * Get information about mounted native filesystems and their permission status\n   * @returns Array of mounted filesystem information\n   */\n  public getMountedFileSystems(): Array<{\n    mountPath: string;\n    permission: 'read' | 'readwrite';\n    canSync: boolean;\n  }> {\n    const result: Array<{\n      mountPath: string;\n      permission: 'read' | 'readwrite';\n      canSync: boolean;\n    }> = [];\n\n    for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n      result.push({\n        mountPath,\n        permission: fsHandle.permission,\n        canSync: fsHandle.permission === 'readwrite'\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Manually sync a specific mounted filesystem\n   * @param mountPath The path of the mounted filesystem to sync\n   * @returns Promise resolving to success status\n   */\n  public async syncFileSystem(mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const fsHandle = this.nativeFsHandles.get(mountPath);\n    \n    if (!fsHandle) {\n      return {\n        success: false,\n        error: `No filesystem mounted at ${mountPath}`\n      };\n    }\n\n    // Check if filesystem is read-only\n    if (fsHandle.permission === 'read') {\n      return {\n        success: false,\n        error: `Cannot sync read-only filesystem at ${mountPath}. Mount with 'readwrite' permission to enable syncing.`\n      };\n    }\n\n    try {\n      await fsHandle.syncfs();\n      return { success: true };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      // Try permission recovery if it's a permission error\n      if (errorMessage.includes('not allowed by the user agent') || \n          errorMessage.includes('getFileHandle') ||\n          errorMessage.includes('permission')) {\n        \n        console.log(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n        \n        try {\n          const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n          \n          if (hasPermission) {\n            // Remount and try again\n            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n            fsHandle.nativefs = newNativefs;\n            fsHandle.syncfs = async () => {\n              try {\n                await newNativefs.syncfs();\n                console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n              } catch (syncError) {\n                throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n              }\n            };\n            \n            await fsHandle.syncfs();\n            return { success: true };\n          } else {\n            return {\n              success: false,\n              error: 'Permission denied by user'\n            };\n          }\n        } catch (recoveryError) {\n          return {\n            success: false,\n            error: `Recovery failed: ${recoveryError instanceof Error ? recoveryError.message : String(recoveryError)}`\n          };\n        }\n      }\n      \n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Upgrade a mounted filesystem from read-only to read-write permission\n   * @param mountPath The path of the mounted filesystem to upgrade\n   * @returns Promise resolving to success status\n   */\n  public async upgradeFileSystemPermission(mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const fsHandle = this.nativeFsHandles.get(mountPath);\n    \n    if (!fsHandle) {\n      return {\n        success: false,\n        error: `No filesystem mounted at ${mountPath}`\n      };\n    }\n\n    if (fsHandle.permission === 'readwrite') {\n      return {\n        success: true,\n        error: `FileSystem at ${mountPath} already has readwrite permission`\n      };\n    }\n\n    try {\n      console.log(`[KERNEL] Attempting to upgrade ${mountPath} to readwrite permission...`);\n      \n      // Try to get readwrite permission\n      const hasWritePermission = await this.verifyPermission(fsHandle.dirHandle, 'readwrite');\n      \n      if (!hasWritePermission) {\n        return {\n          success: false,\n          error: 'User denied write permission or browser does not support write access to this directory'\n        };\n      }\n\n      // Remount with write permission\n      const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n      \n      // Update the stored handle\n      fsHandle.permission = 'readwrite';\n      fsHandle.nativefs = newNativefs;\n      fsHandle.syncfs = async () => {\n        try {\n          await newNativefs.syncfs();\n          console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n        } catch (syncError) {\n          throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n        }\n      };\n\n      console.log(`[KERNEL] Successfully upgraded ${mountPath} to readwrite permission`);\n      return { success: true };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to upgrade permission: ${error instanceof Error ? error.message : String(error)}`\n      };\n    }\n  }\n\n  /**\n   * Set environment variables with performance optimization\n   * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n   */\n  private async setEnvironmentVariables(): Promise<void> {\n    if (Object.keys(this.environmentVariables).length === 0) {\n      return; // No variables to set\n    }\n    \n    const startTime = Date.now();\n    console.log(` Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n    \n    try {\n      // Set each environment variable individually to avoid escaping issues\n      for (const [key, value] of Object.entries(this.environmentVariables)) {\n        // Handle edge cases: null, undefined, etc.\n        let processedValue: string;\n        if (value === null) {\n          processedValue = '';  // Convert null to empty string\n        } else if (value === undefined) {\n          processedValue = '';  // Convert undefined to empty string\n        } else {\n          processedValue = String(value);  // Convert everything else to string\n        }\n        \n        await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n      }\n      \n      const duration = Date.now() - startTime;\n      console.log(` Environment variables set in ${duration}ms`);\n    } catch (error) {\n      console.error(\" Failed to set environment variables:\", error);\n      throw error;\n    }\n  }\n}\n\n// Only Python kernel is supported\n\n// Export the manager for advanced usage\nexport { KernelManager } from \"./manager\";\n","// this file is autogenerated from the wheels in the pypi directory\nexport const allJSONUrl = \"pypi/all.json\";\nexport const ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nexport const pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nexport const pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nexport const widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nexport const widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n"],"names":["root","factory","exports","module","define","amd","self","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","message","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","console","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","constructor","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","length","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","prototype","concat","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","KernelEvents","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","hasOwnProperty","call","toStringTag","PYODIDE_CDN_URL","pyodideLoaded","pyodideLoadPromise","KernelMode","KernelLanguage","EventEmitter","events","on","eventName","listener","this","push","off","index","indexOf","splice","removeListener","emit","args","forEach","setMaxListeners","n","KernelManager","resolveWorkerUrl","workerUrl","window","location","currentScript","document","from","getElementsByTagName","pop","src","scriptUrl","URL","baseUrl","href","substring","lastIndexOf","hostname","includes","pathname","isKeyboardInterrupt","createKeyboardInterruptResult","success","result","status","ename","evalue","traceback","storeAbortController","kernelId","executionId","controller","abortControllers","has","removeAbortController","kernelControllers","size","abortAllKernelOperations","abort","log","options","super","kernels","listenerWrappers","lastActivityTime","inactivityTimers","ongoingExecutions","executionTimeouts","executionStartTimes","executionMetadata","pool","isPreloading","prefillingInProgress","interruptBuffers","interruptionMode","allowedKernelTypes","mode","WORKER","language","PYTHON","defaultPreloadConfigs","filter","poolConfig","enabled","poolSize","autoRefill","preloadConfigs","config","isAllowed","isKernelTypeAllowed","preloadPool","getPoolKey","getFromPool","poolKey","poolPromises","kernelPromise","shift","setTimeout","refillPoolSingle","addToPool","kernel","destroy","createPoolKernelPromise","refillPool","needed","newPromises","async","reject","createPoolKernel","isFromPool","tempId","crypto","randomUUID","lang","instance","MAIN_THREAD","tempInstance","createMainThreadKernel","createWorkerKernel","canUsePool","filesystem","deno","permissions","inactivityTimeout","maxExecutionTime","reassignPoolKernel","poolKernel","newId","updatedInstance","worker","created","Date","toISOString","getPoolStats","stats","promises","entries","available","total","getPoolConfig","getWorkerUrl","setWorkerUrl","url","createKernel","baseId","t","namespace","some","poolKernelPromise","setupPoolKernelFromPromise","newKernelPromise","createOnDemandKernel","eventHandler","event","originalDestroy","setupEventForwarding","updateKernelActivity","setupInactivityTimeout","setupStalledExecutionHandler","EXECUTE_ERROR","String","setupPoolKernel","Kernel","kernelOptions","env","lockFileURL","autoSyncFs","initialize","Worker","initPromise","initHandler","kernelProxy","setupWorkerInterruptBuffer","execute","code","isInitialized","inputReply","content","getStatus","complete","cursor_pos","inspect","detail_level","isComplete","interrupt","setInterruptBuffer","buffer","mountFS","mountPath","dirHandle","permission","getMountedFileSystems","syncFileSystem","upgradeFileSystemPermission","commInfo","target_name","comms","commOpen","commMsg","commClose","terminate","values","eventType","getKernel","getKernelIds","keys","listKernels","filteredKernels","startsWith","all","namespaceMatch","match","extractedNamespace","destroyKernel","clearInactivityTimeout","timeouts","timeoutId","clearTimeout","removeAllKernelListeners","destroyAll","destroyPromises","destroyPool","destroyPromise","onKernelEvent","wrapper","original","wrapped","storeListener","offKernelEvent","getListener","removeStoredListener","kernelMap","eventMap","getListeners","kernelListeners","eventListeners","executeStream","trackExecution","abortController","AbortController","completeExecution","streamQueue","executionComplete","executionResult","eventHandlers","cleanupHandlers","createHandler","handleStreamEvent","handleDisplayEvent","handleUpdateDisplayEvent","handleResultEvent","handleErrorEvent","STREAM","DISPLAY_DATA","UPDATE_DISPLAY_DATA","EXECUTE_RESULT","executionPromise","handleExecutionError","signal","aborted","errorData","errorResult","startTime","now","Set","add","metadata","actualRuntime","handleStuckExecution","startTimes","executions","hasOngoingExecutions","getOngoingExecutionCount","timeout","lastActivity","elapsed","remainingTime","max","timer","timerId","getLastActivityTime","getInactivityTimeout","setInactivityTimeout","getTimeUntilShutdown","getInactivityTimers","timers","EXECUTION_STALLED","forceTerminateKernel","reason","getExecutionInfo","count","isStuck","executionIds","currentTime","longestRunningTime","anyStuck","execMetadata","runtime","sort","a","b","getAllowedKernelTypes","pingKernel","restartKernel","currentConfig","parts","split","restartOptions","newKernelId","interruptKernel","interruptWorkerKernel","interruptMainThreadKernel","interruptWorkerKernelFallback","interruptBuffer","sharedBuffer","SharedArrayBuffer","Uint8Array","info","attempts","maxAttempts","responseHandler","getStuckExecutions","stuckExecutions","ongoingExecs","maxAllowed","kernelMode","kernelLanguage","handleAllStuckExecutions","results","kernelGroups","exec","primaryExec","action","initialized","filesystemOptions","mountPoint","_resolveInputReply","_parent_header","executionCount","_status","_interruptBuffer","_interruptSupported","environmentVariables","nativeFsHandles","_initializeInternal","pyodideStartTime","pyodideConfig","pyodide","importScripts","loadPyodide","script","createElement","onload","onerror","head","appendChild","globalLoadPyodide","defaultConfig","indexURL","pyodideTime","mountFileSystem","setEnvironmentVariables","initGlobals","initPackageManager","initKernel","totalTime","FS","mount","filesystems","NODEFS","mountedFiles","readdir","loadPackage","allJsonPath","wheelFiles","wheelPromises","wheelUrl","wheelStartTime","runPythonAsync","wheelTime","time","wheelResults","successful","failed","f","packageConfig","priority","source","installPackagesWithIntelligentOptimization","importStartTime","importTime","installPromises","pkg","installViaPipWithOptimizations","duration","package","method","pyodideError","analyzeInstallationResults","packageName","pyodideInstalls","pipInstalls","fallbackInstalls","totalDuration","avgDuration","sum","estimatedSequential","round","fastestInstall","min","slowestInstall","globals","_kernel","kernel_instance","copy","_stdout_stream","stdout_stream","_stderr_stream","stderr_stream","_interpreter","interpreter","send_comm","sendComm","setupCallbacks","publishStreamCallback","text","bundle","formatResult","_sendMessage","parentHeader","publish_stream_callback","display_pub","clear_output_callback","wait","display_data_callback","transient","update_display_data_callback","displayhook","publish_execution_result","prompt_count","execution_count","input","getpass","_processMessage","eventData","prompt","password","INPUT_REQUEST","CLEAR_OUTPUT","buffers","ALL","setup","toPy","outputs","output","stdout","stderr","syncAllNativeFs","res","ffi","PyProxy","m","toJs","mapToObject","out","sendInputRequest","replyPromise","ident","is_complete","comm_info","comm_manager","comm_open","comm_msg","comm_close","KERNEL_BUSY","eventQueue","executionError","handleAllEvents","run","KERNEL_IDLE","errorMsg","pythonError","verifyPermission","fileHandle","opts","queryPermission","queryResult","requestPermission","requestResult","requestError","mountNativeFS","handle","WorkerGlobalScope","showDirectoryPicker","actualPermission","analyzePath","exists","unmount","unmountError","rmdir","rmdirError","analyzeError","parentPath","mkdir","parentError","nativefs","fsHandle","syncfs","syncResults","errorMessage","newNativefs","syncError","recoveryError","recoveryMessage","skipped","canSync","processedValue","JSON","stringify"],"sourceRoot":""}