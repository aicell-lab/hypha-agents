{"version":3,"file":"kernel.worker.min.js","mappings":"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","sources":["webpack://web-python-kernel/./node_modules/comlink/dist/esm/comlink.mjs","webpack://web-python-kernel/./src/pyodide-loader.ts","webpack://web-python-kernel/./src/manager.ts","webpack://web-python-kernel/./src/index.ts","webpack://web-python-kernel/./src/_pypi.ts","webpack://web-python-kernel/./src/types.ts","webpack://web-python-kernel/webpack/bootstrap","webpack://web-python-kernel/webpack/runtime/define property getters","webpack://web-python-kernel/webpack/runtime/hasOwnProperty shorthand","webpack://web-python-kernel/./src/kernel.worker.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\n\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise: Promise<any> | null = null;\n\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Check if script is already loaded\n    if (typeof (globalThis as any).loadPyodide !== 'undefined') {\n      resolve();\n      return;\n    }\n\n    const script = document.createElement('script');\n    script.src = PYODIDE_CDN_URL;\n    script.onload = () => resolve();\n    script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n    document.head.appendChild(script);\n  });\n}\n\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    try {\n      // Check if we're in a worker environment\n      if (typeof importScripts === 'undefined') {\n        reject(new Error('importScripts is not available - not in a worker context'));\n        return;\n      }\n\n      // Check if already loaded\n      if (typeof (globalThis as any).loadPyodide !== 'undefined') {\n        resolve();\n        return;\n      }\n\n      importScripts(PYODIDE_CDN_URL);\n      resolve();\n    } catch (error) {\n      reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n    }\n  });\n}\n\n/**\n * Initialize Pyodide with proper configuration\n */\nexport async function loadPyodide(config: any = {}): Promise<any> {\n  // Return existing promise if already loading\n  if (pyodideLoadPromise) {\n    return pyodideLoadPromise;\n  }\n\n  pyodideLoadPromise = (async () => {\n    try {\n      // Determine if we're in a worker or main thread\n      const isWorker = typeof importScripts !== 'undefined';\n      \n      // Load the Pyodide script\n      if (isWorker) {\n        await loadPyodideInWorker();\n      } else {\n        await loadPyodideScript();\n      }\n\n      // Get the global loadPyodide function\n      const globalLoadPyodide = (globalThis as any).loadPyodide;\n      if (!globalLoadPyodide) {\n        throw new Error('loadPyodide function not found after script load');\n      }\n\n      // Configure default options\n      const defaultConfig = {\n        indexURL: PYODIDE_INDEX_URL,\n        ...config\n      };\n\n      // Initialize Pyodide\n      const pyodide = await globalLoadPyodide(defaultConfig);\n      pyodideLoaded = true;\n      \n      console.log('✅ Pyodide loaded successfully from CDN');\n      return pyodide;\n    } catch (error) {\n      pyodideLoadPromise = null; // Reset on failure\n      throw error;\n    }\n  })();\n\n  return pyodideLoadPromise;\n}\n\n/**\n * Check if Pyodide is already loaded\n */\nexport function isPyodideLoaded(): boolean {\n  return pyodideLoaded && typeof (globalThis as any).loadPyodide !== 'undefined';\n}\n\n/**\n * Get Pyodide CDN URL for external use\n */\nexport function getPyodideCDNUrl(): string {\n  return PYODIDE_CDN_URL;\n}\n\n/**\n * Get Pyodide index URL for external use\n */\nexport function getPyodideIndexUrl(): string {\n  return PYODIDE_INDEX_URL;\n} ","// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\nimport * as Comlink from \"comlink\";\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n  private events: { [key: string]: Function[] } = {};\n\n  on(eventName: string, listener: Function) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(listener);\n  }\n\n  off(eventName: string, listener: Function) {\n    if (!this.events[eventName]) return;\n    const index = this.events[eventName].indexOf(listener);\n    if (index > -1) {\n      this.events[eventName].splice(index, 1);\n    }\n  }\n\n  removeListener(eventName: string, listener: Function) {\n    this.off(eventName, listener);\n  }\n\n  emit(eventName: string, ...args: any[]) {\n    if (!this.events[eventName]) return;\n    this.events[eventName].forEach(listener => listener(...args));\n  }\n\n  setMaxListeners(n: number) {\n    // No-op for browser compatibility\n  }\n}\nimport { KernelEvents, IKernel, IKernelOptions, IFileSystemMountOptions } from \"./types\";\nimport { Kernel } from \"./index\";\n\n// Re-export KernelEvents for test usage\nexport { KernelEvents };\n\n// Execution mode enum\nexport enum KernelMode {\n  MAIN_THREAD = \"main_thread\",\n  WORKER = \"worker\"\n}\n\n// Kernel language enum\nexport enum KernelLanguage {\n  PYTHON = \"python\"\n}\n\n// Extended WorkerOptions interface to include Deno permissions\ninterface WorkerOptions {\n  type?: \"classic\" | \"module\";\n  name?: string;\n  deno?: {\n    permissions?: IDenoPermissions;\n  };\n}\n\n// Interface for kernel pool configuration\nexport interface IKernelPoolConfig {\n  enabled: boolean;\n  poolSize: number; // Number of kernels to keep ready per configuration\n  autoRefill: boolean; // Whether to automatically refill the pool when kernels are taken\n  preloadConfigs: Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }>; // Configurations to preload in the pool\n}\n\n// Interface for kernel manager options\nexport interface IKernelManagerOptions {\n  pool?: IKernelPoolConfig;\n  allowedKernelTypes?: Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }>; // Restrict which kernel types can be created\n  interruptionMode?: 'shared-array-buffer' | 'kernel-interrupt' | 'auto'; // Default: 'auto'\n  workerUrl?: string; // Optional custom URL for the worker script\n}\n\n// Interface for kernel instance\nexport interface IKernelInstance {\n  id: string;\n  kernel: IKernel;\n  mode: KernelMode;\n  language: KernelLanguage;\n  worker?: Worker;\n  created: string;\n  options: IManagerKernelOptions;\n  isFromPool?: boolean; // Track if this kernel came from the pool\n  destroy(): Promise<void>;\n}\n\n// Interface for Deno worker permissions\nexport interface IDenoPermissions {\n  read?: (string | URL)[];\n  write?: (string | URL)[];\n  net?: string[];\n  env?: string[];\n  run?: string[];\n  ffi?: string[];\n  hrtime?: boolean;\n}\n\n// Interface for kernel creation options\nexport interface IManagerKernelOptions {\n  id?: string;\n  mode?: KernelMode;\n  lang?: KernelLanguage;\n  namespace?: string;\n  deno?: {\n    permissions?: IDenoPermissions;\n  };\n  filesystem?: IFileSystemMountOptions;\n  env?: Record<string, string>; // Environment variables to set in the kernel\n  lockFileURL?: string; // URL to pyodide-lock.json file for faster loading\n  autoSyncFs?: boolean; // Automatically sync native filesystem after code execution (default: false)\n  inactivityTimeout?: number; // Time in milliseconds after which an inactive kernel will be shut down\n  maxExecutionTime?: number; // Maximum time in milliseconds a single execution can run before considered stuck/dead\n}\n\n// Helper type for listener management\ntype ListenerWrapper = {\n  original: (data: any) => void;\n  wrapped: (event: { kernelId: string, data: any }) => void;\n};\n\n/**\n * KernelManager class manages multiple kernel instances \n * in either main thread or worker mode\n */\nexport class KernelManager extends EventEmitter {\n  private kernels: Map<string, IKernelInstance> = new Map();\n  // Track listeners for each kernel to enable individual removal\n  private listenerWrappers: Map<string, Map<string, Map<Function, ListenerWrapper>>> = new Map();\n  // Track last activity time for each kernel\n  private lastActivityTime: Map<string, number> = new Map();\n  // Store inactivity timers for each kernel\n  private inactivityTimers: Map<string, any> = new Map();\n  // Track ongoing executions for each kernel\n  private ongoingExecutions: Map<string, Set<string>> = new Map();\n  // Track execution timeouts for detecting stuck/dead kernels\n  private executionTimeouts: Map<string, Map<string, any>> = new Map();\n  // Track execution start times for accurate duration calculation\n  private executionStartTimes: Map<string, Map<string, number>> = new Map();\n  // Track execution metadata for better monitoring\n  private executionMetadata: Map<string, Map<string, { startTime: number; code?: string; timeoutId?: any }>> = new Map();\n  \n  // Track AbortControllers for each kernel's ongoing operations\n  private abortControllers: Map<string, Map<string, AbortController>> = new Map();\n  \n  // Pool management - now using promises for immediate response\n  private pool: Map<string, Promise<IKernelInstance>[]> = new Map();\n  private poolConfig: IKernelPoolConfig;\n  private isPreloading: boolean = false;\n  // Track which pool keys are currently being prefilled to prevent duplicates\n  private prefillingInProgress: Map<string, boolean> = new Map();\n  \n  // Allowed kernel types configuration\n  private allowedKernelTypes: Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }>;\n  \n  // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n  private interruptBuffers: Map<string, Uint8Array> = new Map();\n  \n  // Interruption mode configuration\n  private interruptionMode: 'shared-array-buffer' | 'kernel-interrupt' | 'auto';\n  \n  // Worker URL configuration\n  private workerUrl: string | undefined;\n  \n  /**\n   * Resolve the worker URL based on the current environment\n   * @private\n   * @returns The resolved worker URL\n   */\n  private resolveWorkerUrl(): string {\n    // If a custom worker URL is provided, use it\n    if (this.workerUrl) {\n      return this.workerUrl;\n    }\n    \n    // Try to detect the current script location and derive the worker URL\n    if (typeof window !== 'undefined' && window.location) {\n      // Browser environment\n      const currentScript = (document.currentScript as HTMLScriptElement) || \n                           Array.from(document.getElementsByTagName('script')).pop();\n      \n      if (currentScript && currentScript.src) {\n        // Get the base URL from the current script\n        const scriptUrl = new URL(currentScript.src);\n        const baseUrl = scriptUrl.href.substring(0, scriptUrl.href.lastIndexOf('/'));\n        \n        // Check if we're loading from a CDN (jsdelivr, unpkg, etc.)\n        if (scriptUrl.hostname.includes('jsdelivr.net') || \n            scriptUrl.hostname.includes('unpkg.com') ||\n            scriptUrl.hostname.includes('cdnjs.cloudflare.com')) {\n          // For CDN, the worker should be at the same path\n          return `${baseUrl}/kernel.worker.js`;\n        }\n        \n        // For local development or custom deployments\n        return `${baseUrl}/kernel.worker.js`;\n      }\n      \n      // Fallback to relative path from current location\n      const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n      return `${baseUrl}/dist/kernel.worker.js`;\n    }\n    \n    // Node.js or unknown environment - use relative path\n    // This may not work in Node.js but is provided as a fallback\n    return './kernel.worker.js';\n  }\n  \n  /**\n   * Helper function to check if an error is a KeyboardInterrupt\n   * @private\n   */\n  private isKeyboardInterrupt(error: any): boolean {\n    return error && \n           typeof error === 'object' && \n           (('type' in error && error.type === \"KeyboardInterrupt\") ||\n            ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n  }\n  \n  /**\n   * Helper function to create a standardized KeyboardInterrupt error result\n   * @private\n   */\n  private createKeyboardInterruptResult(): { success: boolean; error: Error; result: any } {\n    return {\n      success: false,\n      error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n      result: {\n        status: \"error\",\n        ename: \"KeyboardInterrupt\",\n        evalue: \"Execution interrupted by user\",\n        traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n      }\n    };\n  }\n  \n  /**\n   * Store an AbortController for a specific kernel execution\n   * @private\n   */\n  private storeAbortController(kernelId: string, executionId: string, controller: AbortController): void {\n    if (!this.abortControllers.has(kernelId)) {\n      this.abortControllers.set(kernelId, new Map());\n    }\n    this.abortControllers.get(kernelId)!.set(executionId, controller);\n  }\n\n  /**\n   * Remove and return an AbortController for a specific kernel execution\n   * @private\n   */\n  private removeAbortController(kernelId: string, executionId: string): AbortController | undefined {\n    const kernelControllers = this.abortControllers.get(kernelId);\n    if (!kernelControllers) return undefined;\n    \n    const controller = kernelControllers.get(executionId);\n    if (controller) {\n      kernelControllers.delete(executionId);\n      if (kernelControllers.size === 0) {\n        this.abortControllers.delete(kernelId);\n      }\n    }\n    return controller;\n  }\n\n  /**\n   * Abort all ongoing operations for a specific kernel\n   * @private\n   */\n  private abortAllKernelOperations(kernelId: string): void {\n    const kernelControllers = this.abortControllers.get(kernelId);\n    if (!kernelControllers) return;\n\n    for (const [executionId, controller] of kernelControllers) {\n      try {\n        controller.abort();\n        console.log(`🚫 Aborted execution ${executionId} for kernel ${kernelId}`);\n      } catch (error) {\n        console.warn(`⚠️ Error aborting execution ${executionId}:`, error);\n      }\n    }\n    \n    // Clear all controllers for this kernel\n    this.abortControllers.delete(kernelId);\n  }\n  \n  constructor(options: IKernelManagerOptions = {}) {\n    super();\n    super.setMaxListeners(100); // Allow many listeners for kernel events\n    \n    // Set interruption mode (default to 'auto')\n    this.interruptionMode = options.interruptionMode || 'auto';\n    \n    // Set worker URL if provided\n    this.workerUrl = options.workerUrl;\n    \n    // Set default allowed kernel types (worker mode only for security)\n    this.allowedKernelTypes = options.allowedKernelTypes || [\n      { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n    ];\n    \n    // Initialize pool configuration with defaults based on allowed types\n    const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => \n      type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n    );\n    \n    this.poolConfig = {\n      enabled: false,\n      poolSize: 2,\n      autoRefill: true,\n      preloadConfigs: defaultPreloadConfigs,\n      ...options.pool\n    };\n    \n    // Validate that pool preload configs are within allowed types\n    if (this.poolConfig.preloadConfigs) {\n      this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n        const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n        if (!isAllowed) {\n          console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n        }\n        return isAllowed;\n      });\n    }\n    \n    // Start preloading if pool is enabled\n    if (this.poolConfig.enabled) {\n      this.preloadPool().catch(error => {\n        console.error(\"Error preloading kernel pool:\", error);\n      });\n    }\n  }\n  \n  \n  /**\n   * Generate a pool key for a given mode and language combination\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Pool key string\n   * @private\n   */\n  private getPoolKey(mode: KernelMode, language: KernelLanguage): string {\n    return `${mode}-${language}`;\n  }\n  \n  /**\n   * Get a kernel promise from the pool if available\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Kernel promise or null if none available\n   * @private\n   */\n  private getFromPool(mode: KernelMode, language: KernelLanguage): Promise<IKernelInstance> | null {\n    if (!this.poolConfig.enabled) {\n      return null;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    const poolPromises = this.pool.get(poolKey);\n    \n    if (!poolPromises || poolPromises.length === 0) {\n      return null;\n    }\n    \n    // Remove and return the first promise from the pool (FIFO)\n    const kernelPromise = poolPromises.shift()!;\n    \n    // Immediately trigger background refill to add one promise back\n    if (this.poolConfig.autoRefill) {\n      setTimeout(() => {\n        this.refillPoolSingle(mode, language).catch(error => {\n          console.error(`Error refilling single kernel for ${poolKey}:`, error);\n        });\n      }, 0);\n    }\n    \n    return kernelPromise;\n  }\n  \n  /**\n   * Add a kernel promise to the pool\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @param kernelPromise Kernel promise\n   * @private\n   */\n  private addToPool(mode: KernelMode, language: KernelLanguage, kernelPromise: Promise<IKernelInstance>): void {\n    if (!this.poolConfig.enabled) {\n      return;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    \n    if (!this.pool.has(poolKey)) {\n      this.pool.set(poolKey, []);\n    }\n    \n    const poolPromises = this.pool.get(poolKey)!;\n    \n    // Only add if we haven't reached the pool size limit\n    if (poolPromises.length < this.poolConfig.poolSize) {\n      poolPromises.push(kernelPromise);\n      \n      // Handle promise rejection to prevent unhandled rejections\n      kernelPromise.catch(error => {\n        console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n        // Remove the failed promise from the pool\n        const index = poolPromises.indexOf(kernelPromise);\n        if (index !== -1) {\n          poolPromises.splice(index, 1);\n        }\n      });\n    } else {\n      // Pool is full, let the excess promise resolve and then destroy the kernel\n      kernelPromise.then(kernel => {\n        kernel.destroy().catch(error => {\n          console.error(\"Error destroying excess pool kernel:\", error);\n        });\n      }).catch(error => {\n        console.error(\"Excess pool kernel promise rejected:\", error);\n      });\n    }\n  }\n  \n  /**\n   * Refill the pool with a single kernel promise\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @private\n   */\n  private async refillPoolSingle(mode: KernelMode, language: KernelLanguage): Promise<void> {\n    if (!this.poolConfig.enabled) {\n      return;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    const poolPromises = this.pool.get(poolKey) || [];\n    \n    // Only add one if we're below the pool size\n    if (poolPromises.length < this.poolConfig.poolSize) {\n      const kernelPromise = this.createPoolKernelPromise(mode, language);\n      this.addToPool(mode, language, kernelPromise);\n    }\n  }\n\n  /**\n   * Refill the pool for a specific configuration with parallel creation\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @private\n   */\n  private async refillPool(mode: KernelMode, language: KernelLanguage): Promise<void> {\n    if (!this.poolConfig.enabled) {\n      return;\n    }\n    \n    const poolKey = this.getPoolKey(mode, language);\n    \n    // Check if already prefilling this pool key to prevent duplicates\n    if (this.prefillingInProgress.get(poolKey)) {\n      return;\n    }\n    \n    // Set prefilling flag\n    this.prefillingInProgress.set(poolKey, true);\n    \n    try {\n      const poolPromises = this.pool.get(poolKey) || [];\n      const needed = this.poolConfig.poolSize - poolPromises.length;\n      \n      if (needed <= 0) {\n        return;\n      }\n      \n      // Create all needed kernel promises in parallel\n      const newPromises = Array.from({ length: needed }, () => \n        this.createPoolKernelPromise(mode, language)\n      );\n      \n      // Add all promises to the pool\n      for (const kernelPromise of newPromises) {\n        this.addToPool(mode, language, kernelPromise);\n      }\n      \n    } catch (error) {\n      console.error(`Error refilling pool for ${poolKey}:`, error);\n    } finally {\n      // Always clear the prefilling flag\n      this.prefillingInProgress.set(poolKey, false);\n    }\n  }\n  \n  /**\n   * Create a kernel promise for the pool\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Promise that resolves to a kernel instance\n   * @private\n   */\n  private createPoolKernelPromise(mode: KernelMode, language: KernelLanguage): Promise<IKernelInstance> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const kernel = await this.createPoolKernel(mode, language);\n        // Mark as taken from pool\n        kernel.isFromPool = true;\n        resolve(kernel);\n      } catch (error) {\n        console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Create a kernel specifically for the pool\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns Kernel instance\n   * @private\n   */\n  private async createPoolKernel(mode: KernelMode, language: KernelLanguage): Promise<IKernelInstance> {\n    // Generate a temporary ID for the pool kernel\n    const tempId = `pool-${crypto.randomUUID()}`;\n    \n    // Create kernel with minimal configuration\n    const options: IManagerKernelOptions = {\n      mode,\n      lang: language\n    };\n    \n    // Store options temporarily - but don't store incomplete instance in kernels map\n    // Instead, we'll pass the options directly to the creation methods\n    let instance: IKernelInstance;\n    \n    try {\n      if (mode === KernelMode.MAIN_THREAD) {\n        // For main thread, we need to temporarily store the instance for createMainThreadKernel\n        const tempInstance = {\n          id: tempId,\n          options,\n          mode,\n          language\n        };\n        this.kernels.set(tempId, tempInstance as unknown as IKernelInstance);\n        \n        try {\n          instance = await this.createMainThreadKernel(tempId);\n        } finally {\n          // Always clean up the temporary instance\n          this.kernels.delete(tempId);\n        }\n      } else {\n        // For worker mode, we need to temporarily store the instance for createWorkerKernel\n        const tempInstance = {\n          id: tempId,\n          options,\n          mode,\n          language\n        };\n        this.kernels.set(tempId, tempInstance as unknown as IKernelInstance);\n        \n        try {\n          instance = await this.createWorkerKernel(tempId);\n        } finally {\n          // Always clean up the temporary instance\n          this.kernels.delete(tempId);\n        }\n      }\n    } catch (error) {\n      // Ensure cleanup on any error\n      this.kernels.delete(tempId);\n      throw error;\n    }\n    \n    return instance;\n  }\n  \n  /**\n   * Preload the kernel pool with configured kernel types\n   * @private\n   */\n  private async preloadPool(): Promise<void> {\n    if (!this.poolConfig.enabled || this.isPreloading) {\n      return;\n    }\n    \n    this.isPreloading = true;\n    \n    try {\n      // Preload kernels for each configured type\n      for (const config of this.poolConfig.preloadConfigs) {\n        try {\n          await this.refillPool(config.mode, config.language);\n        } catch (error) {\n          console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n          // Continue with other configurations\n        }\n      }\n    } catch (error) {\n      console.error(\"Error during kernel pool preloading:\", error);\n    } finally {\n      this.isPreloading = false;\n    }\n  }\n  \n  /**\n   * Check if a kernel request can use the pool\n   * @param options Kernel creation options\n   * @returns True if the request can use pool\n   * @private\n   */\n  private canUsePool(options: IManagerKernelOptions): boolean {\n    // Don't use pool if it's disabled\n    if (!this.poolConfig.enabled) {\n      return false;\n    }\n    \n    // Don't use pool if custom filesystem or permissions are specified\n    if (options.filesystem || options.deno?.permissions) {\n      return false;\n    }\n    \n    // Don't use pool if custom timeouts are specified\n    if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n      return false;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Reassign a pool kernel with new ID and options\n   * @param poolKernel Kernel from pool\n   * @param newId New kernel ID\n   * @param options Kernel options\n   * @returns Updated kernel instance\n   * @private\n   */\n  private reassignPoolKernel(\n    poolKernel: IKernelInstance, \n    newId: string, \n    options: IManagerKernelOptions\n  ): IKernelInstance {\n    // Create a new instance object explicitly to avoid spread operator issues\n    const updatedInstance: IKernelInstance = {\n      id: newId,\n      kernel: poolKernel.kernel,\n      mode: poolKernel.mode,\n      language: poolKernel.language,\n      worker: poolKernel.worker,\n      created: new Date().toISOString(), // Update creation time\n      options: { ...poolKernel.options, ...options },\n      isFromPool: true,\n      destroy: poolKernel.destroy // Preserve the original destroy function\n    };\n    \n    // Verify the destroy function is properly set\n    if (typeof updatedInstance.destroy !== 'function') {\n      console.error('Failed to preserve destroy function during pool kernel reassignment');\n      console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n      console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n      throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n    }\n    \n    return updatedInstance;\n  }\n  \n  /**\n   * Get pool statistics for debugging/monitoring\n   * @returns Pool statistics\n   */\n  public getPoolStats(): Record<string, { available: number; total: number }> {\n    const stats: Record<string, { available: number; total: number }> = {};\n    \n    for (const [poolKey, promises] of this.pool.entries()) {\n      stats[poolKey] = {\n        available: promises.length,\n        total: this.poolConfig.poolSize\n      };\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Get pool configuration information\n   * @returns Pool configuration details\n   */\n  public getPoolConfig(): {\n    enabled: boolean;\n    poolSize: number;\n    autoRefill: boolean;\n    preloadConfigs: Array<{\n      mode: KernelMode;\n      language: KernelLanguage;\n    }>;\n    isPreloading: boolean;\n  } {\n    return {\n      enabled: this.poolConfig.enabled,\n      poolSize: this.poolConfig.poolSize,\n      autoRefill: this.poolConfig.autoRefill,\n      preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n      isPreloading: this.isPreloading\n    };\n  }\n  \n  /**\n   * Get the current worker URL configuration\n   * @returns The worker URL or undefined if using auto-detection\n   */\n  public getWorkerUrl(): string | undefined {\n    return this.workerUrl;\n  }\n  \n  /**\n   * Set a custom worker URL for kernel workers\n   * @param url The URL to the kernel.worker.js file\n   * @example\n   * // For CDN usage:\n   * manager.setWorkerUrl('https://cdn.jsdelivr.net/npm/web-python-kernel@latest/dist/kernel.worker.js');\n   * // For local development:\n   * manager.setWorkerUrl('/dist/kernel.worker.js');\n   */\n  public setWorkerUrl(url: string | undefined): void {\n    this.workerUrl = url;\n  }\n  \n  /**\n   * Create a new kernel instance\n   * @param options Options for creating the kernel\n   * @param options.id Optional custom ID for the kernel\n   * @param options.mode Optional kernel mode (main_thread or worker)\n   * @param options.lang Optional kernel language (python or typescript)\n   * @param options.namespace Optional namespace prefix for the kernel ID\n   * @param options.deno.permissions Optional Deno permissions for worker mode\n   * @param options.filesystem Optional filesystem mounting options\n   * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n   * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n   * @returns Promise resolving to the kernel instance ID\n   */\n  public async createKernel(options: IManagerKernelOptions = {}): Promise<string> {\n    // make sure the options.id does not contain colons because it will be used as a namespace prefix\n    if (options.id && options.id.includes(':')) {\n      throw new Error('Kernel ID cannot contain colons');\n    }\n    const baseId = options.id || crypto.randomUUID();\n    const mode = options.mode || KernelMode.WORKER;\n    const language = options.lang || KernelLanguage.PYTHON;\n    \n    // Check if the requested kernel type is allowed\n    if (!this.isKernelTypeAllowed(mode, language)) {\n      throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${\n        this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')\n      }`);\n    }\n    \n    // Apply namespace prefix if provided\n    const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n    \n    // Check if kernel with this ID already exists\n    if (this.kernels.has(id)) {\n      throw new Error(`Kernel with ID ${id} already exists`);\n    }\n    \n    // Try to get from pool if possible\n    if (this.canUsePool(options)) {\n      const poolKey = this.getPoolKey(mode, language);\n      \n      // Check if this kernel type is configured for pooling\n      const isPooledType = this.poolConfig.preloadConfigs.some(config => \n        config.mode === mode && config.language === language\n      );\n      \n      if (isPooledType) {\n        // First try to get from existing pool\n        let poolKernelPromise = this.getFromPool(mode, language);\n        \n        if (poolKernelPromise) {\n          return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n        }\n        \n        // Pool is empty, but this type should be pooled\n        // Create a new promise immediately and trigger background refill\n        try {\n          // Create a new kernel promise specifically for this request\n          const newKernelPromise = this.createPoolKernelPromise(mode, language);\n          \n          // Trigger background refill to replenish the pool for future requests\n          if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n              this.refillPool(mode, language).catch(error => {\n                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n              });\n            }, 0);\n          }\n          \n          return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n        } catch (error) {\n          console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n          // Fall through to on-demand creation as last resort\n        }\n      } else {\n        // This kernel type is not configured for pooling, try to get from pool anyway\n        // in case there are kernels available from previous configurations\n        const poolKernelPromise = this.getFromPool(mode, language);\n        if (poolKernelPromise) {\n          return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n        }\n      }\n    }\n    \n    // Fall back to creating a new kernel on-demand\n    return this.createOnDemandKernel(id, mode, language, options);\n  }\n  \n  /**\n   * Setup a pool kernel from a promise with new ID and options\n   * @param poolKernelPromise Kernel promise from pool\n   * @param id New kernel ID\n   * @param options Kernel options\n   * @returns Kernel ID (returned after kernel is ready)\n   * @private\n   */\n  private async setupPoolKernelFromPromise(\n    poolKernelPromise: Promise<IKernelInstance>, \n    id: string, \n    options: IManagerKernelOptions\n  ): Promise<string> {\n    try {\n      // Wait for the pool kernel to be ready\n      const poolKernel = await poolKernelPromise;\n      \n      // Reassign the pool kernel with the new ID and options\n      const instance = this.reassignPoolKernel(poolKernel, id, options);\n      \n      // For worker kernels, we need to recreate the event handler with the new ID\n      if (instance.mode === KernelMode.WORKER && instance.worker) {\n        // Get the worker and create new message channel\n        const worker = instance.worker;\n        \n        // Create a new message channel for the reassigned kernel\n        const { port1, port2 } = new MessageChannel();\n        \n        // Send the new event port to the worker\n        worker.postMessage({\n          type: \"SET_EVENT_PORT\",\n          port: port2\n        }, [port2]);\n        \n        // Create a new event handler with the correct kernel ID\n        const eventHandler = (event: MessageEvent) => {\n          if (event.data && event.data.type) {\n            // Emit the event from the manager with kernel ID\n            // This structure matches the setupEventForwarding method for main thread kernels\n            super.emit(event.data.type, {\n              kernelId: id,\n              data: event.data.data\n            });\n          }\n        };\n        \n        // Listen for events from the worker with the new handler\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        \n        // Update the destroy function to clean up the new event handler\n        const originalDestroy = instance.destroy;\n        instance.destroy = async () => {\n          port1.removeEventListener('message', eventHandler);\n          port1.close();\n          return originalDestroy();\n        };\n      }\n      \n      // Store the kernel instance\n      this.kernels.set(id, instance);\n      \n      // Forward kernel events to manager (for main thread kernels)\n      this.setupEventForwarding(instance);\n      \n      // Initialize activity tracking\n      this.updateKernelActivity(id);\n      \n      // Set up inactivity timeout if specified and greater than 0\n      if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n        this.setupInactivityTimeout(id, options.inactivityTimeout);\n      }\n      \n      // Setup handlers for stalled executions if maxExecutionTime is specified\n      if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n        this.setupStalledExecutionHandler(id);\n      }\n      \n      return id;\n    } catch (error) {\n      console.error(`Error setting up pool kernel ${id}:`, error);\n      // Emit an error event for this kernel\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: id,\n        data: {\n          ename: \"KernelSetupError\",\n          evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n          traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n        }\n      });\n      throw error; // Re-throw to let the caller handle it\n    }\n  }\n\n  /**\n   * Setup a pool kernel with new ID and options (for already resolved kernels)\n   * @param poolKernel Kernel from pool\n   * @param id New kernel ID\n   * @param options Kernel options\n   * @returns Kernel ID\n   * @private\n   */\n  private setupPoolKernel(\n    poolKernel: IKernelInstance, \n    id: string, \n    options: IManagerKernelOptions\n  ): string {\n    // Reassign the pool kernel with the new ID and options\n    const instance = this.reassignPoolKernel(poolKernel, id, options);\n    \n    // For worker kernels, we need to recreate the event handler with the new ID\n    if (instance.mode === KernelMode.WORKER && instance.worker) {\n      // Get the worker and create new message channel\n      const worker = instance.worker;\n      \n      // Create a new message channel for the reassigned kernel\n      const { port1, port2 } = new MessageChannel();\n      \n      // Send the new event port to the worker\n      worker.postMessage({\n        type: \"SET_EVENT_PORT\",\n        port: port2\n      }, [port2]);\n      \n      // Create a new event handler with the correct kernel ID\n      const eventHandler = (event: MessageEvent) => {\n        if (event.data && event.data.type) {\n          // Emit the event from the manager with kernel ID\n          // This structure matches the setupEventForwarding method for main thread kernels\n          super.emit(event.data.type, {\n            kernelId: id,\n            data: event.data.data\n          });\n        }\n      };\n      \n      // Listen for events from the worker with the new handler\n      port1.addEventListener('message', eventHandler);\n      port1.start();\n      \n      // Update the destroy function to clean up the new event handler\n      const originalDestroy = instance.destroy;\n      instance.destroy = async () => {\n        port1.removeEventListener('message', eventHandler);\n        port1.close();\n        return originalDestroy();\n      };\n    }\n    \n    // Store the kernel instance\n    this.kernels.set(id, instance);\n    \n    // Forward kernel events to manager (for main thread kernels)\n    this.setupEventForwarding(instance);\n    \n    // Initialize activity tracking\n    this.updateKernelActivity(id);\n    \n    // Set up inactivity timeout if specified and greater than 0\n    if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n      this.setupInactivityTimeout(id, options.inactivityTimeout);\n    }\n    \n    // Setup handlers for stalled executions if maxExecutionTime is specified\n    if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n      this.setupStalledExecutionHandler(id);\n    }\n    \n    return id;\n  }\n  \n  /**\n   * Create a kernel on-demand (not from pool)\n   * @param id Kernel ID\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @param options Kernel options\n   * @returns Kernel ID\n   * @private\n   */\n  private async createOnDemandKernel(\n    id: string, \n    mode: KernelMode, \n    language: KernelLanguage, \n    options: IManagerKernelOptions\n  ): Promise<string> {\n    // Store options temporarily to be used in createWorkerKernel\n    const tempInstance = {\n      id,\n      options: { ...options, lang: language },\n      mode,\n      language\n    };\n    this.kernels.set(id, tempInstance as unknown as IKernelInstance);\n    \n    // Create the appropriate kernel instance\n    let instance: IKernelInstance;\n    \n    if (mode === KernelMode.MAIN_THREAD) {\n      instance = await this.createMainThreadKernel(id);\n    } else {\n      instance = await this.createWorkerKernel(id);\n    }\n    \n    // Store the kernel instance\n    this.kernels.set(id, instance);\n    \n    // Forward kernel events to manager\n    this.setupEventForwarding(instance);\n    \n    // Initialize activity tracking\n    this.updateKernelActivity(id);\n    \n    // Set up inactivity timeout if specified and greater than 0\n    if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n      this.setupInactivityTimeout(id, options.inactivityTimeout);\n    }\n    \n    // Setup handlers for stalled executions if maxExecutionTime is specified\n    if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n      this.setupStalledExecutionHandler(id);\n    }\n    \n    return id;\n  }\n  \n  /**\n   * Create a kernel instance running in the main thread\n   * @param id Kernel ID\n   * @returns Kernel instance\n   */\n  private async createMainThreadKernel(id: string): Promise<IKernelInstance> {\n    // Get options from the temporary instance\n    const options = this.kernels.get(id)?.options || {};\n    const language = options.lang || KernelLanguage.PYTHON;\n    \n    // Create the Python kernel\n    const kernel = new Kernel();\n    \n    // Create the kernel instance\n    const instance: IKernelInstance = {\n      id,\n      kernel,\n      mode: KernelMode.MAIN_THREAD,\n      language,\n      created: new Date().toISOString(),\n      options,\n      destroy: async () => {\n        // Nothing special to do for main thread kernel\n        return Promise.resolve();\n      }\n    };\n    \n    // Initialize the kernel with filesystem options\n    const kernelOptions: IKernelOptions = {};\n\n    // Add filesystem options if provided\n    if (options.filesystem) {\n      kernelOptions.filesystem = options.filesystem;\n    }\n\n    // Add environment variables if provided\n    if (options.env) {\n      kernelOptions.env = options.env;\n    }\n\n    // Add lockFileURL if provided\n    if (options.lockFileURL) {\n      kernelOptions.lockFileURL = options.lockFileURL;\n    }\n\n    // Add autoSyncFs if provided\n    if (options.autoSyncFs !== undefined) {\n      kernelOptions.autoSyncFs = options.autoSyncFs;\n    }\n\n    // Initialize the kernel\n    await kernel.initialize(kernelOptions);\n    \n    return instance;\n  }\n  \n  /**\n   * Create a kernel instance running in a worker\n   * @param id Kernel ID\n   * @returns Kernel instance\n   */\n  private async createWorkerKernel(id: string): Promise<IKernelInstance> {\n    // Get permissions from options when creating the kernel\n    const options = this.kernels.get(id)?.options || {};\n    const language = options.lang || KernelLanguage.PYTHON;\n    \n    // Create a new worker with optional permissions\n    const workerOptions: WorkerOptions = {\n      type: \"module\",\n    };\n    \n    // If Deno permissions are provided, use them.\n    // Otherwise don't specify Deno permissions at all to inherit from host script\n    if (options.deno?.permissions) {\n      workerOptions.deno = {\n        permissions: options.deno.permissions\n      };\n    }\n    \n    // Determine the worker URL based on the environment\n    const workerUrl = this.resolveWorkerUrl();\n    const worker = new Worker(workerUrl, { type: 'classic' });\n    \n    // Create a message channel for events\n    const { port1, port2 } = new MessageChannel();\n    \n    // Create a promise that will resolve when the kernel is initialized\n    const initPromise = new Promise<void>((resolve, reject) => {\n      const initHandler = (event: MessageEvent) => {\n        if (event.data?.type === \"KERNEL_INITIALIZED\") {\n          if (event.data.data.success) {\n            port1.removeEventListener('message', initHandler);\n            resolve();\n          } else {\n            port1.removeEventListener('message', initHandler);\n            reject(new Error(\"Kernel initialization failed\"));\n          }\n        }\n      };\n      port1.addEventListener('message', initHandler);\n    });\n    \n    // Send the port to the worker\n    worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n    \n    // Create a proxy to the worker using Comlink\n    const kernelProxy = Comlink.wrap<IKernel>(worker);\n    \n    // Add a local event handler to bridge the worker events\n    // This works around the limitation that Comlink doesn't proxy event emitters\n    const eventHandler = (event: MessageEvent) => {\n      if (event.data && event.data.type) {\n        // Emit the event from the manager with kernel ID\n        // This structure matches the setupEventForwarding method for main thread kernels\n        super.emit(event.data.type, {\n          kernelId: id,\n          data: event.data.data\n        });\n      }\n    };\n    \n    // Listen for events from the worker\n    port1.addEventListener('message', eventHandler);\n    port1.start();\n    \n    // Initialize the kernel with filesystem options\n    // We need to pass these options to the worker\n    worker.postMessage({\n      type: \"INITIALIZE_KERNEL\",\n      options: {\n        filesystem: options.filesystem,\n        env: options.env,\n        lockFileURL: options.lockFileURL,\n        autoSyncFs: options.autoSyncFs,\n        lang: language\n      }\n    });\n    \n    // Wait for kernel initialization\n    await initPromise;\n    \n    // Set up interrupt buffer automatically for worker kernels\n    await this.setupWorkerInterruptBuffer(id, worker);\n    \n    // Create the kernel instance\n    const instance: IKernelInstance = {\n      id,\n      kernel: {\n        // Map methods from the Comlink proxy to the IKernel interface\n        initialize: async (options?: IKernelOptions) => {\n          return kernelProxy.initialize(options);\n        },\n        execute: async (code: string, parent?: any) => {\n          const result = await kernelProxy.execute(code, parent);\n          \n          // Handle Python worker results (no special display reconstruction needed)\n          \n          return result;\n        },\n        isInitialized: () => {\n          return kernelProxy.isInitialized();\n        },\n        inputReply: async (content: { value: string }) => {\n          return kernelProxy.inputReply(content);\n        },\n        // Map async getStatus method\n        getStatus: async () => {\n          try {\n            if (typeof kernelProxy.getStatus === 'function') {\n              return await kernelProxy.getStatus();\n            } else {\n              return \"unknown\";\n            }\n          } catch (error) {\n            return \"unknown\";\n          }\n        },\n        // Map completion methods\n        complete: async (code: string, cursor_pos: number, parent?: any) => {\n          try {\n            if (typeof kernelProxy.complete === 'function') {\n              return await kernelProxy.complete(code, cursor_pos, parent);\n            } else {\n              return { status: 'error', error: 'Completion not supported' };\n            }\n          } catch (error) {\n            return { status: 'error', error: String(error) };\n          }\n        },\n        inspect: async (code: string, cursor_pos: number, detail_level: 0 | 1, parent?: any) => {\n          try {\n            if (typeof kernelProxy.inspect === 'function') {\n              return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n            } else {\n              return { status: 'error', error: 'Inspection not supported' };\n            }\n          } catch (error) {\n            return { status: 'error', error: String(error) };\n          }\n        },\n        isComplete: async (code: string, parent?: any) => {\n          try {\n            if (typeof kernelProxy.isComplete === 'function') {\n              return await kernelProxy.isComplete(code, parent);\n            } else {\n              return { status: 'unknown' };\n            }\n          } catch (error) {\n            return { status: 'error', error: String(error) };\n          }\n        },\n        // Map interrupt methods\n        interrupt: async () => {\n          try {\n            if (typeof kernelProxy.interrupt === 'function') {\n              return await kernelProxy.interrupt();\n            } else {\n              return false;\n            }\n          } catch (error) {\n            return false;\n          }\n        },\n        setInterruptBuffer: (buffer: Uint8Array) => {\n          try {\n            if (typeof kernelProxy.setInterruptBuffer === 'function') {\n              kernelProxy.setInterruptBuffer(buffer);\n            }\n          } catch (error) {\n            console.warn('Failed to set interrupt buffer:', error);\n          }\n        },\n        // Map mountFS method\n        mountFS: async (mountPath: string, dirHandle?: FileSystemDirectoryHandle | null, permission?: 'read' | 'readwrite') => {\n          try {\n            if (typeof kernelProxy.mountFS === 'function') {\n              return await kernelProxy.mountFS(mountPath, dirHandle, permission);\n            } else {\n              throw new Error('mountFS is not supported by this kernel');\n            }\n          } catch (error) {\n            throw error;\n          }\n        },\n        // Map filesystem sync methods\n        getMountedFileSystems: () => {\n          try {\n            if (typeof kernelProxy.getMountedFileSystems === 'function') {\n              return kernelProxy.getMountedFileSystems();\n            } else {\n              return [];\n            }\n          } catch (error) {\n            console.warn('Failed to get mounted filesystems:', error);\n            return [];\n          }\n        },\n        syncFileSystem: async (mountPath: string) => {\n          try {\n            if (typeof kernelProxy.syncFileSystem === 'function') {\n              return await kernelProxy.syncFileSystem(mountPath);\n            } else {\n              return { success: false, error: 'syncFileSystem is not supported by this kernel' };\n            }\n          } catch (error) {\n            return { success: false, error: error instanceof Error ? error.message : String(error) };\n          }\n        },\n        upgradeFileSystemPermission: async (mountPath: string) => {\n          try {\n            if (typeof kernelProxy.upgradeFileSystemPermission === 'function') {\n              return await kernelProxy.upgradeFileSystemPermission(mountPath);\n            } else {\n              return { success: false, error: 'upgradeFileSystemPermission is not supported by this kernel' };\n            }\n          } catch (error) {\n            return { success: false, error: error instanceof Error ? error.message : String(error) };\n          }\n        },\n        // Map comm methods\n        commInfo: async (target_name: string | null, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commInfo === 'function') {\n              return await kernelProxy.commInfo(target_name, parent);\n            } else {\n              return { comms: {}, status: 'ok' };\n            }\n          } catch (error) {\n            return { comms: {}, status: 'error', error: String(error) };\n          }\n        },\n        commOpen: async (content: any, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commOpen === 'function') {\n              return await kernelProxy.commOpen(content, parent);\n            }\n          } catch (error) {\n            console.warn('Failed to open comm:', error);\n          }\n        },\n        commMsg: async (content: any, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commMsg === 'function') {\n              return await kernelProxy.commMsg(content, parent);\n            }\n          } catch (error) {\n            console.warn('Failed to send comm message:', error);\n          }\n        },\n        commClose: async (content: any, parent?: any) => {\n          try {\n            if (typeof kernelProxy.commClose === 'function') {\n              return await kernelProxy.commClose(content, parent);\n            }\n          } catch (error) {\n            console.warn('Failed to close comm:', error);\n          }\n        }\n      } as unknown as IKernel,\n      mode: KernelMode.WORKER,\n      language,\n      worker,\n      created: new Date().toISOString(),\n      options, // Store the options for reference\n      destroy: async () => {\n        // Clean up the worker and event listeners\n        port1.removeEventListener('message', eventHandler);\n        port1.close();\n        worker.terminate();\n        return Promise.resolve();\n      }\n    };\n    \n    return instance;\n  }\n  \n  /**\n   * Setup event forwarding from kernel to manager\n   * @param instance Kernel instance\n   */\n  private setupEventForwarding(instance: IKernelInstance): void {\n    // Only needed for main thread kernels as worker events are handled directly\n    if (instance.mode === KernelMode.MAIN_THREAD) {\n      // Forward all kernel events to the manager with kernel ID\n      Object.values(KernelEvents).forEach((eventType) => {\n        // Access the kernel as a Kernel instance which extends EventEmitter\n        const kernelEmitter = instance.kernel as unknown as EventEmitter;\n        \n        // Add event listener to forward events\n        kernelEmitter.on(eventType, (data: any) => {\n          super.emit(eventType, {\n            kernelId: instance.id,\n            data\n          });\n        });\n      });\n    }\n  }\n  \n  /**\n   * Get a kernel instance by ID\n   * @param id Kernel ID\n   * @returns Kernel instance or undefined if not found\n   */\n  public getKernel(id: string): IKernelInstance | undefined {\n    return this.kernels.get(id);\n  }\n  \n  /**\n   * Get a list of all kernel IDs\n   * @returns Array of kernel IDs\n   */\n  public getKernelIds(): string[] {\n    return Array.from(this.kernels.keys());\n  }\n  \n  /**\n   * Get a list of all kernels with their details\n   * @param namespace Optional namespace to filter kernels by\n   * @returns Array of kernel information objects\n   */\n  public async listKernels(namespace?: string): Promise<Array<{\n    id: string;\n    mode: KernelMode;\n    language: KernelLanguage;\n    status: \"active\" | \"busy\" | \"unknown\";\n    created: string;\n    namespace?: string;\n    deno?: {\n      permissions?: IDenoPermissions;\n    };\n  }>> {\n          const filteredKernels = Array.from(this.kernels.entries())\n        .filter(([id]) => {\n          // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n          if (id.startsWith(\"pool-\")) return false;\n          \n          if (!namespace) return true;\n          return id.startsWith(`${namespace}:`);\n        });\n\n      // Use Promise.all to get all statuses concurrently\n      const kernelInfos = await Promise.all(\n        filteredKernels.map(async ([id, instance]) => {\n          // Extract namespace from id if present\n          const namespaceMatch = id.match(/^([^:]+):/);\n          const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n          \n          // Get status using async getStatus method\n          let status: \"active\" | \"busy\" | \"unknown\" = \"unknown\";\n          try {\n            if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n              status = await instance.kernel.getStatus();\n            }\n          } catch (error) {\n            console.warn(`Error getting status for kernel ${id}:`, error);\n            status = \"unknown\";\n          }\n          \n          return {\n            id,\n            mode: instance.mode,\n            language: instance.language,\n            status,\n            created: instance.created || new Date().toISOString(),\n            namespace: extractedNamespace,\n            deno: instance.options?.deno\n          };\n        })\n      );\n\n      return kernelInfos;\n  }\n  \n  /**\n   * Destroy a kernel instance\n   * @param id Kernel ID\n   * @returns Promise resolving when kernel is destroyed\n   */\n  public async destroyKernel(id: string): Promise<void> {\n    const instance = this.kernels.get(id);\n    \n    if (!instance) {\n      // Handle gracefully - kernel may already be destroyed\n      return;\n    }\n    \n    // Verify the destroy function exists\n    if (typeof instance.destroy !== 'function') {\n      throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n    }\n    \n    // Abort all ongoing operations for this kernel first\n    this.abortAllKernelOperations(id);\n    \n    // Clear any inactivity timer\n    this.clearInactivityTimeout(id);\n    \n    // Clean up execution timeouts\n    if (this.executionTimeouts.has(id)) {\n      const timeouts = this.executionTimeouts.get(id)!;\n      for (const timeoutId of timeouts.values()) {\n        clearTimeout(timeoutId);\n      }\n      this.executionTimeouts.delete(id);\n    }\n    \n    // Clean up execution start times\n    if (this.executionStartTimes.has(id)) {\n      this.executionStartTimes.delete(id);\n    }\n    \n    // Clean up execution metadata\n    if (this.executionMetadata.has(id)) {\n      this.executionMetadata.delete(id);\n    }\n    \n    // Clean up interrupt buffers\n    if (this.interruptBuffers.has(id)) {\n      this.interruptBuffers.delete(id);\n    }\n    \n    // Clean up ongoing executions tracking\n    this.ongoingExecutions.delete(id);\n    \n    // Clean up activity tracking\n    this.lastActivityTime.delete(id);\n    \n    // Remove all event listeners for this kernel\n    this.removeAllKernelListeners(id);\n    \n    // Destroy the kernel instance\n    await instance.destroy();\n    \n    // Remove the kernel from the map\n    this.kernels.delete(id);\n  }\n  \n  /**\n   * Destroy all kernel instances\n   * @param namespace Optional namespace to filter kernels to destroy\n   * @returns Promise resolving when all kernels are destroyed\n   */\n  public async destroyAll(namespace?: string): Promise<void> {\n    const ids = Array.from(this.kernels.keys())\n      .filter(id => {\n        if (!namespace) return true;\n        return id.startsWith(`${namespace}:`);\n      });\n    \n    // Destroy all kernels, but skip incomplete instances\n    const destroyPromises = ids.map(async (id) => {\n      const instance = this.kernels.get(id);\n      if (!instance || typeof instance.destroy !== 'function') {\n        console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n        // Just remove it from the map\n        this.kernels.delete(id);\n        return;\n      }\n      return this.destroyKernel(id);\n    });\n    \n    await Promise.all(destroyPromises);\n    \n    // If no namespace specified, also clean up the pool\n    if (!namespace) {\n      await this.destroyPool();\n    }\n  }\n  \n  /**\n   * Destroy all kernels in the pool\n   * @private\n   */\n  private async destroyPool(): Promise<void> {\n    \n    const destroyPromises: Promise<void>[] = [];\n    \n    for (const [poolKey, promises] of this.pool.entries()) {\n      \n      for (const kernelPromise of promises) {\n        // Handle each promise - if it resolves, destroy the kernel\n        const destroyPromise = kernelPromise.then(kernel => {\n          return kernel.destroy();\n        }).catch(error => {\n          console.error(`Error destroying pool kernel from promise:`, error);\n          // Don't re-throw to avoid unhandled rejections\n        });\n        \n        destroyPromises.push(destroyPromise);\n      }\n    }\n    \n    // Wait for all pool kernels to be destroyed\n    await Promise.all(destroyPromises);\n    \n    // Clear the pool and prefilling flags\n    this.pool.clear();\n    this.prefillingInProgress.clear();\n  }\n  \n  /**\n   * Register an event listener for a specific kernel's events\n   * @param kernelId Kernel ID\n   * @param eventType Event type\n   * @param listener Event listener\n   */\n  public onKernelEvent(kernelId: string, eventType: KernelEvents, listener: (data: any) => void): void {\n    // Check if kernel exists\n    if (!this.kernels.has(kernelId)) {\n      throw new Error(`Kernel with ID ${kernelId} not found`);\n    }\n    \n    // Create wrapper that filters events for this specific kernel\n    const wrapper: ListenerWrapper = {\n      original: listener,\n      wrapped: (event: { kernelId: string, data: any }) => {\n        if (event.kernelId === kernelId) {\n          // Pass just the data to the listener\n          // The data structure is consistent across main thread and worker modes\n          listener(event.data);\n        }\n      }\n    };\n    \n    // Store the wrapper for later removal\n    this.storeListener(kernelId, eventType, listener, wrapper);\n    \n    // Add the wrapped listener to the manager\n    super.on(eventType, wrapper.wrapped);\n  }\n  \n  /**\n   * Remove an event listener for a specific kernel\n   * @param kernelId Kernel ID\n   * @param eventType Event type\n   * @param listener Event listener\n   */\n  public offKernelEvent(kernelId: string, eventType: KernelEvents, listener: (data: any) => void): void {\n    const wrapper = this.getListener(kernelId, eventType, listener);\n    \n    if (wrapper) {\n      // Remove the wrapped listener from the manager\n      super.removeListener(eventType, wrapper.wrapped);\n      \n      // Remove the wrapper from our tracking map\n      this.removeStoredListener(kernelId, eventType, listener);\n    }\n  }\n  \n  /**\n   * Store a listener wrapper for later removal\n   */\n  private storeListener(\n    kernelId: string, \n    eventType: string, \n    original: Function, \n    wrapper: ListenerWrapper\n  ): void {\n    // Get or create kernel map\n    if (!this.listenerWrappers.has(kernelId)) {\n      this.listenerWrappers.set(kernelId, new Map());\n    }\n    const kernelMap = this.listenerWrappers.get(kernelId)!;\n    \n    // Get or create event type map\n    if (!kernelMap.has(eventType)) {\n      kernelMap.set(eventType, new Map());\n    }\n    const eventMap = kernelMap.get(eventType)!;\n    \n    // Store the wrapper\n    eventMap.set(original, wrapper);\n  }\n  \n  /**\n   * Get a stored listener wrapper\n   */\n  private getListener(\n    kernelId: string, \n    eventType: string, \n    original: Function\n  ): ListenerWrapper | undefined {\n    const kernelMap = this.listenerWrappers.get(kernelId);\n    if (!kernelMap) return undefined;\n    \n    const eventMap = kernelMap.get(eventType);\n    if (!eventMap) return undefined;\n    \n    return eventMap.get(original);\n  }\n  \n  /**\n   * Remove a stored listener wrapper\n   */\n  private removeStoredListener(\n    kernelId: string, \n    eventType: string, \n    original: Function\n  ): void {\n    const kernelMap = this.listenerWrappers.get(kernelId);\n    if (!kernelMap) return;\n    \n    const eventMap = kernelMap.get(eventType);\n    if (!eventMap) return;\n    \n    // Remove the listener\n    eventMap.delete(original);\n    \n    // Clean up empty maps\n    if (eventMap.size === 0) {\n      kernelMap.delete(eventType);\n    }\n    \n    if (kernelMap.size === 0) {\n      this.listenerWrappers.delete(kernelId);\n    }\n  }\n  \n  /**\n   * Remove all listeners for a specific kernel\n   */\n  private removeAllKernelListeners(kernelId: string): void {\n    const kernelMap = this.listenerWrappers.get(kernelId);\n    if (!kernelMap) return;\n    \n    // For each event type\n    for (const [eventType, eventMap] of kernelMap.entries()) {\n      // For each original listener\n      for (const wrapper of eventMap.values()) {\n        // Remove the wrapped listener from the manager\n        super.removeListener(eventType, wrapper.wrapped);\n      }\n    }\n    \n    // Clear the kernel's listener map\n    this.listenerWrappers.delete(kernelId);\n  }\n  \n  /**\n   * Get all listeners for a specific kernel and event type\n   * @param kernelId Kernel ID\n   * @param eventType Event type\n   * @returns Array of listeners\n   */\n  public getListeners(kernelId: string, eventType: KernelEvents): ((data: any) => void)[] {\n    const kernelListeners = this.listenerWrappers.get(kernelId);\n    if (!kernelListeners) {\n      return [];\n    }\n    \n    const eventListeners = kernelListeners.get(eventType);\n    if (!eventListeners) {\n      return [];\n    }\n    \n    return Array.from(eventListeners.keys()) as ((data: any) => void)[];\n  }\n\n  /**\n   * Execute Python code with streaming output\n   * This method works in both main thread and worker modes\n   * @param kernelId ID of the kernel to use\n   * @param code The Python code to execute\n   * @param parent Optional parent message header\n   * @returns AsyncGenerator yielding intermediate outputs\n   */\n  public async* executeStream(\n    kernelId: string, \n    code: string, \n    parent: any = {}\n  ): AsyncGenerator<any, { success: boolean, result?: any, error?: Error }, void> {\n    const instance = this.getKernel(kernelId);\n    \n    if (!instance) {\n      throw new Error(`Kernel with ID ${kernelId} not found`);\n    }\n    \n    // Update kernel activity\n    this.updateKernelActivity(kernelId);\n    \n    // Track this execution with the code for better monitoring\n    const executionId = this.trackExecution(kernelId, code);\n    \n    // Create AbortController for this execution to enable cancellation\n    const abortController = new AbortController();\n    this.storeAbortController(kernelId, executionId, abortController);\n    \n    try {\n      // For main thread kernels, we can use the executeStream method directly\n      if (instance.mode === KernelMode.MAIN_THREAD) {\n        const kernel = instance.kernel as unknown as { \n          executeStream: (code: string, parent: any) => AsyncGenerator<any, any, void> \n        };\n        \n        // Forward to the kernel's executeStream method\n        if (typeof kernel.executeStream === 'function') {\n          try {\n            yield* kernel.executeStream(code, parent);\n            \n            // Update activity after execution completes\n            this.updateKernelActivity(kernelId);\n            \n            // Complete execution tracking\n            this.completeExecution(kernelId, executionId);\n            \n            return { success: true };\n          } catch (error) {\n            console.error(`Error in main thread executeStream:`, error);\n            \n            // Update activity even if there's an error\n            this.updateKernelActivity(kernelId);\n            \n            // Complete execution tracking even on error\n            this.completeExecution(kernelId, executionId);\n            \n            return { \n              success: false, \n              error: error instanceof Error ? error : new Error(String(error))\n            };\n          }\n        }\n      }\n      \n      // For worker mode, we need to implement streaming via events with proper isolation\n      try {\n        // Event-based approach for worker kernels or main thread kernels without executeStream\n        const streamQueue: any[] = [];\n        let executionComplete = false;\n        let executionResult: { success: boolean, result?: any, error?: Error } = { success: true };\n        \n        // Store handler references for guaranteed cleanup\n        const eventHandlers = new Map<string, (event: { kernelId: string, data: any }) => void>();\n        \n        // Helper function to clean up all event handlers\n        const cleanupHandlers = () => {\n          for (const [eventType, handler] of eventHandlers.entries()) {\n            super.off(eventType as any, handler);\n          }\n          eventHandlers.clear();\n        };\n        \n        // Create execution-specific event handlers that include executionId check\n        const createHandler = (eventType: string) => {\n          const handler = (event: { kernelId: string, data: any }) => {\n            // Only process events for this specific kernel and while this execution is active\n            if (event.kernelId === kernelId && !executionComplete) {\n              streamQueue.push({\n                type: eventType,\n                data: event.data,\n                executionId // Include execution ID for debugging\n              });\n              \n              // Events also count as activity\n              this.updateKernelActivity(kernelId);\n            }\n          };\n          eventHandlers.set(eventType, handler);\n          return handler;\n        };\n        \n        // Create and register all event handlers\n        const handleStreamEvent = createHandler('stream');\n        const handleDisplayEvent = createHandler('display_data');\n        const handleUpdateDisplayEvent = createHandler('update_display_data');\n        const handleResultEvent = createHandler('execute_result');\n        const handleErrorEvent = createHandler('execute_error');\n        \n        // Register handlers\n        super.on(KernelEvents.STREAM, handleStreamEvent);\n        super.on(KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n        super.on(KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n        super.on(KernelEvents.EXECUTE_RESULT, handleResultEvent);\n        super.on(KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n        \n        // Create a promise that will resolve when execution is complete\n        const executionPromise = new Promise<{ success: boolean, result?: any, error?: Error }>((resolve, reject) => {\n          // Set up a handler for execution errors specifically\n          const handleExecutionError = (event: { kernelId: string, data: any }) => {\n            if (event.kernelId === kernelId && !executionComplete) {\n              // Mark execution as complete to stop processing more events\n              executionComplete = true;\n              \n              // Store the error for the final result\n              executionResult = {\n                success: false,\n                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                result: event.data\n              };\n              \n              // Update activity\n              this.updateKernelActivity(kernelId);\n              \n              resolve(executionResult);\n            }\n          };\n          \n          // Add error handler to our cleanup list\n          eventHandlers.set('execute_error_completion', handleExecutionError);\n          super.on(KernelEvents.EXECUTE_ERROR, handleExecutionError);\n          \n          // Check if already aborted\n          if (abortController.signal.aborted) {\n            executionComplete = true;\n            resolve({\n              success: false,\n              error: new Error('Execution was aborted')\n            });\n            return;\n          }\n          \n          // Set up abort handler\n          const abortHandler = () => {\n            if (!executionComplete) {\n              console.log(`🚫 Execution ${executionId} aborted`);\n              executionComplete = true;\n              \n              resolve({\n                success: false,\n                error: new Error('Execution was aborted')\n              });\n            }\n          };\n          \n          abortController.signal.addEventListener('abort', abortHandler);\n          \n          // Execute the code\n          // We know the execute method is available directly on the kernel object\n          try {\n            const executePromise = instance.kernel.execute(code, parent);\n            \n            executePromise.then((result) => {\n              // Only process if execution hasn't been marked complete already\n              if (!executionComplete) {\n                // Check if the execution result indicates an error (for Python kernels)\n                if (result.success && result.result && result.result.status === \"error\") {\n                  // Handle as error\n                  const errorData = {\n                    status: result.result.status,\n                    ename: result.result.ename,\n                    evalue: result.result.evalue,\n                    traceback: result.result.traceback\n                  };\n                  \n                  // Push error to stream queue directly \n                  streamQueue.push({\n                    type: 'error',\n                    data: errorData,\n                    executionId\n                  });\n                  \n                  // Update execution result to reflect the error\n                  executionResult = {\n                    success: false,\n                    error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                    result: result.result\n                  };\n                } else {\n                  executionResult = result;\n                }\n                \n                executionComplete = true;\n                \n                // Update activity when execution completes\n                this.updateKernelActivity(kernelId);\n                \n                resolve(executionResult);\n              }\n            }).catch((error) => {\n              // Only process if execution hasn't been marked complete already\n              if (!executionComplete) {\n                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                \n                // Check if this is a KeyboardInterrupt and handle it specially\n                let errorResult;\n                if (this.isKeyboardInterrupt(error)) {\n                  console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                  errorResult = this.createKeyboardInterruptResult();\n                  \n                  // Also push to stream queue for immediate feedback\n                  streamQueue.push({\n                    type: 'error',\n                    data: errorResult.result,\n                    executionId\n                  });\n                } else {\n                  // Handle other errors normally\n                  errorResult = {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                  };\n                }\n                \n                executionComplete = true;\n                executionResult = errorResult;\n                \n                // Update activity even on error\n                this.updateKernelActivity(kernelId);\n                \n                resolve(errorResult);\n              }\n            });\n          } catch (error) {\n            // Only process if execution hasn't been marked complete already\n            if (!executionComplete) {\n              console.error(`Error calling execute for kernel ${kernelId}:`, error);\n              \n              // Simple error handling\n              const errorResult = {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n              };\n              \n              executionComplete = true;\n              executionResult = errorResult;\n              \n              // Update activity even on direct error\n              this.updateKernelActivity(kernelId);\n              \n              resolve(errorResult);\n            }\n          }\n        });\n        \n        // Use try/finally to guarantee cleanup\n        try {\n          // Monitor the stream queue and yield results\n          // Continue until execution is complete AND all queued events have been yielded\n          while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n            // If there are items in the queue, yield them\n            if (streamQueue.length > 0) {\n              const event = streamQueue.shift();\n              yield event;\n              continue;\n            }\n            \n            // If no more events but execution is not complete, wait a little\n            if (!executionComplete) {\n              // Use abort signal to cancel the wait\n              try {\n                await new Promise((resolve, reject) => {\n                  const timeoutId = setTimeout(resolve, 10);\n                  abortController.signal.addEventListener('abort', () => {\n                    clearTimeout(timeoutId);\n                    reject(new Error('Aborted'));\n                  });\n                });\n              } catch (error) {\n                // If aborted, break out of loop\n                if (abortController.signal.aborted) {\n                  break;\n                }\n              }\n            }\n          }\n          \n          // Check if execution was aborted during stream monitoring\n          if (abortController.signal.aborted && !executionComplete) {\n            throw new Error('Execution was aborted during stream monitoring');\n          }\n          \n          // Wait for the final result\n          const result = await executionPromise;\n          return result;\n        } finally {\n          // ALWAYS clean up event handlers regardless of how execution ends\n          cleanupHandlers();\n          \n          // Remove AbortController to prevent memory leaks\n          this.removeAbortController(kernelId, executionId);\n          \n          // Complete execution tracking\n          this.completeExecution(kernelId, executionId);\n        }\n      } catch (error) {\n        // Complete execution tracking on any outer error\n        this.completeExecution(kernelId, executionId);\n        \n        console.error(`Unexpected error in executeStream:`, error);\n        return {\n          success: false, \n          error: error instanceof Error ? error : new Error(String(error))\n        };\n      }\n    } catch (error) {\n      // Complete execution tracking on any outer error\n      this.completeExecution(kernelId, executionId);\n      \n      console.error(`Unexpected error in executeStream:`, error);\n      return {\n        success: false, \n        error: error instanceof Error ? error : new Error(String(error))\n      };\n    }\n  }\n\n  /**\n   * Track a new execution task for a kernel\n   * @param kernelId Kernel ID\n   * @param code Optional code being executed for metadata\n   * @returns Unique execution ID\n   * @private\n   */\n  private trackExecution(kernelId: string, code?: string): string {\n    // Create a unique execution ID\n    const executionId = `exec-${crypto.randomUUID()}`;\n    const startTime = Date.now();\n    \n    // Reset interrupt buffer for worker kernels before each new execution\n    // This ensures the kernel can be interrupted multiple times\n    const instance = this.kernels.get(kernelId);\n    if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n      const interruptBuffer = this.interruptBuffers.get(kernelId)!;\n      // Reset buffer to 0 (no interrupt signal) to ensure clean state\n      interruptBuffer[0] = 0;\n    }\n    \n    // Get or create the set of ongoing executions for this kernel\n    if (!this.ongoingExecutions.has(kernelId)) {\n      this.ongoingExecutions.set(kernelId, new Set());\n    }\n    \n    // Add this execution to the set\n    this.ongoingExecutions.get(kernelId)!.add(executionId);\n    \n    // Track execution start time\n    if (!this.executionStartTimes.has(kernelId)) {\n      this.executionStartTimes.set(kernelId, new Map());\n    }\n    this.executionStartTimes.get(kernelId)!.set(executionId, startTime);\n    \n    // Track execution metadata\n    if (!this.executionMetadata.has(kernelId)) {\n      this.executionMetadata.set(kernelId, new Map());\n    }\n    \n    // Update activity timestamp\n    this.updateKernelActivity(kernelId);\n    \n    // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n    if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n      // Get or create the map of execution timeouts for this kernel\n      if (!this.executionTimeouts.has(kernelId)) {\n        this.executionTimeouts.set(kernelId, new Map());\n      }\n      \n      // Set a timeout for this execution with enhanced handling\n      const timeoutId = setTimeout(() => {\n        console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n        \n        // Get execution metadata for better error reporting\n        const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n        const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n        \n        // Emit a stalled execution event with enhanced information\n        super.emit('execution_stalled', {\n          kernelId,\n          executionId,\n          maxExecutionTime: instance.options.maxExecutionTime,\n          actualRuntime,\n          code: metadata?.code || code,\n          startTime: metadata?.startTime || startTime\n        });\n        \n        // Auto-handle stuck execution if configured\n        this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n      }, instance.options.maxExecutionTime);\n      \n      // Store the timeout ID\n      this.executionTimeouts.get(kernelId)!.set(executionId, timeoutId);\n      \n      // Store metadata including timeout ID\n      this.executionMetadata.get(kernelId)!.set(executionId, {\n        startTime,\n        code,\n        timeoutId\n      });\n    } else {\n      // Store metadata without timeout ID\n      this.executionMetadata.get(kernelId)!.set(executionId, {\n        startTime,\n        code\n      });\n    }\n    \n    return executionId;\n  }\n  \n  /**\n   * Complete tracking for an execution\n   * @param kernelId Kernel ID\n   * @param executionId Execution ID\n   * @private\n   */\n  private completeExecution(kernelId: string, executionId: string): void {\n    // Clear any execution timeout\n    if (this.executionTimeouts.has(kernelId)) {\n      const timeouts = this.executionTimeouts.get(kernelId)!;\n      if (timeouts.has(executionId)) {\n        clearTimeout(timeouts.get(executionId));\n        timeouts.delete(executionId);\n      }\n      \n      // Clean up empty maps\n      if (timeouts.size === 0) {\n        this.executionTimeouts.delete(kernelId);\n      }\n    }\n    \n    // Clean up execution start times\n    if (this.executionStartTimes.has(kernelId)) {\n      const startTimes = this.executionStartTimes.get(kernelId)!;\n      startTimes.delete(executionId);\n      \n      // Clean up empty maps\n      if (startTimes.size === 0) {\n        this.executionStartTimes.delete(kernelId);\n      }\n    }\n    \n    // Clean up execution metadata\n    if (this.executionMetadata.has(kernelId)) {\n      const metadata = this.executionMetadata.get(kernelId)!;\n      metadata.delete(executionId);\n      \n      // Clean up empty maps\n      if (metadata.size === 0) {\n        this.executionMetadata.delete(kernelId);\n      }\n    }\n    \n    // Remove from ongoing executions\n    if (this.ongoingExecutions.has(kernelId)) {\n      const executions = this.ongoingExecutions.get(kernelId)!;\n      executions.delete(executionId);\n      \n      // Clean up empty sets\n      if (executions.size === 0) {\n        this.ongoingExecutions.delete(kernelId);\n        \n        // Update activity timestamp for completed execution\n        this.updateKernelActivity(kernelId);\n      }\n    }\n  }\n  \n  /**\n   * Check if a kernel has any ongoing executions\n   * @param kernelId Kernel ID\n   * @returns True if the kernel has ongoing executions\n   * @private\n   */\n  private hasOngoingExecutions(kernelId: string): boolean {\n    return this.ongoingExecutions.has(kernelId) && \n           this.ongoingExecutions.get(kernelId)!.size > 0;\n  }\n  \n  /**\n   * Get the count of ongoing executions for a kernel\n   * @param id Kernel ID\n   * @returns Number of ongoing executions\n   */\n  public getOngoingExecutionCount(id: string): number {\n    if (!this.ongoingExecutions.has(id)) {\n      return 0;\n    }\n    return this.ongoingExecutions.get(id)!.size;\n  }\n  \n  /**\n   * Set up an inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @param timeout Timeout in milliseconds\n   * @private\n   */\n  private setupInactivityTimeout(id: string, timeout: number): void {\n    // Don't set up a timer if timeout is 0 or negative\n    if (timeout <= 0) {\n      return;\n    }\n    \n    // Always clear any existing timer first\n    this.clearInactivityTimeout(id);\n    \n    // Calculate remaining time based on last activity\n    const lastActivity = this.lastActivityTime.get(id) || Date.now();\n    const elapsed = Date.now() - lastActivity;\n    const remainingTime = Math.max(0, timeout - elapsed);\n    \n    // If no time remaining, destroy immediately\n    if (remainingTime === 0) {\n      // Check if the kernel has ongoing executions before shutting down\n      if (this.hasOngoingExecutions(id)) {\n        // Reset the timer to check again later\n        this.setupInactivityTimeout(id, timeout);\n        return;\n      }\n      \n      // Destroy immediately\n      this.destroyKernel(id).catch(error => {\n        console.error(`Error destroying inactive kernel ${id}:`, error);\n      });\n      return;\n    }\n    \n    // Create a timer to destroy the kernel after the remaining timeout\n    const timer = setTimeout(() => {\n      // Check if the kernel has ongoing executions before shutting down\n      if (this.hasOngoingExecutions(id)) {\n        // Reset the timer to check again later\n        this.setupInactivityTimeout(id, timeout);\n        return;\n      }\n      \n      this.destroyKernel(id).catch(error => {\n        console.error(`Error destroying inactive kernel ${id}:`, error);\n      });\n    }, remainingTime);\n    \n    // Store the timer ID\n    this.inactivityTimers.set(id, timer);\n  }\n  \n  /**\n   * Clear any existing inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @private\n   */\n  private clearInactivityTimeout(id: string): void {\n    if (this.inactivityTimers.has(id)) {\n      const timerId = this.inactivityTimers.get(id);\n      clearTimeout(timerId);\n      this.inactivityTimers.delete(id);\n    }\n  }\n\n  /**\n   * Update activity timestamp for a kernel and reset inactivity timer if present\n   * @param id Kernel ID\n   * @private\n   */\n  private updateKernelActivity(id: string): void {\n    // Update the last activity time\n    this.lastActivityTime.set(id, Date.now());\n    \n    // Get the kernel options\n    const instance = this.kernels.get(id);\n    if (!instance) return;\n    \n    const timeout = instance.options.inactivityTimeout;\n    \n    // Reset the inactivity timer if timeout is enabled (greater than 0)\n    if (timeout && timeout > 0) {\n      this.setupInactivityTimeout(id, timeout);\n    }\n  }\n\n  /**\n   * Get the last activity time for a kernel\n   * @param id Kernel ID\n   * @returns Last activity time in milliseconds since epoch, or undefined if not found\n   */\n  public getLastActivityTime(id: string): number | undefined {\n    return this.lastActivityTime.get(id);\n  }\n\n  /**\n   * Get the inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @returns Inactivity timeout in milliseconds, or undefined if not set\n   */\n  public getInactivityTimeout(id: string): number | undefined {\n    const instance = this.kernels.get(id);\n    if (!instance) return undefined;\n    \n    return instance.options.inactivityTimeout;\n  }\n\n  /**\n   * Set or update the inactivity timeout for a kernel\n   * @param id Kernel ID\n   * @param timeout Timeout in milliseconds, or 0 to disable\n   * @returns True if the timeout was set, false if the kernel was not found\n   */\n  public setInactivityTimeout(id: string, timeout: number): boolean {\n    const instance = this.kernels.get(id);\n    if (!instance) return false;\n    \n    // Update the timeout in the options\n    instance.options.inactivityTimeout = timeout;\n    \n    // Clear any existing timer\n    this.clearInactivityTimeout(id);\n    \n    // If timeout is greater than 0, set up a new timer\n    if (timeout > 0) {\n      this.setupInactivityTimeout(id, timeout);\n    }\n    \n    return true;\n  }\n\n  /**\n   * Get time until auto-shutdown for a kernel\n   * @param id Kernel ID\n   * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n   */\n  public getTimeUntilShutdown(id: string): number | undefined {\n    const instance = this.kernels.get(id);\n    if (!instance) return undefined;\n    \n    const timeout = instance.options.inactivityTimeout;\n    if (!timeout || timeout <= 0) return undefined;\n    \n    const lastActivity = this.lastActivityTime.get(id);\n    if (!lastActivity) return undefined;\n    \n    const elapsedTime = Date.now() - lastActivity;\n    const remainingTime = timeout - elapsedTime;\n    \n    return Math.max(0, remainingTime);\n  }\n\n  /**\n   * Get the map of inactivity timers (for debugging/testing only)\n   * @returns Object with kernel IDs as keys and timer IDs as values\n   */\n  public getInactivityTimers(): Record<string, number> {\n    // Convert Map to Object for easier inspection\n    const timers: Record<string, number> = {};\n    this.inactivityTimers.forEach((value, key) => {\n      timers[key] = value;\n    });\n    return timers;\n  }\n\n  /**\n   * Set up a handler for stalled executions\n   * @param id Kernel ID\n   * @private\n   */\n  private setupStalledExecutionHandler(id: string): void {\n    // Listen for stalled execution events\n    super.on(KernelEvents.EXECUTION_STALLED, (event: { kernelId: string, executionId: string, maxExecutionTime: number }) => {\n      if (event.kernelId === id) {\n        console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n        \n        // Emit an event for clients to handle\n        const instance = this.kernels.get(id);\n        if (instance) {\n          super.emit(KernelEvents.EXECUTE_ERROR, {\n            kernelId: id,\n            data: {\n              ename: \"ExecutionStalledError\",\n              evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n              traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n            }\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Force terminate a potentially stuck kernel\n   * @param id Kernel ID\n   * @param reason Optional reason for termination\n   * @returns Promise resolving to true if the kernel was terminated\n   */\n  public async forceTerminateKernel(id: string, reason = \"Force terminated due to stalled execution\"): Promise<boolean> {\n    const instance = this.kernels.get(id);\n    \n    if (!instance) {\n      return false;\n    }\n    \n    try {\n      // Log the forced termination\n      console.warn(`Force terminating kernel ${id}: ${reason}`);\n      \n      // Emit an error event to notify clients\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: id,\n        data: {\n          ename: \"KernelForcedTermination\",\n          evalue: reason,\n          traceback: [\"Kernel was forcefully terminated by the system.\"]\n        }\n      });\n      \n      // Destroy the kernel\n      await this.destroyKernel(id);\n      return true;\n    } catch (error) {\n      console.error(`Error during forced termination of kernel ${id}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get information about ongoing executions for a kernel\n   * @param id Kernel ID\n   * @returns Information about ongoing executions with accurate timing\n   */\n  public getExecutionInfo(id: string): { \n    count: number; \n    isStuck: boolean; \n    executionIds: string[];\n    longestRunningTime?: number;\n    executions: Array<{\n      id: string;\n      startTime: number;\n      runtime: number;\n      code?: string;\n      isStuck: boolean;\n    }>;\n  } {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      return { count: 0, isStuck: false, executionIds: [], executions: [] };\n    }\n    \n    // Handle partially initialized kernels where options may not be fully set\n    if (!instance.options) {\n      return { count: 0, isStuck: false, executionIds: [], executions: [] };\n    }\n    \n    const executionIds = this.ongoingExecutions.get(id) \n      ? Array.from(this.ongoingExecutions.get(id)!)\n      : [];\n    \n    const count = executionIds.length;\n    const currentTime = Date.now();\n    const maxExecutionTime = instance.options.maxExecutionTime;\n    \n    // Build detailed execution information\n    const executions: Array<{\n      id: string;\n      startTime: number;\n      runtime: number;\n      code?: string;\n      isStuck: boolean;\n    }> = [];\n    \n    let longestRunningTime: number | undefined = undefined;\n    let anyStuck = false;\n    \n    // Get execution start times and metadata\n    const startTimes = this.executionStartTimes.get(id);\n    const metadata = this.executionMetadata.get(id);\n    \n    for (const executionId of executionIds) {\n      const startTime = startTimes?.get(executionId);\n      const execMetadata = metadata?.get(executionId);\n      \n      if (startTime !== undefined) {\n        const runtime = currentTime - startTime;\n        const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n        \n        executions.push({\n          id: executionId,\n          startTime,\n          runtime,\n          code: execMetadata?.code,\n          isStuck\n        });\n        \n        // Track longest running time\n        if (longestRunningTime === undefined || runtime > longestRunningTime) {\n          longestRunningTime = runtime;\n        }\n        \n        // Track if any execution is stuck\n        if (isStuck) {\n          anyStuck = true;\n        }\n      } else {\n        // Fallback for executions without start time tracking\n        console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n        executions.push({\n          id: executionId,\n          startTime: 0,\n          runtime: 0,\n          code: execMetadata?.code,\n          isStuck: false\n        });\n      }\n    }\n    \n    // Sort executions by start time (oldest first)\n    executions.sort((a, b) => a.startTime - b.startTime);\n    \n    return {\n      count,\n      isStuck: anyStuck,\n      executionIds,\n      longestRunningTime,\n      executions\n    };\n  }\n\n  /**\n   * Execute Python code in a kernel\n   * Uses executeStream to collect all outputs and return them\n   * @param kernelId ID of the kernel to use\n   * @param code Python code to execute\n   * @param parent Optional parent message header\n   * @returns Promise resolving to execution result with collected outputs\n   */\n  public async execute(\n    kernelId: string,\n    code: string,\n    parent: any = {}\n  ): Promise<{ success: boolean, outputs?: any, error?: Error, ename?: string, evalue?: string, traceback?: any }> {\n    const instance = this.getKernel(kernelId);\n    \n    if (!instance) {\n      throw new Error(`Kernel with ID ${kernelId} not found`);\n    }\n    return await instance.kernel.execute(code, parent);\n  }\n\n  /**\n   * Check if a kernel type is allowed\n   * @param mode Kernel mode\n   * @param language Kernel language\n   * @returns True if the kernel type is allowed\n   * @private\n   */\n  private isKernelTypeAllowed(mode: KernelMode, language: KernelLanguage): boolean {\n    return this.allowedKernelTypes.some(type => \n      type.mode === mode && type.language === language\n    );\n  }\n  \n  /**\n   * Get the list of allowed kernel types\n   * @returns Array of allowed kernel type configurations\n   */\n  public getAllowedKernelTypes(): Array<{\n    mode: KernelMode;\n    language: KernelLanguage;\n  }> {\n    return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n  }\n\n  /**\n   * Ping a kernel to reset its activity timer and extend the deadline\n   * @param id Kernel ID\n   * @returns True if the kernel was pinged successfully, false if not found\n   */\n  public pingKernel(id: string): boolean {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      return false;\n    }\n    \n    // Update kernel activity (this will reset the inactivity timer)\n    this.updateKernelActivity(id);\n    \n    return true;\n  }\n\n  /**\n   * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n   * @param id Kernel ID\n   * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n   */\n  public async restartKernel(id: string): Promise<boolean> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      console.warn(`Cannot restart kernel ${id}: kernel not found`);\n      return false;\n    }\n    \n    try {\n      // Store the current configuration\n      const currentConfig = {\n        mode: instance.mode,\n        language: instance.language,\n        options: { ...instance.options }\n      };\n      \n      // Extract namespace from ID if present\n      let namespace: string | undefined;\n      let baseId: string;\n      \n      if (id.includes(':')) {\n        const parts = id.split(':');\n        namespace = parts[0];\n        baseId = parts[1];\n      } else {\n        baseId = id;\n      }\n      \n      // Destroy the existing kernel\n      await this.destroyKernel(id);\n      \n      // Create a new kernel with the same configuration\n      const restartOptions: IManagerKernelOptions = {\n        id: baseId,\n        mode: currentConfig.mode,\n        lang: currentConfig.language,\n        namespace,\n        deno: currentConfig.options.deno,\n        filesystem: currentConfig.options.filesystem,\n        inactivityTimeout: currentConfig.options.inactivityTimeout,\n        maxExecutionTime: currentConfig.options.maxExecutionTime\n      };\n      \n      // Create the new kernel\n      const newKernelId = await this.createKernel(restartOptions);\n      \n      // Verify the new kernel has the same ID\n      if (newKernelId !== id) {\n        console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n        return false;\n      }\n      \n      return true;\n      \n    } catch (error) {\n      console.error(`Error restarting kernel ${id}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Interrupt a running kernel execution\n   * @param id Kernel ID\n   * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n   */\n  public async interruptKernel(id: string): Promise<boolean> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n      return false;\n    }\n    \n    try {\n      if (instance.mode === KernelMode.WORKER && instance.worker) {\n        // For worker kernels, use SharedArrayBuffer interrupt method\n        return await this.interruptWorkerKernel(id, instance);\n      } else {\n        // For main thread kernels, try to interrupt (will throw error if not supported)\n        return await this.interruptMainThreadKernel(id, instance);\n      }\n    } catch (error) {\n      console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n      return false;\n    }\n  }\n  \n  /**\n   * Interrupt a main thread kernel\n   * @param id Kernel ID\n   * @param instance Kernel instance\n   * @returns Promise resolving to interrupt success\n   * @private\n   */\n  private async interruptMainThreadKernel(id: string, instance: IKernelInstance): Promise<boolean> {\n    // Main thread kernels don't support proper interruption like worker kernels do\n    // Even if they have an interrupt method, it's limited and unreliable\n    throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n  }\n  \n  /**\n   * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n   * @param id Kernel ID\n   * @param instance Kernel instance\n   * @returns Promise resolving to interrupt success\n   * @private\n   */\n  private async interruptWorkerKernel(id: string, instance: IKernelInstance): Promise<boolean> {\n    try {\n      const worker = instance.worker;\n      if (!worker) {\n        console.error(`Worker not found for kernel ${id}`);\n        return false;\n      }\n      \n      // If interruption mode is 'kernel-interrupt', use fallback directly\n      if (this.interruptionMode === 'kernel-interrupt') {\n        return await this.interruptWorkerKernelFallback(id, worker);\n      }\n      \n      // Check if we already have an interrupt buffer for this kernel\n      let interruptBuffer = this.interruptBuffers.get(id);\n      \n      if (!interruptBuffer) {\n        // Create a new SharedArrayBuffer for interrupt control\n        try {\n          // Try to create SharedArrayBuffer (requires specific security headers)\n          const sharedBuffer = new SharedArrayBuffer(1);\n          interruptBuffer = new Uint8Array(sharedBuffer);\n          \n          // Initialize buffer to 0 (no interrupt signal)\n          interruptBuffer[0] = 0;\n          \n          // Store the buffer for future use\n          this.interruptBuffers.set(id, interruptBuffer);\n          \n          // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n          worker.postMessage({\n            type: \"SET_INTERRUPT_BUFFER\",\n            buffer: interruptBuffer\n          });\n          \n          // Wait for the worker to confirm buffer setup\n          await new Promise<void>((resolve, reject) => {\n            const timeout = setTimeout(() => {\n              reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n            }, 2000);\n            \n            const handler = (event: MessageEvent) => {\n              if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                worker.removeEventListener(\"message\", handler);\n                clearTimeout(timeout);\n                resolve();\n              }\n            };\n            \n            worker.addEventListener(\"message\", handler);\n          });\n          \n          console.log(`Interrupt buffer set up for kernel ${id}`);\n          \n        } catch (error) {\n          // Handle based on interruption mode\n          if (this.interruptionMode === 'shared-array-buffer') {\n            // If explicitly set to shared-array-buffer, this is an error\n            console.error(`❌ Cannot create SharedArrayBuffer for interrupt handling in kernel ${id}`);\n            throw new Error(`SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })`);\n          } else {\n            // Auto mode: fall back to kernel.interrupt()\n            console.info(`ℹ️ Using message-based interrupt for kernel ${id} (SharedArrayBuffer not available)`);\n            \n            // Fallback: use message-based interrupt\n            return await this.interruptWorkerKernelFallback(id, worker);\n          }\n        }\n      }\n      \n      // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n      console.log(`Setting interrupt signal for kernel ${id}...`);\n      interruptBuffer[0] = 2;\n      \n      // Wait for Pyodide to process the interrupt\n      // Pyodide will reset the buffer to 0 when it processes the interrupt\n      let attempts = 0;\n      const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n      \n      while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        attempts++;\n      }\n      \n      if (interruptBuffer[0] === 0) {\n        console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n        return true;\n      } else {\n        console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n        // Still return true as we set the signal - the interrupt may be processed later\n        return true;\n      }\n      \n    } catch (error) {\n      console.error(`Error interrupting worker kernel ${id}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n   * @param id Kernel ID\n   * @param worker Worker instance\n   * @returns Promise resolving to interrupt success\n   * @private\n   */\n  private async interruptWorkerKernelFallback(id: string, worker: Worker): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      // Set up a listener for the interrupt response\n      const responseHandler = (event: MessageEvent) => {\n        if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n          worker.removeEventListener(\"message\", responseHandler);\n          const success = event.data.data?.success || false;\n          resolve(success);\n        }\n      };\n      \n      // Listen for the response\n      worker.addEventListener(\"message\", responseHandler);\n      \n      // Send the interrupt message\n      worker.postMessage({\n        type: \"INTERRUPT_KERNEL\"\n      });\n      \n      // Set a timeout in case we don't get a response\n      setTimeout(() => {\n        worker.removeEventListener(\"message\", responseHandler);\n        console.warn(`⏱️ Interrupt request timed out for kernel ${id} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`);\n        resolve(false);\n      }, 5000); // 5 second timeout\n    });\n  }\n\n  /**\n   * Handle a stuck execution with configurable strategies\n   * @param kernelId Kernel ID\n   * @param executionId Execution ID that's stuck\n   * @param actualRuntime How long the execution has been running\n   * @param code The code that was being executed\n   * @private\n   */\n  private async handleStuckExecution(kernelId: string, executionId: string, actualRuntime: number, code?: string): Promise<void> {\n    const instance = this.kernels.get(kernelId);\n    if (!instance) {\n      return;\n    }\n    \n    console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n    \n    // Strategy 1: Try to interrupt the kernel first\n    const interruptSuccess = await this.interruptKernel(kernelId);\n    \n    if (interruptSuccess) {\n      console.log(`Successfully interrupted kernel ${kernelId}`);\n      \n      // Emit an execution error to notify clients\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: kernelId,\n        data: {\n          ename: \"ExecutionInterrupted\",\n          evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n          traceback: [\n            `Execution was automatically interrupted due to timeout.`,\n            `Runtime: ${actualRuntime}ms`,\n            `Max allowed: ${instance.options.maxExecutionTime}ms`,\n            code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n          ]\n        }\n      });\n      \n      return;\n    }\n    \n    // Strategy 2: If interrupt failed, try restarting the kernel\n    console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n    const restartSuccess = await this.restartKernel(kernelId);\n    \n    if (restartSuccess) {\n      console.log(`Successfully restarted kernel ${kernelId}`);\n      \n      // Emit a restart notification\n      super.emit(KernelEvents.EXECUTE_ERROR, {\n        kernelId: kernelId,\n        data: {\n          ename: \"KernelRestarted\",\n          evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n          traceback: [\n            `Kernel was automatically restarted due to stuck execution.`,\n            `Runtime: ${actualRuntime}ms`,\n            `Max allowed: ${instance.options.maxExecutionTime}ms`,\n            `Interrupt attempt failed, kernel was restarted instead.`,\n            code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n          ]\n        }\n      });\n      \n      return;\n    }\n    \n    // Strategy 3: If restart failed, force terminate the kernel\n    console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n    const terminateSuccess = await this.forceTerminateKernel(\n      kernelId, \n      `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`\n    );\n    \n    if (terminateSuccess) {\n      console.log(`Successfully terminated kernel ${kernelId}`);\n    } else {\n      console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n      \n      // Emit a critical error\n      super.emit('kernel_unrecoverable', {\n        kernelId: kernelId,\n        executionId: executionId,\n        actualRuntime: actualRuntime,\n        code: code,\n        message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n      });\n    }\n  }\n\n  /**\n   * Get detailed information about stuck executions across all kernels\n   * @returns Array of stuck execution details\n   */\n  public getStuckExecutions(): Array<{\n    kernelId: string;\n    executionId: string;\n    startTime: number;\n    runtime: number;\n    maxAllowed: number;\n    code?: string;\n    kernelMode: KernelMode;\n    kernelLanguage: KernelLanguage;\n  }> {\n    const stuckExecutions: Array<{\n      kernelId: string;\n      executionId: string;\n      startTime: number;\n      runtime: number;\n      maxAllowed: number;\n      code?: string;\n      kernelMode: KernelMode;\n      kernelLanguage: KernelLanguage;\n    }> = [];\n    \n    const currentTime = Date.now();\n    \n    for (const [kernelId, instance] of this.kernels.entries()) {\n      // Skip pool kernels\n      if (kernelId.startsWith(\"pool-\")) continue;\n      \n      // Skip kernels without maxExecutionTime configured\n      if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n        continue;\n      }\n      \n      const maxExecutionTime = instance.options.maxExecutionTime;\n      const startTimes = this.executionStartTimes.get(kernelId);\n      const metadata = this.executionMetadata.get(kernelId);\n      const ongoingExecs = this.ongoingExecutions.get(kernelId);\n      \n      if (!ongoingExecs || ongoingExecs.size === 0) {\n        continue;\n      }\n      \n      for (const executionId of ongoingExecs) {\n        const startTime = startTimes?.get(executionId);\n        if (startTime === undefined) continue;\n        \n        const runtime = currentTime - startTime;\n        \n        // Check if this execution is stuck\n        if (runtime > maxExecutionTime) {\n          const execMetadata = metadata?.get(executionId);\n          \n          stuckExecutions.push({\n            kernelId,\n            executionId,\n            startTime,\n            runtime,\n            maxAllowed: maxExecutionTime,\n            code: execMetadata?.code,\n            kernelMode: instance.mode,\n            kernelLanguage: instance.language\n          });\n        }\n      }\n    }\n    \n    // Sort by runtime (longest running first)\n    stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n    \n    return stuckExecutions;\n  }\n\n  /**\n   * Force interrupt all stuck executions across all kernels\n   * @returns Promise resolving to array of intervention results\n   */\n  public async handleAllStuckExecutions(): Promise<Array<{\n    kernelId: string;\n    executionId: string;\n    action: 'interrupted' | 'restarted' | 'terminated' | 'failed';\n    success: boolean;\n    error?: string;\n  }>> {\n    const stuckExecutions = this.getStuckExecutions();\n    const results: Array<{\n      kernelId: string;\n      executionId: string;\n      action: 'interrupted' | 'restarted' | 'terminated' | 'failed';\n      success: boolean;\n      error?: string;\n    }> = [];\n    \n    console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n    \n    // Group by kernel to avoid multiple interventions on the same kernel\n    const kernelGroups = new Map<string, typeof stuckExecutions>();\n    for (const exec of stuckExecutions) {\n      if (!kernelGroups.has(exec.kernelId)) {\n        kernelGroups.set(exec.kernelId, []);\n      }\n      kernelGroups.get(exec.kernelId)!.push(exec);\n    }\n    \n    // Handle each kernel's stuck executions\n    for (const [kernelId, executions] of kernelGroups) {\n      try {\n        // Pick the longest running execution as the primary one\n        const primaryExec = executions[0]; // Already sorted by runtime desc\n        \n        console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n        \n        // Use the automated handling system\n        await this.handleStuckExecution(\n          kernelId, \n          primaryExec.executionId, \n          primaryExec.runtime, \n          primaryExec.code\n        );\n        \n        // Mark all executions for this kernel as handled\n        for (const exec of executions) {\n          results.push({\n            kernelId: exec.kernelId,\n            executionId: exec.executionId,\n            action: 'interrupted', // We don't know the exact action, but it was handled\n            success: true\n          });\n        }\n        \n      } catch (error) {\n        console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n        \n        // Mark all executions for this kernel as failed\n        for (const exec of executions) {\n          results.push({\n            kernelId: exec.kernelId,\n            executionId: exec.executionId,\n            action: 'failed',\n            success: false,\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Set up interrupt buffer for a worker kernel during creation\n   * @param id Kernel ID\n   * @param worker Worker instance\n   * @private\n   */\n  private async setupWorkerInterruptBuffer(id: string, worker: Worker): Promise<void> {\n    // Skip SharedArrayBuffer setup if mode is 'kernel-interrupt'\n    if (this.interruptionMode === 'kernel-interrupt') {\n      console.log(`Skipping SharedArrayBuffer setup for kernel ${id} - using kernel.interrupt() mode`);\n      return;\n    }\n    \n    try {\n      // Python kernels support interrupt buffers\n      \n      // For Python kernels, create actual SharedArrayBuffer\n      const sharedBuffer = new SharedArrayBuffer(1);\n      const interruptBuffer = new Uint8Array(sharedBuffer);\n      \n      // Initialize buffer to 0 (no interrupt signal)\n      interruptBuffer[0] = 0;\n      \n      // Store the buffer for future use\n      this.interruptBuffers.set(id, interruptBuffer);\n      \n      // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n      worker.postMessage({\n        type: \"SET_INTERRUPT_BUFFER\",\n        buffer: interruptBuffer\n      });\n      \n      // Wait for the worker to confirm buffer setup\n      await new Promise<void>((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n        }, 5000);\n        \n        const handler = (event: MessageEvent) => {\n          if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n            worker.removeEventListener(\"message\", handler);\n            clearTimeout(timeout);\n            resolve();\n          }\n        };\n        \n        worker.addEventListener(\"message\", handler);\n      });\n      \n    } catch (error) {\n      // Handle based on interruption mode\n      if (this.interruptionMode === 'shared-array-buffer') {\n        // If explicitly set to shared-array-buffer, this is an error\n        console.error(`❌ SharedArrayBuffer required but not available for kernel ${id}`);\n        throw new Error(`SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.`);\n      } else {\n        // Auto mode: fall back to kernel.interrupt()\n        console.info(`ℹ️ SharedArrayBuffer not available for kernel ${id}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`);\n        // Don't throw - kernel can still work without interrupt buffer\n      }\n    }\n  }\n\n  /**\n   * Get information about mounted filesystems for a specific kernel\n   * @param id Kernel ID\n   * @returns Promise resolving to array of mounted filesystem info\n   */\n  public async getMountedFileSystems(id: string): Promise<Array<{\n    mountPath: string;\n    permission: 'read' | 'readwrite';\n    canSync: boolean;\n  }>> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      throw new Error(`Kernel ${id} not found`);\n    }\n\n    try {\n      if (typeof instance.kernel.getMountedFileSystems === 'function') {\n        return instance.kernel.getMountedFileSystems();\n      } else {\n        console.warn(`Kernel ${id} does not support getMountedFileSystems method`);\n        return [];\n      }\n    } catch (error) {\n      console.error(`Error getting mounted filesystems for kernel ${id}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Manually sync a specific mounted filesystem for a kernel\n   * @param id Kernel ID\n   * @param mountPath The path of the mounted filesystem to sync\n   * @returns Promise resolving to sync result\n   */\n  public async syncFileSystem(id: string, mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      throw new Error(`Kernel ${id} not found`);\n    }\n\n    try {\n      if (typeof instance.kernel.syncFileSystem === 'function') {\n        return await instance.kernel.syncFileSystem(mountPath);\n      } else {\n        console.warn(`Kernel ${id} does not support syncFileSystem method`);\n        return {\n          success: false,\n          error: 'syncFileSystem is not supported by this kernel'\n        };\n      }\n    } catch (error) {\n      console.error(`Error syncing filesystem for kernel ${id}:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Upgrade a mounted filesystem from read-only to read-write permission\n   * @param id Kernel ID\n   * @param mountPath The path of the mounted filesystem to upgrade\n   * @returns Promise resolving to upgrade result\n   */\n  public async upgradeFileSystemPermission(id: string, mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const instance = this.kernels.get(id);\n    if (!instance) {\n      throw new Error(`Kernel ${id} not found`);\n    }\n\n    try {\n      if (typeof instance.kernel.upgradeFileSystemPermission === 'function') {\n        return await instance.kernel.upgradeFileSystemPermission(mountPath);\n      } else {\n        console.warn(`Kernel ${id} does not support upgradeFileSystemPermission method`);\n        return {\n          success: false,\n          error: 'upgradeFileSystemPermission is not supported by this kernel'\n        };\n      }\n    } catch (error) {\n      console.error(`Error upgrading filesystem permission for kernel ${id}:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n}","// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n  private events: { [key: string]: Function[] } = {};\n\n  on(eventName: string, listener: Function) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(listener);\n  }\n\n  off(eventName: string, listener: Function) {\n    if (!this.events[eventName]) return;\n    const index = this.events[eventName].indexOf(listener);\n    if (index > -1) {\n      this.events[eventName].splice(index, 1);\n    }\n  }\n\n  emit(eventName: string, ...args: any[]) {\n    if (!this.events[eventName]) return;\n    this.events[eventName].forEach(listener => listener(...args));\n  }\n\n  setMaxListeners(n: number) {\n    // No-op for browser compatibility\n  }\n}\n\n// @ts-ignore Importing from npm\nimport { loadPyodide } from \"./pyodide-loader\";\n\n// Import types and enums\nimport { KernelEvents, IEventData, IMessage, IKernel, IKernelOptions, IFileSystemMountOptions, IKernelExecuteOptions, IEventEmitter } from \"./types\";\n\n// Import PyPI URLs\nimport {\n  pipliteWheelUrl,\n  pyodide_kernelWheelUrl,\n  ipykernelWheelUrl,\n  allJSONUrl,\n  widgetsnbextensionWheelUrl,\n  widgetsnbextensionWheelUrl1\n} from './_pypi';\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\nexport { KernelEvents } from \"./types\";\nexport type {\n  IKernel,\n  IKernelOptions,\n  IFileSystemMountOptions,\n  IKernelExecuteOptions,\n  IMessage,\n  IEventData,\n  IEventEmitter,\n  INativeFSHandle\n} from \"./types\";\n\nexport { KernelMode, KernelLanguage } from \"./manager\";\n\n\n\n\nexport class Kernel extends EventEmitter implements IKernel {\n  private pyodide: any;\n  private initialized = false;\n  private initPromise: Promise<void> | null = null;\n  \n  // FileSystem options\n  private filesystemOptions: IFileSystemMountOptions = {\n    enabled: false,\n    root: \".\",\n    mountPoint: \"/home/pyodide\"\n  };\n  \n  // Kernel options\n  private lockFileURL?: string;\n  \n  // Kernel components\n  private _kernel: any;\n  private _interpreter: any;\n  private _stdout_stream: any;\n  private _stderr_stream: any;\n  \n  // Input handling\n  private _resolveInputReply: ((value: any) => void) | null = null;\n  \n  // Execution state\n  private _parent_header: any = {};\n  private executionCount = 0;\n  private _status: \"active\" | \"busy\" | \"unknown\" = \"unknown\";\n  \n  // Interrupt handling\n  private _interruptBuffer: Uint8Array | null = null;\n  private _interruptSupported = false;\n  \n  // Environment variables\n  private environmentVariables: Record<string, string> = {};\n\n  // Native filesystem handles\n  private nativeFsHandles: Map<string, { \n    syncfs: () => Promise<void>; \n    dirHandle: FileSystemDirectoryHandle;\n    permission: 'read' | 'readwrite';\n    nativefs: any;\n  }> = new Map();\n  private autoSyncFs: boolean = false;\n\n  // Unique identifier for this kernel instance\n  private readonly kernelId: string;\n\n  constructor() {\n    super();\n    super.setMaxListeners(20);\n    // Generate a unique ID for this kernel instance\n    this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n  }\n\n  // Async method for kernel status\n  async getStatus(): Promise<\"active\" | \"busy\" | \"unknown\"> {\n    return this._status;\n  }\n\n  /**\n   * Initialize the kernel with maximum performance optimizations\n   * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n   */\n  public async initialize(options?: IKernelOptions): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n    \n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    // Set filesystem options if provided\n    if (options?.filesystem) {\n      this.filesystemOptions = {\n        ...this.filesystemOptions,\n        ...options.filesystem\n      };\n    }\n\n    // Set environment variables if provided\n    if (options?.env) {\n      this.environmentVariables = { ...options.env };\n    }\n\n    // Set lockFileURL if provided\n    if (options?.lockFileURL) {\n      this.lockFileURL = options.lockFileURL;\n    }\n\n    // Set autoSyncFs if provided\n    if (options?.autoSyncFs !== undefined) {\n      this.autoSyncFs = options.autoSyncFs;\n    }\n\n    this.initPromise = this._initializeInternal();\n    return this.initPromise;\n  }\n  \n  /**\n   * Initialize the kernel with maximum performance optimizations\n   * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n   */\n  private async _initializeInternal(): Promise<void> {\n    const startTime = Date.now();\n    console.log(\"🚀 Starting optimized kernel initialization...\");\n    \n    try {\n      // Load Pyodide from CDN\n      const pyodideStartTime = Date.now();\n      \n      // Configure pyodide options\n      const pyodideConfig: any = {};\n      if (this.lockFileURL) {\n        pyodideConfig.lockFileURL = this.lockFileURL;\n        console.log(`🔒 Using lockFileURL: ${this.lockFileURL}`);\n      }\n      \n      // Use our CDN loader - it will automatically handle main thread vs worker\n      this.pyodide = await loadPyodide(pyodideConfig);\n      const pyodideTime = Date.now() - pyodideStartTime;\n      console.log(`✅ Pyodide loaded in ${pyodideTime}ms`);\n      \n      // Initialize core components in parallel\n      if (this.lockFileURL) {\n        // When using lockFileURL, packages are pre-installed, skip package installation\n        console.log(\"🚀 Using lock file - skipping package installation\");\n        const [,] = await Promise.all([\n          // 1. FileSystem mounting (if enabled)\n          this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n          // 2. Environment variables setup\n          this.setEnvironmentVariables()\n        ]);\n        \n        // Initialize globals directly (packages are already available)\n        await this.initGlobals();\n      } else {\n        // Standard initialization with package installation\n        const [, ,] = await Promise.all([\n          // 1. FileSystem mounting (if enabled)\n          this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n          // 2. Package manager initialization\n          this.initPackageManager(),\n          // 3. Environment variables setup\n          this.setEnvironmentVariables()\n        ]);\n        \n        // Install packages and initialize globals\n        await this.initKernel();\n        await this.initGlobals();\n      }\n      \n      const totalTime = Date.now() - startTime;\n      console.log(`🎯 KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n      console.log(`⚡ Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n      \n      // Mark as initialized\n      this.initialized = true;\n      this._status = \"active\";\n      console.log(\"🟢 Kernel is now ACTIVE and ready for execution!\");\n      \n    } catch (error) {\n      console.error(\"❌ Kernel initialization failed:\", error);\n      this._status = \"unknown\";\n      throw error;\n    }\n  }\n  \n  /**\n   * Mount the local filesystem to the Pyodide environment\n   */\n  private async mountFileSystem(): Promise<void> {\n    try {\n      console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n      \n      // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n      // Simple and direct mounting of the filesystem\n      await this.pyodide.FS.mount(\n        this.pyodide.FS.filesystems.NODEFS,\n        { root: this.filesystemOptions.root || \".\" },\n        this.filesystemOptions.mountPoint || \"/home/pyodide\"\n      );\n      \n      console.log(\"FileSystem mounted successfully\");\n      \n      // Verify the mount by listing the directory\n      try {\n        const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n        console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n      } catch (error) {\n        console.error(`Error listing mounted directory: ${error}`);\n      }\n    } catch (error) {\n      console.error(\"Error mounting filesystem:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize the Pyodide package manager with optimized wheel loading\n   * OPTIMIZED: Smart caching and parallel wheel installation\n   */\n  private async initPackageManager(): Promise<void> {\n    const startTime = Date.now();\n    console.log(\"⚡ Initializing optimized package manager...\");\n    \n    try {\n      // Load micropip and packaging in parallel\n      console.log(\"📦 Loading micropip, packaging...\");\n      await this.pyodide.loadPackage(['micropip', 'packaging']);\n      console.log(\"✅ Loaded micropip, packaging\");\n      \n      // Get the base URL - use window.location for browser or fallback for worker\n      let baseUrl: string;\n      if (typeof window !== 'undefined' && window.location) {\n        // In main thread - use window.location\n        baseUrl = new URL(\".\", window.location.href).href;\n      } else if (typeof self !== 'undefined' && self.location) {\n        // In web worker - use self.location\n        baseUrl = new URL(\".\", self.location.href).href;\n      } else {\n        // Fallback - assume current origin\n        baseUrl = \"/\";\n      }\n      \n      const allJsonPath = new URL(allJSONUrl, baseUrl).href;\n      \n      // Prepare all wheel URLs for parallel loading\n      const wheelFiles = [\n        new URL(pipliteWheelUrl, baseUrl).href,\n        new URL(pyodide_kernelWheelUrl, baseUrl).href,\n        new URL(ipykernelWheelUrl, baseUrl).href,\n        new URL(widgetsnbextensionWheelUrl, baseUrl).href,\n        new URL(widgetsnbextensionWheelUrl1, baseUrl).href,\n      ];\n      \n      console.log(`🚀 Installing ${wheelFiles.length} wheel packages in parallel...`);\n      \n      // Install all wheel packages in parallel for maximum speed\n      const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n        const wheelStartTime = Date.now();\n        try {\n          await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\"✅ Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n          const wheelTime = Date.now() - wheelStartTime;\n          console.log(`⚡ Wheel ${index + 1} installed in ${wheelTime}ms`);\n          return { index, success: true, time: wheelTime };\n        } catch (error) {\n          const wheelTime = Date.now() - wheelStartTime;\n          console.warn(`⚠️ Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n          return { index, success: false, time: wheelTime, error };\n        }\n      });\n      \n      // Wait for all wheel installations\n      const wheelResults = await Promise.all(wheelPromises);\n      const successful = wheelResults.filter(r => r.success);\n      const failed = wheelResults.filter(r => !r.success);\n      \n      console.log(`📊 Wheels: ${successful.length}/${wheelFiles.length} successful`);\n      if (failed.length > 0) {\n        console.warn(`⚠️ Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n      }\n      \n      // Set up piplite configuration with performance optimizations (if available)\n      try {\n        await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\"📋 Package index configured\")\n    except Exception as e:\n        print(f\"⚠️ Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\"⚡ Piplite optimized for performance\")\nexcept ImportError:\n    print(\"⚠️ Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\"⚠️ Piplite setup failed: {e}\")\n`);\n      } catch (error) {\n        console.warn(\"⚠️ Piplite configuration failed, continuing without it:\", error);\n      }\n      \n      const totalTime = Date.now() - startTime;\n      console.log(`🎯 Package manager initialized in ${totalTime}ms`);\n      \n    } catch (error) {\n      console.error(\"❌ Package manager initialization failed:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize the kernel with required Python packages\n   * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n   */\n  private async initKernel(): Promise<void> {\n    const startTime = Date.now();\n    console.log(\"🚀 Initializing kernel packages with maximum optimization...\");\n    \n    // All packages to install with priority and dependency information\n    const packageConfig = [\n      // High priority: CDN packages (fastest)\n      { name: 'pure-eval', priority: 1, source: 'pyodide' },\n      { name: 'stack-data', priority: 1, source: 'pyodide' },\n      { name: 'pygments', priority: 1, source: 'pyodide' },\n      { name: 'ssl', priority: 1, source: 'pyodide' },\n      { name: 'sqlite3', priority: 1, source: 'pyodide' },\n      { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n      { name: 'jedi', priority: 1, source: 'pyodide' },\n      { name: 'ipython', priority: 1, source: 'pyodide' },\n      \n      // Medium priority: pip packages\n      { name: 'comm', priority: 2, source: 'pip' },\n      { name: 'hypha-rpc', priority: 2, source: 'pip' },\n      { name: 'nbformat', priority: 2, source: 'pip' },\n      \n      // Lower priority: complex packages\n      { name: 'ipykernel', priority: 3, source: 'pip' },\n      { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n    ];\n\n    try {\n      console.log(`📦 Installing ${packageConfig.length} packages with intelligent optimization...`);\n      \n      // Install ALL packages in parallel with advanced error handling and caching\n      await this.installPackagesWithIntelligentOptimization(packageConfig);\n      \n      // Import the kernel (must be done after packages are installed)\n      console.log(\"📥 Importing pyodide_kernel...\");\n      const importStartTime = Date.now();\n      await this.pyodide.runPythonAsync('import pyodide_kernel');\n      const importTime = Date.now() - importStartTime;\n      console.log(`✅ pyodide_kernel imported in ${importTime}ms`);\n      \n      const totalTime = Date.now() - startTime;\n      console.log(`🎯 Kernel packages initialized in ${totalTime}ms`);\n      \n    } catch (error) {\n      console.error(\"❌ Kernel package initialization failed:\", error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Install packages with intelligent optimization and advanced caching\n   * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n   */\n  private async installPackagesWithIntelligentOptimization(packageConfig: Array<{name: string, priority: number, source: string}>): Promise<void> {\n    console.log(`⚡ Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n    \n    const installPromises = packageConfig.map(async (pkg) => {\n      const startTime = Date.now();\n      try {\n        console.log(`🔄 Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n        \n        // Try preferred source first, with intelligent fallback\n        if (pkg.source === 'pyodide') {\n          try {\n            await this.pyodide.loadPackage([pkg.name]);\n            const duration = Date.now() - startTime;\n            console.log(`✅ ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n            return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n          } catch (pyodideError) {\n            // Fallback to pip with enhanced error handling\n            console.log(`📦 ${pkg.name} not available on CDN, trying pip...`);\n            await this.installViaPipWithOptimizations(pkg.name);\n            const duration = Date.now() - startTime;\n            console.log(`✅ ${pkg.name} installed via pip fallback (${duration}ms)`);\n            return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n          }\n        } else {\n          // Direct pip installation with optimizations\n          await this.installViaPipWithOptimizations(pkg.name);\n          const duration = Date.now() - startTime;\n          console.log(`✅ ${pkg.name} installed via pip (${duration}ms)`);\n          return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n        }\n      } catch (error) {\n        const duration = Date.now() - startTime;\n        console.warn(`❌ Failed to install ${pkg.name} after ${duration}ms:`, error);\n        return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n      }\n    });\n    \n    // Wait for all installations with detailed analysis\n    const results = await Promise.all(installPromises);\n    \n    // Comprehensive performance analysis\n    this.analyzeInstallationResults(results);\n  }\n  \n  /**\n   * Install package via pip with performance optimizations\n   */\n  private async installViaPipWithOptimizations(packageName: string): Promise<void> {\n    await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\"✅ Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\"⚠️ Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\"✅ Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\"❌ Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n  }\n  \n  /**\n   * Analyze installation results and provide performance insights\n   */\n  private analyzeInstallationResults(results: Array<any>): void {\n    const successful = results.filter(r => r.success);\n    const failed = results.filter(r => !r.success);\n    const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n    const pipInstalls = successful.filter(r => r.method === 'pip');\n    const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n    \n    const totalDuration = Math.max(...results.map(r => r.duration));\n    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n    const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n    \n    console.log(`🎯 INTELLIGENT INSTALLATION COMPLETE!`);\n    console.log(`📊 Results: ${successful.length}/${results.length} successful`);\n    console.log(`⚡ Pyodide CDN: ${pyodideInstalls.length} packages`);\n    console.log(`📦 Direct pip: ${pipInstalls.length} packages`);\n    console.log(`🔄 Pip fallback: ${fallbackInstalls.length} packages`);\n    console.log(`❌ Failed: ${failed.length} packages`);\n    console.log(`⏱️  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n    console.log(`🚀 Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n    console.log(`📈 Average per package: ${Math.round(avgDuration)}ms`);\n    \n    if (failed.length > 0) {\n      console.warn(`⚠️  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n      // Log specific failure reasons for debugging\n      failed.forEach(f => {\n        console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n      });\n    }\n    \n    // Performance insights\n    const fastestInstall = Math.min(...successful.map(r => r.duration));\n    const slowestInstall = Math.max(...successful.map(r => r.duration));\n    console.log(`📊 Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n  }\n  \n  /**\n   * Initialize global objects from the pyodide_kernel package\n   * Based on the PyodideRemoteKernel implementation\n   */\n  private async initGlobals(): Promise<void> {\n    console.log(\"Initializing globals...\");\n    \n    // Get the globals from the Python environment\n    const { globals } = this.pyodide;\n    \n    // Get the kernel instance and related objects\n    this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n    this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n    this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n    this._interpreter = this._kernel.interpreter.copy();\n    \n    // Set up communication handlers\n    this._interpreter.send_comm = this.sendComm.bind(this);\n    \n    // Set up callbacks\n    this.setupCallbacks();\n  }\n  \n  /**\n   * Setup all necessary callbacks for the Python environment\n   */\n  private setupCallbacks(): void {\n    // Execution result callback\n    const publishExecutionResult = (\n      prompt_count: any,\n      data: any,\n      metadata: any,\n    ): void => {\n      const bundle = {\n        execution_count: prompt_count,\n        data: this.formatResult(data),\n        metadata: this.formatResult(metadata),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'execute_result',\n      });\n    };\n\n    // Error callback\n    const publishExecutionError = (ename: any, evalue: any, traceback: any): void => {\n      const bundle = {\n        ename: ename,\n        evalue: evalue,\n        traceback: traceback,\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n          type: 'execute_error',\n      });\n    };\n\n    // Clear output callback\n    const clearOutputCallback = (wait: boolean): void => {\n      const bundle = {\n        wait: this.formatResult(wait),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n          type: 'clear_output',\n      });\n    };\n\n    // Display data callback\n    const displayDataCallback = (data: any, metadata: any, transient: any): void => {\n      const bundle = {\n        data: this.formatResult(data),\n        metadata: this.formatResult(metadata),\n        transient: this.formatResult(transient),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'display_data',\n      });\n    };\n\n    // Update display data callback\n    const updateDisplayDataCallback = (\n      data: any,\n      metadata: any,\n      transient: any,\n    ): void => {\n      const bundle = {\n        data: this.formatResult(data),\n        metadata: this.formatResult(metadata),\n        transient: this.formatResult(transient),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'update_display_data',\n      });\n    };\n\n    // Stream callback\n    const publishStreamCallback = (name: any, text: any): void => {\n      const bundle = {\n        name: this.formatResult(name),\n        text: this.formatResult(text),\n      };\n\n      this._sendMessage({\n        parentHeader: this.formatResult(this._parent_header)['header'],\n        bundle,\n        type: 'stream',\n      });\n    };\n\n    // Assign callbacks to the Python objects\n    this._stdout_stream.publish_stream_callback = publishStreamCallback;\n    this._stderr_stream.publish_stream_callback = publishStreamCallback;\n    this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n    this._interpreter.display_pub.display_data_callback = displayDataCallback;\n    this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n    this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n    this._interpreter.input = this.input.bind(this);\n    this._interpreter.getpass = this.getpass.bind(this);\n  }\n  \n  /**\n   * Process a message from Python environment\n   */\n  private _sendMessage(msg: IMessage): void {\n    this._processMessage(msg);\n  }\n  \n  /**\n   * Process a message by emitting the appropriate event\n   */\n  private _processMessage(msg: IMessage): void {\n    if (!msg.type) {\n      return;\n    }\n\n    let eventData: any;\n\n    switch (msg.type) {\n      case 'stream': {\n        const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n        super.emit(KernelEvents.STREAM, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'input_request': {\n        const content = msg.content ?? { prompt: '', password: false };\n        super.emit(KernelEvents.INPUT_REQUEST, content);\n        eventData = content;\n        break;\n      }\n      case 'display_data': {\n        const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n        super.emit(KernelEvents.DISPLAY_DATA, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'update_display_data': {\n        const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n        super.emit(KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'clear_output': {\n        const bundle = msg.bundle ?? { wait: false };\n        super.emit(KernelEvents.CLEAR_OUTPUT, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'execute_result': {\n        const bundle = msg.bundle ?? {\n          execution_count: this.executionCount,\n          data: {},\n          metadata: {},\n        };\n        super.emit(KernelEvents.EXECUTE_RESULT, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'execute_error': {\n        const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n        super.emit(KernelEvents.EXECUTE_ERROR, bundle);\n        eventData = bundle;\n        break;\n      }\n      case 'comm_open':\n      case 'comm_msg':\n      case 'comm_close': {\n        const content = msg.content ?? {};\n        super.emit(msg.type, content, msg.metadata, msg.buffers);\n        eventData = {\n          content,\n          metadata: msg.metadata,\n          buffers: msg.buffers\n        };\n        break;\n      }\n    }\n\n    // Emit the ALL event with standardized format\n    if (eventData) {\n      super.emit(KernelEvents.ALL, {\n        type: msg.type,\n        data: eventData\n      } as IEventData);\n    }\n  }\n  \n  /**\n   * Check if the kernel has been initialized\n   */\n  public isInitialized(): boolean {\n    return this.initialized;\n  }\n  \n  /**\n   * Makes sure pyodide is ready before continuing, and cache the parent message.\n   */\n  private async setup(parent: any): Promise<void> {\n    await this.initialize();\n    this._parent_header = this.pyodide.toPy(parent || {});\n  }\n  \n  /**\n   * Execute code in the kernel with proper message-based completion detection\n   * \n   * @param code The code to execute\n   * @param parent Parent message header\n   * @returns The result of the execution\n   */\n  public async execute(code: string, parent: any = {}): Promise<{ success: boolean, outputs?: any, error?: Error, ename?: string, evalue?: string, traceback?: any }> {\n    // Simple implementation that collects all outputs from executeStream\n    const outputs: any[] = [];\n    \n    try {\n      // Use executeStream to get all outputs\n      for await (const output of this.executeStream(code, parent)) {\n        outputs.push(output);\n      }\n      \n      // Process collected outputs to create a comprehensive result\n      const result: any = {\n        outputs: [],\n        data: {},\n        metadata: {},\n        execution_count: this.executionCount\n      };\n      \n      // Collect all output types\n      for (const output of outputs) {\n        if (output.type === 'stream') {\n          // Collect stdout/stderr\n          if (!result.stdout) result.stdout = '';\n          if (!result.stderr) result.stderr = '';\n          \n          if (output.data.name === 'stdout') {\n            result.stdout += output.data.text;\n          } else if (output.data.name === 'stderr') {\n            result.stderr += output.data.text;\n          }\n          result.outputs.push(output.data);\n        } else if (output.type === 'display_data' || output.type === 'execute_result') {\n          // Collect display data\n          if (output.data.data) {\n            Object.assign(result.data, output.data.data);\n          }\n          if (output.data.metadata) {\n            Object.assign(result.metadata, output.data.metadata);\n          }\n          result.outputs.push(output.data);\n        } else if (output.type === 'execute_error' || output.type === 'error') {\n          // Handle errors\n          const errorData = output.data;\n          return {\n            success: false,\n            error: new Error(`${errorData.ename}: ${errorData.evalue}`),\n            ename: errorData.ename,\n            evalue: errorData.evalue,\n            traceback: errorData.traceback,\n            outputs: result.outputs\n          };\n        } else {\n          // Store any other output type\n          result.outputs.push(output);\n        }\n      }\n      // Return collected results\n      result.success = true;\n\n      // Auto-sync native filesystems if enabled\n      if (this.autoSyncFs) {\n        await this.syncAllNativeFs();\n      }\n\n      return result;\n\n    } catch (error) {\n      console.error(\"[KERNEL] Execute error:\", error);\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error))\n      };\n    }\n  }\n  \n  /**\n   * Format the result from the Pyodide evaluation\n   * Based on PyodideRemoteKernel implementation\n   */\n  private formatResult(res: any): any {\n    if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n      return res;\n    }\n    \n    try {\n      // Convert PyProxy to JS\n      const m = res.toJs();\n      const results = this.mapToObject(m);\n      return results;\n    } catch (error) {\n      console.error(\"Error formatting result:\", error);\n      return { status: 'error', error: String(error) };\n    }\n  }\n  \n  /**\n   * Convert a Map to a JavaScript object recursively\n   * Based on PyodideRemoteKernel implementation\n   */\n  private mapToObject(obj: any) {\n    const out: any = obj instanceof Array ? [] : {};\n    \n    obj.forEach((value: any, key: string) => {\n      out[key] = \n        value instanceof Map || value instanceof Array\n          ? this.mapToObject(value)\n          : value;\n    });\n    \n    return out;\n  }\n  \n  /**\n   * Handle input reply from user\n   */\n  public async inputReply(content: { value: string }): Promise<void> {\n    if (this._resolveInputReply) {\n      this._resolveInputReply(content);\n      this._resolveInputReply = null;\n    }\n  }\n  \n  /**\n   * Send a input request to the front-end.\n   */\n  private async sendInputRequest(prompt: string, password: boolean): Promise<void> {\n    const content = {\n      prompt,\n      password,\n    };\n\n    this._sendMessage({\n      type: 'input_request',\n      content,\n      parentHeader: this.formatResult(this._parent_header)['header']\n    });\n  }\n\n  /**\n   * Get password input (with hidden input)\n   */\n  private async getpass(prompt: string): Promise<string> {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await this.sendInputRequest(prompt, true);\n    const replyPromise = new Promise<{ value: string }>((resolve) => {\n      this._resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result.value;\n  }\n\n  /**\n   * Get text input\n   */\n  private async input(prompt: string): Promise<string> {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await this.sendInputRequest(prompt, false);\n    const replyPromise = new Promise<{ value: string }>((resolve) => {\n      this._resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result.value;\n  }\n  \n  /**\n   * Send a comm message to the front-end.\n   */\n  private async sendComm(type: string, content: any, metadata: any, ident: any, buffers: any): Promise<void> {\n    this._sendMessage({\n      type: type,\n      content: this.formatResult(content),\n      metadata: this.formatResult(metadata),\n      ident: this.formatResult(ident),\n      buffers: this.formatResult(buffers),\n      parentHeader: this.formatResult(this._parent_header)['header'],\n    });\n  }\n  \n  /**\n   * Complete the code submitted by a user.\n   */\n  public async complete(code: string, cursor_pos: number, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.complete(code, cursor_pos);\n    return this.formatResult(res);\n  }\n\n  /**\n   * Inspect the code submitted by a user.\n   */\n  public async inspect(code: string, cursor_pos: number, detail_level: 0 | 1, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.inspect(code, cursor_pos, detail_level);\n    return this.formatResult(res);\n  }\n\n  /**\n   * Check code for completeness.\n   */\n  public async isComplete(code: string, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.is_complete(code);\n    return this.formatResult(res);\n  }\n\n  /**\n   * Get information about available comms.\n   */\n  public async commInfo(target_name: string | null, parent: any = {}): Promise<any> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_info(target_name);\n    return {\n      comms: this.formatResult(res),\n      status: 'ok',\n    };\n  }\n\n  /**\n   * Open a COMM\n   */\n  public async commOpen(content: any, parent: any = {}): Promise<void> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_manager.comm_open(\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(content)\n    );\n    \n    return this.formatResult(res);\n  }\n  \n  /**\n   * Send a message through a COMM\n   */\n  public async commMsg(content: any, parent: any = {}): Promise<void> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_manager.comm_msg(\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(content)\n    );\n    \n    return this.formatResult(res);\n  }\n  \n  /**\n   * Close a COMM\n   */\n  public async commClose(content: any, parent: any = {}): Promise<void> {\n    await this.setup(parent);\n    \n    const res = this._kernel.comm_manager.comm_close(\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(null),\n      this.pyodide.toPy(content)\n    );\n    \n    return this.formatResult(res);\n  }\n\n  /**\n   * Execute Python code with streaming output\n   * @param code The Python code to execute\n   * @param parent Parent message header\n   * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n   */\n  public async* executeStream(code: string, parent: any = {}): AsyncGenerator<any, { success: boolean, result?: any, error?: Error }, void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    try {\n      this._status = \"busy\";\n      super.emit(KernelEvents.KERNEL_BUSY, {});\n      await this.setup(parent);\n      // Create event listeners for streaming\n      const eventQueue: IEventData[] = [];\n      let executionComplete = false;\n      let executionResult: any = null;\n      let executionError: Error | null = null;\n      \n      const handleAllEvents = (eventData: IEventData) => {\n        eventQueue.push(eventData);\n      };\n      \n      // Listen for all events BEFORE executing code\n      super.on(KernelEvents.ALL, handleAllEvents);\n      \n      try {\n        // Execute the code directly\n        this._kernel.run(code).then((result: any) => {\n          console.log(\"[KERNEL] Python execution finished\");\n          executionResult = this.formatResult(result);\n          \n          // Check if the result indicates an error and emit it as an event\n          if (executionResult && executionResult.status === 'error') {\n            console.log(\"[KERNEL] Execution completed with error status, emitting execute_error event\");\n            \n            // Emit the error event so the UI can display it\n            this._sendMessage({\n              parentHeader: this.formatResult(this._parent_header)['header'],\n              bundle: {\n                ename: executionResult.ename || 'Error',\n                evalue: executionResult.evalue || 'Unknown error',\n                traceback: executionResult.traceback || []\n              },\n              type: 'execute_error',\n            });\n          }\n          \n          // Wait a small amount of time for any remaining messages to be processed\n          setTimeout(() => {\n            executionComplete = true;\n          }, 100); // 100ms should be enough for message processing\n          \n        }).catch((error: any) => {\n          console.error(\"[KERNEL] Python execution error:\", error);\n          executionError = error instanceof Error ? error : new Error(String(error));\n          \n          // Still wait for messages to settle before completing\n          setTimeout(() => {\n            executionComplete = true;\n          }, 100);\n        });\n        \n        // Stream events as they arrive\n        while (!executionComplete || eventQueue.length > 0) {\n          // Yield queued events\n          if (eventQueue.length > 0) {\n            const event = eventQueue.shift()!;\n            yield event;\n          } else if (!executionComplete) {\n            // Wait a bit for more events\n            await new Promise(resolve => setTimeout(resolve, 10));\n          }\n        }\n        \n        // Process final result\n        this._status = \"active\";\n        super.emit(KernelEvents.KERNEL_IDLE, {});\n        \n        if (executionError) {\n          return {\n            success: false,\n            error: executionError,\n            result: executionResult\n          };\n        }\n        \n        // Check if result indicates an error\n        if (executionResult && executionResult.status === 'error') {\n          const errorMsg = `${executionResult.ename || 'Error'}: ${executionResult.evalue || 'Unknown error'}`;\n          return {\n            success: false,\n            error: new Error(errorMsg),\n            result: executionResult\n          };\n        }\n\n        // Auto-sync native filesystems if enabled\n        if (this.autoSyncFs) {\n          await this.syncAllNativeFs();\n        }\n\n        return {\n          success: true,\n          result: executionResult\n        };\n\n      } finally {\n        // Clean up listener\n        super.off(KernelEvents.ALL, handleAllEvents);\n      }\n      \n    } catch (error) {\n      console.error(\"[KERNEL] ExecuteStream error:\", error);\n      this._status = \"active\";\n      super.emit(KernelEvents.KERNEL_IDLE, {});\n      \n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error))\n      };\n    }\n  }\n\n  // Interrupt functionality\n  public async interrupt(): Promise<boolean> {\n    if (!this.initialized || !this.pyodide) {\n      console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n      return false;\n    }\n    \n    console.log(\"[KERNEL] Attempting to interrupt execution...\");\n    \n    try {\n      // First priority: Use interrupt buffer if available\n      if (this._interruptBuffer && this._interruptSupported) {\n        console.log(\"[KERNEL] Using interrupt buffer method\");\n        // Set interrupt signal (2 = SIGINT)\n        this._interruptBuffer[0] = 2;\n        \n        // Give the interrupt a moment to be processed\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        // Check if the interrupt was processed (buffer should be reset to 0)\n        const wasProcessed = this._interruptBuffer[0] === 0;\n        if (wasProcessed) {\n          console.log(\"[KERNEL] Interrupt processed successfully via buffer\");\n          return true;\n        }\n      }\n      \n      // Second priority: Try Python-level interrupt\n      try {\n        console.log(\"[KERNEL] Attempting Python-level interrupt\");\n        // Try to raise KeyboardInterrupt in Python\n        await this.pyodide.runPythonAsync(`\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n`);\n        console.log(\"[KERNEL] Python interrupt signal sent\");\n        return true;\n      } catch (pythonError) {\n        console.log(\"[KERNEL] Python interrupt attempt failed:\", pythonError);\n      }\n      \n      // Third priority: Try interpreter interrupt if available\n      if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n        console.log(\"[KERNEL] Using interpreter interrupt method\");\n        this._interpreter.interrupt();\n        return true;\n      }\n      \n      // Last resort: Send interrupt messages for UI feedback\n      console.log(\"[KERNEL] Sending interrupt messages for UI feedback\");\n      \n      // Send stderr stream first (for Jupyter notebook UI compatibility)\n      this._sendMessage({\n        type: 'stream',\n        bundle: {\n          name: 'stderr',\n          text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n        }\n      });\n      \n      this._sendMessage({\n        type: 'execute_error',\n        bundle: {\n          ename: 'KeyboardInterrupt',\n          evalue: 'Execution interrupted by user',\n          traceback: ['KeyboardInterrupt: Execution interrupted by user']\n        }\n      });\n      \n      // Return false since we couldn't actually interrupt the execution\n      return false;\n    } catch (error) {\n      console.error(\"[KERNEL] Error during interrupt:\", error);\n      return false;\n    }\n  }\n\n  public setInterruptBuffer(buffer: Uint8Array): void {\n    this._interruptBuffer = buffer;\n\n    try {\n      if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n        this.pyodide.setInterruptBuffer(buffer);\n        this._interruptSupported = true;\n      } else {\n        console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n        this._interruptSupported = false;\n      }\n    } catch (error) {\n      console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n      this._interruptSupported = false;\n    }\n  }\n\n  /**\n   * Verify and request permission for a file system handle\n   * @private\n   */\n  private async verifyPermission(\n    fileHandle: FileSystemDirectoryHandle,\n    permission: 'read' | 'readwrite'\n  ): Promise<boolean> {\n    const opts: any = {};\n    if (permission === 'readwrite') {\n      opts.mode = 'readwrite';\n    }\n\n    console.log(`[KERNEL] Verifying ${permission} permission for file handle...`);\n\n    // Check if permission APIs are supported\n    if (typeof (fileHandle as any).queryPermission !== 'function') {\n      console.warn('[KERNEL] queryPermission not supported, assuming permission granted');\n      return true;\n    }\n\n    try {\n      // Check if we already have permission, if so, return true.\n      const queryResult = await (fileHandle as any).queryPermission(opts);\n      console.log('[KERNEL] Query result:', queryResult);\n      \n      if (queryResult === 'granted') {\n        console.log(`[KERNEL] Permission already granted for ${permission} access`);\n        return true;\n      }\n\n      // Request permission to the file, if the user grants permission, return true.\n      if (typeof (fileHandle as any).requestPermission === 'function') {\n        console.log(`[KERNEL] Requesting ${permission} permission from user...`);\n        \n        try {\n          const requestResult = await (fileHandle as any).requestPermission(opts);\n          console.log('[KERNEL] Request result:', requestResult);\n          \n          if (requestResult === 'granted') {\n            console.log(`[KERNEL] Permission granted for ${permission} access`);\n            return true;\n          }\n        } catch (requestError) {\n          console.log('[KERNEL] Permission request failed or was dismissed:', requestError);\n        }\n      }\n\n      // The user did not grant permission, return false.\n      console.log(`[KERNEL] ${permission} permission not granted`);\n      return false;\n      \n    } catch (error) {\n      console.error('[KERNEL] Error checking permission:', error);\n      // If permission check fails, assume it's granted (more permissive approach)\n      console.warn('[KERNEL] Permission check failed, assuming granted as fallback');\n      return true;\n    }\n  }\n\n  /**\n   * Mount a native file system directory into the Pyodide filesystem\n   * @param mountPath The path where the directory should be mounted in the Python filesystem\n   * @param dirHandle Optional FileSystemDirectoryHandle. If null/undefined, shows directory picker\n   * @param permission Permission mode:\n   *   - 'read': Read-only access, no syncing capabilities, auto-sync will be skipped (default)\n   *   - 'readwrite': Full read/write access with syncing capabilities\n   * @returns Promise resolving to a handle with syncfs() method for syncing changes\n   * @note syncfs() will throw an error if called on a read-only mounted filesystem\n   * @note Many browsers only offer read permission initially. Explicitly request 'readwrite' if you need write access.\n   */\n  public async mountFS(\n    mountPath: string,\n    dirHandle?: FileSystemDirectoryHandle | null,\n    permission: 'read' | 'readwrite' = 'read'\n  ): Promise<{ syncfs: () => Promise<void> }> {\n    if (!this.initialized || !this.pyodide) {\n      throw new Error(\"Kernel must be initialized before mounting filesystem\");\n    }\n\n    // Check if mountNativeFS is available\n    if (typeof this.pyodide.mountNativeFS !== 'function') {\n      throw new Error(\"pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.\");\n    }\n\n    let handle = dirHandle;\n\n    // If no dirHandle provided, show directory picker\n    if (!handle) {\n      // Check if we're in a worker context\n      if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n        throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter.\");\n      }\n\n      // Check if showDirectoryPicker is available\n      if (typeof window !== 'undefined' && 'showDirectoryPicker' in window) {\n        try {\n          handle = await (window as any).showDirectoryPicker({\n            mode: 'readwrite',\n          });\n        } catch (error) {\n          throw new Error(`Failed to show directory picker: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      } else {\n        throw new Error(\"showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.\");\n      }\n    }\n\n    if (!handle) {\n      throw new Error(\"No directory handle available\");\n    }\n\n    // Verify and request permissions before mounting\n    console.log(`[KERNEL] Verifying ${permission} permissions before mounting...`);\n    const hasRequestedPermission = await this.verifyPermission(handle, permission);\n    \n    if (!hasRequestedPermission) {\n      if (permission === 'readwrite') {\n        throw new Error(\n          `Failed to obtain write permission for directory. ` +\n          `The browser may only be offering read permission. ` +\n          `Try mounting with permission: 'read' if you only need to read files, ` +\n          `or ensure the browser supports write access to this directory.`\n        );\n      } else {\n        throw new Error(`Failed to obtain ${permission} permission for directory.`);\n      }\n    }\n    \n    const actualPermission = permission;\n\n    // Mount the native filesystem\n    try {\n      console.log(`[KERNEL] Mounting native filesystem at ${mountPath} with ${actualPermission} permission`);\n      \n      // Check if the mount point already exists and handle cleanup\n      try {\n        const pathInfo = this.pyodide.FS.analyzePath(mountPath);\n        if (pathInfo.exists) {\n          console.log(`[KERNEL] Path ${mountPath} exists, checking if it's a mount point`);\n          \n          // Try to unmount if it's already mounted\n          try {\n            await this.pyodide.FS.unmount(mountPath);\n            console.log(`[KERNEL] Successfully unmounted existing filesystem at ${mountPath}`);\n          } catch (unmountError) {\n            // If unmount fails, it might not be a mount point or might be busy\n            console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${unmountError}`);\n          }\n          \n          // Remove the directory if it exists but is empty\n          try {\n            this.pyodide.FS.rmdir(mountPath);\n            console.log(`[KERNEL] Removed existing directory at ${mountPath}`);\n          } catch (rmdirError) {\n            // Directory might not be empty or might not exist, that's okay\n            console.log(`[KERNEL] Could not remove directory (this is normal): ${rmdirError}`);\n          }\n        }\n      } catch (analyzeError) {\n        // analyzePath might fail, that's okay - the path probably doesn't exist\n        console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${analyzeError}`);\n      }\n      \n      // Ensure the parent directory exists\n      const parentPath = mountPath.substring(0, mountPath.lastIndexOf('/')) || '/';\n      try {\n        if (parentPath !== '/' && !this.pyodide.FS.analyzePath(parentPath).exists) {\n          this.pyodide.FS.mkdir(parentPath);\n          console.log(`[KERNEL] Created parent directory ${parentPath}`);\n        }\n      } catch (parentError) {\n        console.log(`[KERNEL] Parent directory handling: ${parentError}`);\n      }\n      \n      const nativefs = await this.pyodide.mountNativeFS(mountPath, handle);\n\n      console.log(`[KERNEL] Successfully mounted native filesystem at ${mountPath} with ${actualPermission} permission`);\n\n      // Create a handle with syncfs method and permission recovery\n      const fsHandle = {\n        syncfs: async () => {\n          // Check if filesystem is read-only\n          if (actualPermission === 'read') {\n            throw new Error(`Cannot sync read-only filesystem at ${mountPath}. Use upgradeFileSystemPermission() to request write access.`);\n          }\n          \n          try {\n            await nativefs.syncfs();\n            console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n          } catch (error) {\n            throw new Error(`Failed to sync filesystem: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        },\n        dirHandle: handle,\n        permission: actualPermission,\n        nativefs: nativefs\n      };\n\n      // Store the handle for auto-sync\n      this.nativeFsHandles.set(mountPath, fsHandle);\n\n      return { syncfs: fsHandle.syncfs };\n    } catch (error) {\n      throw new Error(`Failed to mount native filesystem: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Sync all mounted native filesystems with permission recovery\n   * Only syncs filesystems mounted with 'readwrite' permission\n   * @private\n   */\n  private async syncAllNativeFs(): Promise<void> {\n    if (this.nativeFsHandles.size === 0) {\n      return;\n    }\n\n    const syncResults: Array<{ mountPath: string; success: boolean; error?: string; skipped?: boolean }> = [];\n\n    for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n      // Skip read-only filesystems\n      if (fsHandle.permission === 'read') {\n        syncResults.push({ mountPath, success: true, skipped: true });\n        console.log(`[KERNEL] Skipping sync for read-only filesystem at ${mountPath}`);\n        continue;\n      }\n\n      try {\n        // First, try to sync directly\n        await fsHandle.syncfs();\n        syncResults.push({ mountPath, success: true });\n        console.log(`[KERNEL] Successfully synced filesystem at ${mountPath}`);\n      } catch (error) {\n        // If sync fails, check if it's a permission error\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        \n        if (errorMessage.includes('not allowed by the user agent') || \n            errorMessage.includes('getFileHandle') ||\n            errorMessage.includes('permission')) {\n          \n          console.warn(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n          \n          try {\n            // Try to recover by re-verifying permissions\n            const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n            \n            if (hasPermission) {\n              // Try to remount and sync\n              console.log(`[KERNEL] Permission recovered for ${mountPath}, attempting remount...`);\n              const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n              \n              // Update the stored handle with the new nativefs\n              fsHandle.nativefs = newNativefs;\n              fsHandle.syncfs = async () => {\n                try {\n                  await newNativefs.syncfs();\n                  console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                } catch (syncError) {\n                  throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                }\n              };\n              \n              // Try sync again with the new handle\n              await fsHandle.syncfs();\n              syncResults.push({ mountPath, success: true });\n              console.log(`[KERNEL] Successfully recovered and synced filesystem at ${mountPath}`);\n            } else {\n              syncResults.push({ \n                mountPath, \n                success: false, \n                error: 'Permission denied by user' \n              });\n              console.warn(`[KERNEL] User denied permission for ${mountPath}, skipping sync`);\n            }\n          } catch (recoveryError) {\n            const recoveryMessage = recoveryError instanceof Error ? recoveryError.message : String(recoveryError);\n            syncResults.push({ \n              mountPath, \n              success: false, \n              error: `Recovery failed: ${recoveryMessage}` \n            });\n            console.error(`[KERNEL] Failed to recover permissions for ${mountPath}:`, recoveryError);\n          }\n        } else {\n          // Non-permission error\n          syncResults.push({ \n            mountPath, \n            success: false, \n            error: errorMessage \n          });\n          console.error(`[KERNEL] Non-permission error syncing ${mountPath}:`, error);\n        }\n      }\n    }\n\n    // Log summary\n    const successful = syncResults.filter(r => r.success && !r.skipped).length;\n    const skipped = syncResults.filter(r => r.skipped).length;\n    const failed = syncResults.filter(r => !r.success);\n    \n    if (successful > 0 || skipped > 0) {\n      const parts = [];\n      if (successful > 0) parts.push(`${successful} synced`);\n      if (skipped > 0) parts.push(`${skipped} read-only skipped`);\n      console.log(`[KERNEL] Auto-sync completed: ${parts.join(', ')} (${syncResults.length} total filesystems)`);\n    }\n    \n    if (failed.length > 0) {\n      console.warn(`[KERNEL] Auto-sync issues:`, failed.map(f => `${f.mountPath}: ${f.error}`));\n    }\n    \n    // Don't throw - we don't want to fail execution just because sync failed\n  }\n\n  /**\n   * Get information about mounted native filesystems and their permission status\n   * @returns Array of mounted filesystem information\n   */\n  public getMountedFileSystems(): Array<{\n    mountPath: string;\n    permission: 'read' | 'readwrite';\n    canSync: boolean;\n  }> {\n    const result: Array<{\n      mountPath: string;\n      permission: 'read' | 'readwrite';\n      canSync: boolean;\n    }> = [];\n\n    for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n      result.push({\n        mountPath,\n        permission: fsHandle.permission,\n        canSync: fsHandle.permission === 'readwrite'\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Manually sync a specific mounted filesystem\n   * @param mountPath The path of the mounted filesystem to sync\n   * @returns Promise resolving to success status\n   */\n  public async syncFileSystem(mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const fsHandle = this.nativeFsHandles.get(mountPath);\n    \n    if (!fsHandle) {\n      return {\n        success: false,\n        error: `No filesystem mounted at ${mountPath}`\n      };\n    }\n\n    // Check if filesystem is read-only\n    if (fsHandle.permission === 'read') {\n      return {\n        success: false,\n        error: `Cannot sync read-only filesystem at ${mountPath}. Mount with 'readwrite' permission to enable syncing.`\n      };\n    }\n\n    try {\n      await fsHandle.syncfs();\n      return { success: true };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      // Try permission recovery if it's a permission error\n      if (errorMessage.includes('not allowed by the user agent') || \n          errorMessage.includes('getFileHandle') ||\n          errorMessage.includes('permission')) {\n        \n        console.log(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n        \n        try {\n          const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n          \n          if (hasPermission) {\n            // Remount and try again\n            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n            fsHandle.nativefs = newNativefs;\n            fsHandle.syncfs = async () => {\n              try {\n                await newNativefs.syncfs();\n                console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n              } catch (syncError) {\n                throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n              }\n            };\n            \n            await fsHandle.syncfs();\n            return { success: true };\n          } else {\n            return {\n              success: false,\n              error: 'Permission denied by user'\n            };\n          }\n        } catch (recoveryError) {\n          return {\n            success: false,\n            error: `Recovery failed: ${recoveryError instanceof Error ? recoveryError.message : String(recoveryError)}`\n          };\n        }\n      }\n      \n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Upgrade a mounted filesystem from read-only to read-write permission\n   * @param mountPath The path of the mounted filesystem to upgrade\n   * @returns Promise resolving to success status\n   */\n  public async upgradeFileSystemPermission(mountPath: string): Promise<{ success: boolean; error?: string }> {\n    const fsHandle = this.nativeFsHandles.get(mountPath);\n    \n    if (!fsHandle) {\n      return {\n        success: false,\n        error: `No filesystem mounted at ${mountPath}`\n      };\n    }\n\n    if (fsHandle.permission === 'readwrite') {\n      return {\n        success: true,\n        error: `FileSystem at ${mountPath} already has readwrite permission`\n      };\n    }\n\n    try {\n      console.log(`[KERNEL] Attempting to upgrade ${mountPath} to readwrite permission...`);\n      \n      // Try to get readwrite permission\n      const hasWritePermission = await this.verifyPermission(fsHandle.dirHandle, 'readwrite');\n      \n      if (!hasWritePermission) {\n        return {\n          success: false,\n          error: 'User denied write permission or browser does not support write access to this directory'\n        };\n      }\n\n      // Remount with write permission\n      const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n      \n      // Update the stored handle\n      fsHandle.permission = 'readwrite';\n      fsHandle.nativefs = newNativefs;\n      fsHandle.syncfs = async () => {\n        try {\n          await newNativefs.syncfs();\n          console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n        } catch (syncError) {\n          throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n        }\n      };\n\n      console.log(`[KERNEL] Successfully upgraded ${mountPath} to readwrite permission`);\n      return { success: true };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: `Failed to upgrade permission: ${error instanceof Error ? error.message : String(error)}`\n      };\n    }\n  }\n\n  /**\n   * Set environment variables with performance optimization\n   * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n   */\n  private async setEnvironmentVariables(): Promise<void> {\n    if (Object.keys(this.environmentVariables).length === 0) {\n      return; // No variables to set\n    }\n    \n    const startTime = Date.now();\n    console.log(`🌍 Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n    \n    try {\n      // Set each environment variable individually to avoid escaping issues\n      for (const [key, value] of Object.entries(this.environmentVariables)) {\n        // Handle edge cases: null, undefined, etc.\n        let processedValue: string;\n        if (value === null) {\n          processedValue = '';  // Convert null to empty string\n        } else if (value === undefined) {\n          processedValue = '';  // Convert undefined to empty string\n        } else {\n          processedValue = String(value);  // Convert everything else to string\n        }\n        \n        await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n      }\n      \n      const duration = Date.now() - startTime;\n      console.log(`⚡ Environment variables set in ${duration}ms`);\n    } catch (error) {\n      console.error(\"❌ Failed to set environment variables:\", error);\n      throw error;\n    }\n  }\n}\n\n// Only Python kernel is supported\n\n// Export the manager for advanced usage\nexport { KernelManager } from \"./manager\";\n","// this file is autogenerated from the wheels in the pypi directory\nexport const allJSONUrl = \"pypi/all.json\";\nexport const ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nexport const pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nexport const pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nexport const widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nexport const widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n","// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n\n// Events enum\nexport enum KernelEvents {\n  // IOPub Channel Messages\n  STREAM = \"stream\",\n  DISPLAY_DATA = \"display_data\",\n  UPDATE_DISPLAY_DATA = \"update_display_data\",\n  EXECUTE_RESULT = \"execute_result\",\n  EXECUTE_ERROR = \"execute_error\",\n  EXECUTE_REQUEST = \"execute_request\",\n  \n  // Input request\n  INPUT_REQUEST = \"input_request\",\n  \n  // Output control\n  CLEAR_OUTPUT = \"clear_output\",\n  \n  // Comm messages\n  COMM_OPEN = \"comm_open\",\n  COMM_MSG = \"comm_msg\",\n  COMM_CLOSE = \"comm_close\",\n  \n  // Internal Events\n  KERNEL_READY = \"kernel_ready\",\n  KERNEL_BUSY = \"kernel_busy\",\n  KERNEL_IDLE = \"kernel_idle\",\n  \n  // Special catchall for internal use\n  ALL = \"*\", // Wildcard event type\n  \n  // Execution monitoring events\n  EXECUTION_STALLED = \"execution_stalled\",\n  \n  // Enhanced stuck kernel handling events\n  KERNEL_UNRECOVERABLE = \"kernel_unrecoverable\",\n  EXECUTION_INTERRUPTED = \"execution_interrupted\",\n  KERNEL_RESTARTED = \"kernel_restarted\",\n  KERNEL_TERMINATED = \"kernel_terminated\"\n}\n\n// EventEmitter interface for typing\nexport interface IEventEmitter {\n  on(eventName: string, listener: Function): void;\n  off(eventName: string, listener: Function): void;\n  emit(eventName: string, ...args: any[]): void;\n  setMaxListeners(n: number): void;\n}\n\n// FileSystem mount options\nexport interface IFileSystemMountOptions {\n  enabled?: boolean;\n  root?: string;\n  mountPoint?: string;\n}\n\n// Kernel options interface\nexport interface IKernelOptions {\n  filesystem?: IFileSystemMountOptions;\n  env?: Record<string, string>; // Environment variables to set in the kernel\n  lockFileURL?: string; // URL to pyodide-lock.json file for faster loading\n  autoSyncFs?: boolean; // Automatically sync native filesystem after code execution (default: false)\n}\n\n// Native filesystem handle type\nexport interface INativeFSHandle {\n  syncfs(): Promise<void>;\n}\n\n// Kernel interface\nexport interface IKernel extends IEventEmitter {\n  initialize(options?: IKernelOptions): Promise<void>;\n  execute(code: string, parent?: any): Promise<{ success: boolean, result?: any, error?: Error }>;\n  executeStream?(code: string, parent?: any): AsyncGenerator<any, { success: boolean, result?: any, error?: Error }, void>;\n  isInitialized(): boolean;\n  inputReply(content: { value: string }): Promise<void>;\n  getStatus(): Promise<\"active\" | \"busy\" | \"unknown\">;\n\n  // Interrupt functionality\n  interrupt?(): Promise<boolean>;\n  setInterruptBuffer?(buffer: Uint8Array): void;\n\n  // Native filesystem mounting\n  mountFS?(mountPath: string, dirHandle?: FileSystemDirectoryHandle | null, permission?: 'read' | 'readwrite'): Promise<INativeFSHandle>;\n  getMountedFileSystems?(): Array<{ mountPath: string; permission: 'read' | 'readwrite'; canSync: boolean; }>;\n  syncFileSystem?(mountPath: string): Promise<{ success: boolean; error?: string }>;\n  upgradeFileSystemPermission?(mountPath: string): Promise<{ success: boolean; error?: string }>;\n\n  // Optional methods\n  complete?(code: string, cursor_pos: number, parent?: any): Promise<any>;\n  inspect?(code: string, cursor_pos: number, detail_level: 0 | 1, parent?: any): Promise<any>;\n  isComplete?(code: string, parent?: any): Promise<any>;\n  commInfo?(target_name: string | null, parent?: any): Promise<any>;\n  commOpen?(content: any, parent?: any): Promise<void>;\n  commMsg?(content: any, parent?: any): Promise<void>;\n  commClose?(content: any, parent?: any): Promise<void>;\n}\n\n// Execute options interface\nexport interface IKernelExecuteOptions {\n  code: string;\n  silent?: boolean;\n  storeHistory?: boolean;\n}\n\n// Message interface\nexport interface IMessage {\n  type: string;\n  bundle?: any;\n  content?: any;\n  metadata?: any;\n  parentHeader?: any;\n  buffers?: any;\n  ident?: any;\n}\n\n// Event data interface\nexport interface IEventData {\n  type: string;\n  data: any;\n} ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Web Worker file for running the Kernel in a separate thread\n// Import necessary modules\nimport * as Comlink from \"comlink\";\nimport { KernelEvents, IKernelOptions } from \"./types\";\nimport { Kernel } from \"./index\";\n\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n  public events: { [key: string]: Function[] } = {};\n\n  on(eventName: string, listener: Function) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(listener);\n  }\n\n  off(eventName: string, listener: Function) {\n    if (!this.events[eventName]) return;\n    const index = this.events[eventName].indexOf(listener);\n    if (index > -1) {\n      this.events[eventName].splice(index, 1);\n    }\n  }\n\n  emit(eventName: string, ...args: any[]) {\n    if (!this.events[eventName]) return;\n    this.events[eventName].forEach(listener => listener(...args));\n  }\n}\n\n\n// Create a new kernel instance\nconst kernel = new Kernel();\n\n// Variable to store the event port\nlet eventPort: MessagePort | null = null;\n\n// Store kernel initialization options\nlet kernelOptions: IKernelOptions = {};\n\n// Track current event listeners for cleanup\nlet currentEventListeners: Map<string, (data: any) => void> = new Map();\n\n// Interrupt handling for worker\nlet interruptBuffer: Uint8Array | null = null;\n\n// Helper function to check if an error is a KeyboardInterrupt\nfunction isKeyboardInterrupt(error: any): boolean {\n  return error && \n         typeof error === 'object' && \n         (error.type === \"KeyboardInterrupt\" || \n          (error.message && error.message.includes(\"KeyboardInterrupt\")));\n}\n\n// Helper function to create KeyboardInterrupt error result\nfunction createKeyboardInterruptResult() {\n  return {\n    success: false,\n    error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n    result: {\n      payload: [],\n      status: \"error\",\n      ename: \"KeyboardInterrupt\",\n      evalue: \"Execution interrupted by user\",\n      traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n    }\n  };\n}\n\n// Global error handlers to prevent worker crashes\nself.addEventListener(\"error\", (event) => {\n  console.error(\"[WORKER] Global error caught:\", event.error);\n  event.preventDefault();\n});\n\nself.addEventListener(\"unhandledrejection\", (event) => {\n  if (isKeyboardInterrupt(event.reason)) {\n    console.log(\"[WORKER] KeyboardInterrupt caught in unhandled rejection handler - this is expected during interrupts\");\n    \n    // Send interrupt acknowledgment if we have an event port\n    if (eventPort) {\n      eventPort.postMessage({\n        type: KernelEvents.EXECUTE_ERROR,\n        data: {\n          ename: \"KeyboardInterrupt\",\n          evalue: \"Execution interrupted by user\",\n          traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n        }\n      });\n    }\n  } else {\n    console.error(\"[WORKER] Unhandled promise rejection:\", event.reason);\n  }\n  \n  event.preventDefault();\n});\n\n// Listen for messages to set up the event port and initialize kernel\nself.addEventListener(\"message\", (event) => {\n  if (event.data?.type === \"SET_EVENT_PORT\" && event.data?.port) {\n    // Clean up old event listeners and port before setting up new ones\n    cleanupEventForwarding();\n    \n    // Set the new port\n    eventPort = event.data.port;\n    \n    // If the kernel is already initialized, set up event forwarding immediately\n    if (kernel.isInitialized()) {\n      setupEventForwarding();\n    }\n  } else if (event.data?.type === \"INITIALIZE_KERNEL\") {\n    // Save the options for kernel initialization\n    kernelOptions = event.data.options || {};\n    \n    // Initialize the kernel with the provided options\n    initializeKernel(kernelOptions).catch(error => {\n      console.error(\"[WORKER] Error initializing kernel in worker:\", error);\n      if (eventPort) {\n        eventPort.postMessage({\n          type: KernelEvents.EXECUTE_ERROR,\n          data: {\n            ename: \"WorkerInitError\",\n            evalue: `Failed to initialize kernel: ${error.message}`,\n            traceback: [error.stack || \"\"]\n          }\n        });\n      }\n    });\n  } else if (event.data?.type === \"SET_INTERRUPT_BUFFER\") {\n    // Handle interrupt buffer setup\n    interruptBuffer = event.data.buffer;\n    \n    // Set the interrupt buffer in the kernel if it's initialized\n    if (kernel.isInitialized() && interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n      kernel.setInterruptBuffer(interruptBuffer);\n      console.log(\"[WORKER] Interrupt buffer set in pyodide kernel\");\n    } else if (interruptBuffer) {\n      console.log(\"[WORKER] Interrupt buffer stored, will be set when kernel initializes\");\n    }\n    \n    const responseMessage = {\n      type: \"INTERRUPT_BUFFER_SET\",\n      data: { success: true }\n    };\n    \n    // Send response on both channels to ensure it's received\n    if (eventPort) {\n      eventPort.postMessage(responseMessage);\n    }\n    \n    // Also send on main worker channel in case eventPort isn't set up yet\n    self.postMessage(responseMessage);\n    \n  } else if (event.data?.type === \"INTERRUPT_KERNEL\") {\n    // Handle interrupt request\n    \n    if (interruptBuffer) {\n      // Set interrupt signal (2 = SIGINT)\n      interruptBuffer[0] = 2;\n      \n      const responseMessage = {\n        type: \"INTERRUPT_TRIGGERED\",\n        data: { success: true, method: \"buffer\" }\n      };\n      \n      // Send response on both channels\n      if (eventPort) {\n        eventPort.postMessage(responseMessage);\n      }\n      self.postMessage(responseMessage);\n      \n    } else {\n      console.log(\"[WORKER] No interrupt buffer available, trying kernel.interrupt()\");\n      \n      // Fallback to kernel interrupt method\n      if (typeof kernel.interrupt === 'function') {\n        kernel.interrupt().then(success => {\n          const responseMessage = {\n            type: \"INTERRUPT_TRIGGERED\",\n            data: { success, method: \"kernel\" }\n          };\n          \n          if (eventPort) {\n            eventPort.postMessage(responseMessage);\n          }\n          self.postMessage(responseMessage);\n        }).catch(error => {\n          console.error(\"[WORKER] Error during kernel interrupt:\", error);\n          const responseMessage = {\n            type: \"INTERRUPT_TRIGGERED\",\n            data: { success: false, error: error.message, method: \"kernel\" }\n          };\n          \n          if (eventPort) {\n            eventPort.postMessage(responseMessage);\n          }\n          self.postMessage(responseMessage);\n        });\n      } else {\n        console.warn(\"[WORKER] No interrupt method available\");\n        const responseMessage = {\n          type: \"INTERRUPT_TRIGGERED\",\n          data: { success: false, error: \"No interrupt method available\", method: \"none\" }\n        };\n        \n        if (eventPort) {\n          eventPort.postMessage(responseMessage);\n        }\n        self.postMessage(responseMessage);\n      }\n    }\n  }\n});\n\n// Initialize the kernel with provided options\nasync function initializeKernel(options: IKernelOptions): Promise<void> {\n  try {\n    await kernel.initialize(options);\n    \n    // Set up the interrupt buffer if it's available and the kernel supports it\n    if (interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n      kernel.setInterruptBuffer(interruptBuffer);\n    }\n    \n    // Set up event forwarding AFTER kernel is initialized\n    setupEventForwarding();\n    \n    if (eventPort) {\n      eventPort.postMessage({\n        type: \"KERNEL_INITIALIZED\",\n        data: { success: true }\n      });\n    }\n  } catch (error) {\n    console.error(\"Kernel initialization failed:\", error);\n    throw error;\n  }\n}\n\n// Clean up old event listeners and port\nfunction cleanupEventForwarding() {\n  if (currentEventListeners.size > 0) {\n    // Remove all current event listeners\n    for (const [eventType, listener] of currentEventListeners.entries()) {\n      (kernel as unknown as EventEmitter).off(eventType, listener);\n    }\n    \n    // Clear the listeners map\n    currentEventListeners.clear();\n  }\n  \n  // Close the old port if it exists\n  if (eventPort) {\n    eventPort.close();\n    eventPort = null;\n  }\n}\n\n// Set up event forwarding from kernel to main thread\nfunction setupEventForwarding() {\n  if (!eventPort) {\n    console.error(\"[WORKER] Cannot set up event forwarding: no event port available\");\n    return;\n  }\n\n  // Forward all kernel events to the main thread\n  Object.values(KernelEvents).forEach((eventType) => {\n    // Create a listener function for this event type\n    const listener = (data: any) => {\n      if (eventPort) {\n        // Send just the event type and raw data\n        // This matches the structure used in main thread mode\n        eventPort.postMessage({\n          type: eventType,\n          data: data\n        });\n      }\n    };\n    \n    // Store the listener for later cleanup\n    currentEventListeners.set(eventType, listener);\n    \n    // Add the listener to the kernel\n    (kernel as unknown as EventEmitter).on(eventType, listener);\n  });\n}\n\n// Handle cleanup when worker is terminated\nself.addEventListener(\"beforeunload\", async () => {\n  // Close any resources or connections\n  try {\n    // Send a final message before termination if needed\n    if (eventPort) {\n      eventPort.postMessage({\n        type: \"WORKER_TERMINATING\",\n        data: { message: \"Worker is shutting down\" }\n      });\n    }\n  } catch (error) {\n    console.error(\"Error during worker cleanup:\", error);\n  }\n});\n\n// Log available methods for debugging\n\n// Create a simplified proxy that only exposes the methods we need\n// We're not trying to implement the full EventEmitter interface\nconst simpleProxy = {\n  // Required methods from IKernel interface\n  initialize: async (options?: IKernelOptions) => {\n    try {\n      await kernel.initialize(options);\n      return undefined;\n    } catch (error) {\n      console.error(\"[WORKER] Initialize error:\", error);\n      throw error;\n    }\n  },\n  \n  execute: async (code: string, parent?: any) => {\n    try {\n      const result = await kernel.execute(code, parent);\n      return result;\n    } catch (error) {\n      console.error(\"[WORKER] Execute error:\", error);\n      \n      // Check if this is a KeyboardInterrupt and handle it specially\n      if (isKeyboardInterrupt(error)) {\n        console.log(\"[WORKER] KeyboardInterrupt caught in execute method\");\n        return createKeyboardInterruptResult();\n      }\n      \n      // Handle other errors normally\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        result: {\n          payload: [],\n          status: \"error\",\n          ename: error instanceof Error ? error.constructor.name : \"Error\",\n          evalue: error instanceof Error ? error.message : String(error),\n          traceback: error instanceof Error && error.stack ? error.stack.split('\\n') : [String(error)]\n        }\n      };\n    }\n  },\n  \n  isInitialized: () => {\n    try {\n      const result = kernel.isInitialized();\n      return result;\n    } catch (error) {\n      console.error(\"[WORKER] IsInitialized error:\", error);\n      return false;\n    }\n  },\n  \n  inputReply: async (content: { value: string }) => {\n    try {\n      await kernel.inputReply(content);\n    } catch (error) {\n      console.error(\"[WORKER] InputReply error:\", error);\n      throw error;\n    }\n  },\n  \n  // Async method for status\n  getStatus: async () => {\n    try {\n      const status = await kernel.getStatus();\n      return status;\n    } catch (error) {\n      console.error(\"[WORKER] getStatus error:\", error);\n      return \"unknown\";\n    }\n  },\n  \n  // Interrupt functionality\n  interrupt: async () => {\n    try {\n      if (typeof kernel.interrupt === 'function') {\n        const result = await kernel.interrupt();\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support interrupt method\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"[WORKER] Interrupt error:\", error);\n      // Don't let interrupt errors crash the worker\n      return false;\n    }\n  },\n  \n  setInterruptBuffer: (buffer: Uint8Array) => {\n    try {\n      if (typeof kernel.setInterruptBuffer === 'function') {\n        kernel.setInterruptBuffer(buffer);\n        return true;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support setInterruptBuffer method\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"[WORKER] setInterruptBuffer error:\", error);\n      return false;\n    }\n  },\n  \n  // Completion methods\n  complete: async (code: string, cursor_pos: number, parent?: any) => {\n    try {\n      if (typeof kernel.complete === 'function') {\n        const result = await kernel.complete(code, cursor_pos, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support complete method\");\n        return { status: 'error', error: 'Completion not supported' };\n      }\n    } catch (error) {\n      console.error(\"[WORKER] Complete error:\", error);\n      return { status: 'error', error: String(error) };\n    }\n  },\n  \n  inspect: async (code: string, cursor_pos: number, detail_level: 0 | 1, parent?: any) => {\n    try {\n      if (typeof kernel.inspect === 'function') {\n        const result = await kernel.inspect(code, cursor_pos, detail_level, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support inspect method\");\n        return { status: 'error', error: 'Inspection not supported' };\n      }\n    } catch (error) {\n      console.error(\"[WORKER] Inspect error:\", error);\n      return { status: 'error', error: String(error) };\n    }\n  },\n  \n  isComplete: async (code: string, parent?: any) => {\n    try {\n      if (typeof kernel.isComplete === 'function') {\n        const result = await kernel.isComplete(code, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support isComplete method\");\n        return { status: 'unknown' };\n      }\n    } catch (error) {\n      console.error(\"[WORKER] IsComplete error:\", error);\n      return { status: 'error', error: String(error) };\n    }\n  },\n\n  // Native filesystem mounting\n  mountFS: async (mountPath: string, dirHandle?: FileSystemDirectoryHandle | null, permission?: 'read' | 'readwrite') => {\n    try {\n      if (typeof kernel.mountFS === 'function') {\n        // In worker context, dirHandle must be provided - we cannot show directory picker\n        if (!dirHandle) {\n          throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter when calling mountFS on a worker kernel.\");\n        }\n        const result = await kernel.mountFS(mountPath, dirHandle, permission);\n        // Wrap the result with Comlink.proxy so the syncfs function can be called across worker boundary\n        return Comlink.proxy(result);\n      } else {\n        console.warn(\"[WORKER] Kernel does not support mountFS method\");\n        throw new Error(\"mountFS is not supported by this kernel\");\n      }\n    } catch (error) {\n      console.error(\"[WORKER] MountFS error:\", error);\n      throw error;\n    }\n  },\n\n  getMountedFileSystems: async () => {\n    try {\n      if (typeof kernel.getMountedFileSystems === 'function') {\n        const result = kernel.getMountedFileSystems();\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support getMountedFileSystems method\");\n        return [];\n      }\n    } catch (error) {\n      console.error(\"[WORKER] getMountedFileSystems error:\", error);\n      return [];\n    }\n  },\n\n  syncFileSystem: async (mountPath: string) => {\n    try {\n      if (typeof kernel.syncFileSystem === 'function') {\n        const result = await kernel.syncFileSystem(mountPath);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support syncFileSystem method\");\n        return { success: false, error: 'syncFileSystem is not supported by this kernel' };\n      }\n    } catch (error) {\n      console.error(\"[WORKER] syncFileSystem error:\", error);\n      return { success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  },\n\n  upgradeFileSystemPermission: async (mountPath: string) => {\n    try {\n      if (typeof kernel.upgradeFileSystemPermission === 'function') {\n        const result = await kernel.upgradeFileSystemPermission(mountPath);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support upgradeFileSystemPermission method\");\n        return { success: false, error: 'upgradeFileSystemPermission is not supported by this kernel' };\n      }\n    } catch (error) {\n      console.error(\"[WORKER] upgradeFileSystemPermission error:\", error);\n      return { success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  },\n\n  // Comm methods\n  commInfo: async (target_name: string | null, parent?: any) => {\n    try {\n      if (typeof kernel.commInfo === 'function') {\n        const result = await kernel.commInfo(target_name, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support commInfo method\");\n        return { comms: {}, status: 'ok' };\n      }\n    } catch (error) {\n      console.error(\"[WORKER] CommInfo error:\", error);\n      return { comms: {}, status: 'error', error: String(error) };\n    }\n  },\n  \n  commOpen: async (content: any, parent?: any) => {\n    try {\n      if (typeof kernel.commOpen === 'function') {\n        const result = await kernel.commOpen(content, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support commOpen method\");\n        return undefined;\n      }\n    } catch (error) {\n      console.error(\"[WORKER] CommOpen error:\", error);\n      return undefined;\n    }\n  },\n  \n  commMsg: async (content: any, parent?: any) => {\n    try {\n      if (typeof kernel.commMsg === 'function') {\n        const result = await kernel.commMsg(content, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support commMsg method\");\n        return undefined;\n      }\n    } catch (error) {\n      console.error(\"[WORKER] CommMsg error:\", error);\n      return undefined;\n    }\n  },\n  \n  commClose: async (content: any, parent?: any) => {\n    try {\n      if (typeof kernel.commClose === 'function') {\n        const result = await kernel.commClose(content, parent);\n        return result;\n      } else {\n        console.warn(\"[WORKER] Kernel does not support commClose method\");\n        return undefined;\n      }\n    } catch (error) {\n      console.error(\"[WORKER] CommClose error:\", error);\n      return undefined;\n    }\n  }\n};\n\n// Expose the proxy through Comlink\ntry {\n  Comlink.expose(simpleProxy);\n} catch (error) {\n  console.error(\"Error exposing proxy:\", error);\n} "],"names":["proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","message","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","console","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","constructor","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","length","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","prototype","concat","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","PYODIDE_CDN_URL","pyodideLoaded","pyodideLoadPromise","KernelMode","KernelLanguage","events","on","eventName","listener","this","push","off","index","indexOf","splice","emit","args","forEach","setMaxListeners","n","Kernel","super","initialized","initPromise","filesystemOptions","enabled","root","mountPoint","_resolveInputReply","_parent_header","executionCount","_status","_interruptBuffer","_interruptSupported","environmentVariables","nativeFsHandles","autoSyncFs","kernelId","substring","Date","now","getStatus","initialize","options","filesystem","env","lockFileURL","_initializeInternal","startTime","log","pyodideStartTime","pyodideConfig","pyodide","async","config","importScripts","reject","loadPyodide","script","document","createElement","src","onload","onerror","head","appendChild","globalLoadPyodide","defaultConfig","indexURL","pyodideTime","all","mountFileSystem","setEnvironmentVariables","initGlobals","initPackageManager","initKernel","totalTime","FS","mount","filesystems","NODEFS","mountedFiles","readdir","baseUrl","loadPackage","window","location","URL","href","self","allJsonPath","wheelFiles","wheelPromises","wheelUrl","wheelStartTime","runPythonAsync","wheelTime","success","time","wheelResults","successful","filter","failed","f","packageConfig","priority","source","installPackagesWithIntelligentOptimization","importStartTime","importTime","installPromises","pkg","installViaPipWithOptimizations","duration","package","method","pyodideError","results","analyzeInstallationResults","packageName","pyodideInstalls","pipInstalls","fallbackInstalls","totalDuration","max","avgDuration","sum","estimatedSequential","round","fastestInstall","min","slowestInstall","globals","_kernel","kernel_instance","copy","_stdout_stream","stdout_stream","_stderr_stream","stderr_stream","_interpreter","interpreter","send_comm","sendComm","setupCallbacks","publishStreamCallback","text","bundle","formatResult","_sendMessage","parentHeader","publish_stream_callback","display_pub","clear_output_callback","wait","display_data_callback","metadata","transient","update_display_data_callback","displayhook","publish_execution_result","prompt_count","execution_count","input","getpass","_processMessage","eventData","STREAM","content","prompt","password","INPUT_REQUEST","DISPLAY_DATA","UPDATE_DISPLAY_DATA","CLEAR_OUTPUT","EXECUTE_RESULT","ename","evalue","traceback","EXECUTE_ERROR","buffers","ALL","isInitialized","setup","toPy","execute","code","outputs","output","executeStream","result","stdout","stderr","errorData","syncAllNativeFs","String","res","ffi","PyProxy","m","toJs","mapToObject","status","out","key","inputReply","sendInputRequest","replyPromise","ident","complete","cursor_pos","inspect","detail_level","isComplete","is_complete","commInfo","target_name","comm_info","comms","commOpen","comm_manager","comm_open","commMsg","comm_msg","commClose","comm_close","KERNEL_BUSY","eventQueue","executionComplete","executionResult","executionError","handleAllEvents","run","setTimeout","event","shift","KERNEL_IDLE","errorMsg","interrupt","pythonError","setInterruptBuffer","buffer","verifyPermission","fileHandle","permission","opts","mode","queryPermission","queryResult","requestPermission","requestResult","requestError","mountFS","mountPath","dirHandle","mountNativeFS","handle","WorkerGlobalScope","showDirectoryPicker","actualPermission","analyzePath","exists","unmount","unmountError","rmdir","rmdirError","analyzeError","parentPath","lastIndexOf","mkdir","parentError","nativefs","fsHandle","syncfs","size","syncResults","entries","errorMessage","includes","newNativefs","syncError","recoveryError","recoveryMessage","skipped","parts","getMountedFileSystems","canSync","syncFileSystem","upgradeFileSystemPermission","keys","processedValue","JSON","stringify","KernelEvents","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","o","defineProperty","enumerable","hasOwnProperty","call","kernel","eventPort","kernelOptions","currentEventListeners","interruptBuffer","isKeyboardInterrupt","setupEventForwarding","values","eventType","preventDefault","reason","cleanupEventForwarding","initializeKernel","responseMessage","simpleProxy","payload","split"],"sourceRoot":""}