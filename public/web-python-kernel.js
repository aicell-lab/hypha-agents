/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebPythonKernel"] = factory();
	else
		root["WebPythonKernel"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* unused harmony exports createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint */\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLGtCQUFrQixVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELGdCQUFnQixJQUFJO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5REFBeUQsZ0JBQWdCLElBQUk7QUFDN0UsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUk7QUFDakkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcz8yNzk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKFwiQ29tbGluay5wcm94eVwiKTtcbmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKFwiQ29tbGluay5lbmRwb2ludFwiKTtcbmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbChcIkNvbWxpbmsucmVsZWFzZVByb3h5XCIpO1xuY29uc3QgZmluYWxpemVyID0gU3ltYm9sKFwiQ29tbGluay5maW5hbGl6ZXJcIik7XG5jb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsudGhyb3duXCIpO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHx8IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlIHRvIGhhbmRsZSBvYmplY3RzIG1hcmtlZCB0byBwcm94eS5cbiAqL1xuY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sXG4gICAgc2VyaWFsaXplKG9iaikge1xuICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGV4cG9zZShvYmosIHBvcnQxKTtcbiAgICAgICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZShwb3J0KSB7XG4gICAgICAgIHBvcnQuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHdyYXAocG9ydCk7XG4gICAgfSxcbn07XG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZXIgdG8gaGFuZGxlIHRocm93biBleGNlcHRpb25zLlxuICovXG5jb25zdCB0aHJvd1RyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHRocm93TWFya2VyIGluIHZhbHVlLFxuICAgIHNlcmlhbGl6ZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0ge1xuICAgICAgICAgICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzZXJpYWxpemVkLCBbXV07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHNlcmlhbGl6ZWQudmFsdWUubWVzc2FnZSksIHNlcmlhbGl6ZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHNlcmlhbGl6ZWQudmFsdWU7XG4gICAgfSxcbn07XG4vKipcbiAqIEFsbG93cyBjdXN0b21pemluZyB0aGUgc2VyaWFsaXphdGlvbiBvZiBjZXJ0YWluIHZhbHVlcy5cbiAqL1xuY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IG5ldyBNYXAoW1xuICAgIFtcInByb3h5XCIsIHByb3h5VHJhbnNmZXJIYW5kbGVyXSxcbiAgICBbXCJ0aHJvd1wiLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0sXG5dKTtcbmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7XG4gICAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7XG4gICAgICAgIGlmIChvcmlnaW4gPT09IGFsbG93ZWRPcmlnaW4gfHwgYWxsb3dlZE9yaWdpbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBleHBvc2Uob2JqLCBlcCA9IGdsb2JhbFRoaXMsIGFsbG93ZWRPcmlnaW5zID0gW1wiKlwiXSkge1xuICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7XG4gICAgICAgIGlmICghZXYgfHwgIWV2LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgZXYub3JpZ2luKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIG9yaWdpbiAnJHtldi5vcmlnaW59JyBmb3IgY29tbGluayBwcm94eWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIHR5cGUsIHBhdGggfSA9IE9iamVjdC5hc3NpZ24oeyBwYXRoOiBbXSB9LCBldi5kYXRhKTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2xpY2UoMCwgLTEpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHBhdGgucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHRVRcIiAvKiBNZXNzYWdlVHlwZS5HRVQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlNFVFwiIC8qIE1lc3NhZ2VUeXBlLlNFVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50W3BhdGguc2xpY2UoLTEpWzBdXSA9IGZyb21XaXJlVmFsdWUoZXYuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFQUExZXCIgLyogTWVzc2FnZVR5cGUuQVBQTFkgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWUuYXBwbHkocGFyZW50LCBhcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb3h5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpXG4gICAgICAgICAgICAuY2F0Y2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJldHVyblZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGRldGFjaCBhbmQgZGVhY3RpdmUgYWZ0ZXIgc2VuZGluZyByZWxlYXNlIHJlc3BvbnNlIGFib3ZlLlxuICAgICAgICAgICAgICAgIGVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmluYWxpemVyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFNlbmQgU2VyaWFsaXphdGlvbiBFcnJvciBUbyBDYWxsZXJcbiAgICAgICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVHlwZUVycm9yKFwiVW5zZXJpYWxpemFibGUgcmV0dXJuIHZhbHVlXCIpLFxuICAgICAgICAgICAgICAgIFt0aHJvd01hcmtlcl06IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgICBlcC5zdGFydCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHtcbiAgICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJNZXNzYWdlUG9ydFwiO1xufVxuZnVuY3Rpb24gY2xvc2VFbmRQb2ludChlbmRwb2ludCkge1xuICAgIGlmIChpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSlcbiAgICAgICAgZW5kcG9pbnQuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIHdyYXAoZXAsIHRhcmdldCkge1xuICAgIGNvbnN0IHBlbmRpbmdMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGV2O1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5kZWxldGUoZGF0YS5pZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIFtdLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkge1xuICAgIGlmIChpc1JlbGVhc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHtcbiAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgbmV3IE1hcCgpLCB7XG4gICAgICAgIHR5cGU6IFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi8sXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgIH0pO1xufVxuY29uc3QgcHJveHlDb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHByb3h5RmluYWxpemVycyA9IFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIiBpbiBnbG9iYWxUaGlzICYmXG4gICAgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChlcCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7XG4gICAgICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICAgICAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICB9XG4gICAgfSk7XG5mdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5LCBlcCkge1xuICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApICsgMTtcbiAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gICAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgICAgICBwcm94eUZpbmFsaXplcnMucmVnaXN0ZXIocHJveHksIGVwLCBwcm94eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5yZWdpc3RlclByb3h5KHByb3h5KSB7XG4gICAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgICAgICBwcm94eUZpbmFsaXplcnMudW5yZWdpc3Rlcihwcm94eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24gKCkgeyB9KSB7XG4gICAgbGV0IGlzUHJveHlSZWxlYXNlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSByZWxlYXNlUHJveHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkpO1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJveHlSZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSBcInRoZW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0aGVuOiAoKSA9PiBwcm94eSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiIC8qIE1lc3NhZ2VUeXBlLkdFVCAqLyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIFsuLi5wYXRoLCBwcm9wXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBFUzYgUHJveHkgSGFuZGxlciBgc2V0YCBtZXRob2RzIGFyZSBzdXBwb3NlZCB0byByZXR1cm4gYVxuICAgICAgICAgICAgLy8gYm9vbGVhbi4gVG8gc2hvdyBnb29kIHdpbGwsIHdlIHJldHVybiB0cnVlIGFzeW5jaHJvbm91c2x5IMKvXFxfKOODhClfL8KvXG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlNFVFwiIC8qIE1lc3NhZ2VUeXBlLlNFVCAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbLi4ucGF0aCwgcHJvcF0ubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwbHkoX3RhcmdldCwgX3RoaXNBcmcsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gY3JlYXRlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkVORFBPSU5UXCIgLyogTWVzc2FnZVR5cGUuRU5EUE9JTlQgKi8sXG4gICAgICAgICAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGp1c3QgcHJldGVuZCB0aGF0IGBiaW5kKClgIGRpZG7igJl0IGhhcHBlbi5cbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBcImJpbmRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQVBQTFlcIiAvKiBNZXNzYWdlVHlwZS5BUFBMWSAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQ09OU1RSVUNUXCIgLyogTWVzc2FnZVR5cGUuQ09OU1RSVUNUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJQcm94eShwcm94eSwgZXApO1xuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIG15RmxhdChhcnIpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NBcmd1bWVudHMoYXJndW1lbnRMaXN0KSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gYXJndW1lbnRMaXN0Lm1hcCh0b1dpcmVWYWx1ZSk7XG4gICAgcmV0dXJuIFtwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzBdKSwgbXlGbGF0KHByb2Nlc3NlZC5tYXAoKHYpID0+IHZbMV0pKV07XG59XG5jb25zdCB0cmFuc2ZlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7XG4gICAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBwcm94eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIHsgW3Byb3h5TWFya2VyXTogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIHdpbmRvd0VuZHBvaW50KHcsIGNvbnRleHQgPSBnbG9iYWxUaGlzLCB0YXJnZXRPcmlnaW4gPSBcIipcIikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RNZXNzYWdlOiAobXNnLCB0cmFuc2ZlcmFibGVzKSA9PiB3LnBvc3RNZXNzYWdlKG1zZywgdGFyZ2V0T3JpZ2luLCB0cmFuc2ZlcmFibGVzKSxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogY29udGV4dC5hZGRFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1dpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIGhhbmRsZXJdIG9mIHRyYW5zZmVySGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIuY2FuSGFuZGxlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgW3NlcmlhbGl6ZWRWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSBoYW5kbGVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJIQU5ETEVSXCIgLyogV2lyZVZhbHVlVHlwZS5IQU5ETEVSICovLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlckNhY2hlLmdldCh2YWx1ZSkgfHwgW10sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGZyb21XaXJlVmFsdWUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmZXJIYW5kbGVycy5nZXQodmFsdWUubmFtZSkuZGVzZXJpYWxpemUodmFsdWUudmFsdWUpO1xuICAgICAgICBjYXNlIFwiUkFXXCIgLyogV2lyZVZhbHVlVHlwZS5SQVcgKi86XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgbXNnLCB0cmFuc2ZlcnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpO1xuICAgICAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IGlkIH0sIG1zZyksIHRyYW5zZmVycyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheSg0KVxuICAgICAgICAuZmlsbCgwKVxuICAgICAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW5kcG9pbnQsIGV4cG9zZSwgZmluYWxpemVyLCBwcm94eSwgcHJveHlNYXJrZXIsIHJlbGVhc2VQcm94eSwgdHJhbnNmZXIsIHRyYW5zZmVySGFuZGxlcnMsIHdpbmRvd0VuZHBvaW50LCB3cmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21saW5rLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n\n}");

/***/ }),

/***/ "./src/_pypi.ts":
/*!**********************!*\
  !*** ./src/_pypi.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allJSONUrl: () => (/* binding */ allJSONUrl),\n/* harmony export */   ipykernelWheelUrl: () => (/* binding */ ipykernelWheelUrl),\n/* harmony export */   pipliteWheelUrl: () => (/* binding */ pipliteWheelUrl),\n/* harmony export */   pyodide_kernelWheelUrl: () => (/* binding */ pyodide_kernelWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl: () => (/* binding */ widgetsnbextensionWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl1: () => (/* binding */ widgetsnbextensionWheelUrl1)\n/* harmony export */ });\n// this file is autogenerated from the wheels in the pypi directory\nconst allJSONUrl = \"pypi/all.json\";\nconst ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nconst pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nconst pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvX3B5cGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFDNUQsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDO0FBQ25DLE1BQU0saUJBQWlCLEdBQUcsdUNBQXVDLENBQUM7QUFDbEUsTUFBTSxlQUFlLEdBQUcsdUNBQXVDLENBQUM7QUFDaEUsTUFBTSxzQkFBc0IsR0FBRyw4Q0FBOEMsQ0FBQztBQUM5RSxNQUFNLDBCQUEwQixHQUFHLGtEQUFrRCxDQUFDO0FBQ3RGLE1BQU0sMkJBQTJCLEdBQUcsa0RBQWtELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9zcmMvX3B5cGkudHM/ZTg2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIGZpbGUgaXMgYXV0b2dlbmVyYXRlZCBmcm9tIHRoZSB3aGVlbHMgaW4gdGhlIHB5cGkgZGlyZWN0b3J5XG5leHBvcnQgY29uc3QgYWxsSlNPTlVybCA9IFwicHlwaS9hbGwuanNvblwiO1xuZXhwb3J0IGNvbnN0IGlweWtlcm5lbFdoZWVsVXJsID0gXCJweXBpL2lweWtlcm5lbC02LjkuMi1weTMtbm9uZS1hbnkud2hsXCI7XG5leHBvcnQgY29uc3QgcGlwbGl0ZVdoZWVsVXJsID0gXCJweXBpL3BpcGxpdGUtMC42LjBhNS1weTMtbm9uZS1hbnkud2hsXCI7XG5leHBvcnQgY29uc3QgcHlvZGlkZV9rZXJuZWxXaGVlbFVybCA9IFwicHlwaS9weW9kaWRlX2tlcm5lbC0wLjYuMGE1LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybCA9IFwicHlwaS93aWRnZXRzbmJleHRlbnNpb24tMy42Ljk5OS1weTMtbm9uZS1hbnkud2hsXCI7XG5leHBvcnQgY29uc3Qgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwxID0gXCJweXBpL3dpZGdldHNuYmV4dGVuc2lvbi00LjAuOTk5LXB5My1ub25lLWFueS53aGxcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/_pypi.ts\n\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kernel: () => (/* binding */ Kernel),\n/* harmony export */   KernelEvents: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents),\n/* harmony export */   KernelLanguage: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelLanguage),\n/* harmony export */   KernelManager: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelManager),\n/* harmony export */   KernelMode: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelMode)\n/* harmony export */ });\n/* harmony import */ var _pyodide_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pyodide-loader */ \"./src/pyodide-loader.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _pypi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_pypi */ \"./src/_pypi.ts\");\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manager */ \"./src/manager.ts\");\n// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n// @ts-ignore Importing from npm\n\n// Import types and enums\n\n// Import PyPI URLs\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\n\n\nclass Kernel extends EventEmitter {\n    constructor() {\n        super();\n        this.initialized = false;\n        this.initPromise = null;\n        // FileSystem options\n        this.filesystemOptions = {\n            enabled: false,\n            root: \".\",\n            mountPoint: \"/home/pyodide\"\n        };\n        // Input handling\n        this._resolveInputReply = null;\n        // Execution state\n        this._parent_header = {};\n        this.executionCount = 0;\n        this._status = \"unknown\";\n        // Interrupt handling\n        this._interruptBuffer = null;\n        this._interruptSupported = false;\n        // Environment variables\n        this.environmentVariables = {};\n        // Native filesystem handles\n        this.nativeFsHandles = new Map();\n        this.autoSyncFs = false;\n        super.setMaxListeners(20);\n        // Generate a unique ID for this kernel instance\n        this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n    }\n    // Async method for kernel status\n    async getStatus() {\n        return this._status;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async initialize(options) {\n        if (this.initialized) {\n            return;\n        }\n        if (this.initPromise) {\n            return this.initPromise;\n        }\n        // Set filesystem options if provided\n        if (options?.filesystem) {\n            this.filesystemOptions = {\n                ...this.filesystemOptions,\n                ...options.filesystem\n            };\n        }\n        // Set environment variables if provided\n        if (options?.env) {\n            this.environmentVariables = { ...options.env };\n        }\n        // Set lockFileURL if provided\n        if (options?.lockFileURL) {\n            this.lockFileURL = options.lockFileURL;\n        }\n        // Set autoSyncFs if provided\n        if (options?.autoSyncFs !== undefined) {\n            this.autoSyncFs = options.autoSyncFs;\n        }\n        this.initPromise = this._initializeInternal();\n        return this.initPromise;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async _initializeInternal() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Starting optimized kernel initialization...\");\n        try {\n            // Load Pyodide from CDN\n            const pyodideStartTime = Date.now();\n            // Configure pyodide options\n            const pyodideConfig = {};\n            if (this.lockFileURL) {\n                pyodideConfig.lockFileURL = this.lockFileURL;\n                console.log(`ðŸ”’ Using lockFileURL: ${this.lockFileURL}`);\n            }\n            // Use our CDN loader - it will automatically handle main thread vs worker\n            this.pyodide = await (0,_pyodide_loader__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)(pyodideConfig);\n            const pyodideTime = Date.now() - pyodideStartTime;\n            console.log(`âœ… Pyodide loaded in ${pyodideTime}ms`);\n            // Initialize core components in parallel\n            if (this.lockFileURL) {\n                // When using lockFileURL, packages are pre-installed, skip package installation\n                console.log(\"ðŸš€ Using lock file - skipping package installation\");\n                const [,] = await Promise.all([\n                    // 1. FileSystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n                    // 2. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Initialize globals directly (packages are already available)\n                await this.initGlobals();\n            }\n            else {\n                // Standard initialization with package installation\n                const [, ,] = await Promise.all([\n                    // 1. FileSystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n                    // 2. Package manager initialization\n                    this.initPackageManager(),\n                    // 3. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Install packages and initialize globals\n                await this.initKernel();\n                await this.initGlobals();\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n            console.log(`âš¡ Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n            // Mark as initialized\n            this.initialized = true;\n            this._status = \"active\";\n            console.log(\"ðŸŸ¢ Kernel is now ACTIVE and ready for execution!\");\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel initialization failed:\", error);\n            this._status = \"unknown\";\n            throw error;\n        }\n    }\n    /**\n     * Mount the local filesystem to the Pyodide environment\n     */\n    async mountFileSystem() {\n        try {\n            console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n            // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n            // Simple and direct mounting of the filesystem\n            await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS, { root: this.filesystemOptions.root || \".\" }, this.filesystemOptions.mountPoint || \"/home/pyodide\");\n            console.log(\"FileSystem mounted successfully\");\n            // Verify the mount by listing the directory\n            try {\n                const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n                console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n            }\n            catch (error) {\n                console.error(`Error listing mounted directory: ${error}`);\n            }\n        }\n        catch (error) {\n            console.error(\"Error mounting filesystem:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the Pyodide package manager with optimized wheel loading\n     * OPTIMIZED: Smart caching and parallel wheel installation\n     */\n    async initPackageManager() {\n        const startTime = Date.now();\n        console.log(\"âš¡ Initializing optimized package manager...\");\n        try {\n            // Load micropip and packaging in parallel\n            console.log(\"ðŸ“¦ Loading micropip, packaging...\");\n            await this.pyodide.loadPackage(['micropip', 'packaging']);\n            console.log(\"âœ… Loaded micropip, packaging\");\n            // Get the base URL - use window.location for browser or fallback for worker\n            let baseUrl;\n            if (typeof window !== 'undefined' && window.location) {\n                // In main thread - use window.location\n                baseUrl = new URL(\".\", window.location.href).href;\n            }\n            else if (typeof self !== 'undefined' && self.location) {\n                // In web worker - use self.location\n                baseUrl = new URL(\".\", self.location.href).href;\n            }\n            else {\n                // Fallback - assume current origin\n                baseUrl = \"/\";\n            }\n            const allJsonPath = new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.allJSONUrl, baseUrl).href;\n            // Prepare all wheel URLs for parallel loading\n            const wheelFiles = [\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pipliteWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pyodide_kernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.ipykernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl1, baseUrl).href,\n            ];\n            console.log(`ðŸš€ Installing ${wheelFiles.length} wheel packages in parallel...`);\n            // Install all wheel packages in parallel for maximum speed\n            const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n                const wheelStartTime = Date.now();\n                try {\n                    await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\"âœ… Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.log(`âš¡ Wheel ${index + 1} installed in ${wheelTime}ms`);\n                    return { index, success: true, time: wheelTime };\n                }\n                catch (error) {\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.warn(`âš ï¸ Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n                    return { index, success: false, time: wheelTime, error };\n                }\n            });\n            // Wait for all wheel installations\n            const wheelResults = await Promise.all(wheelPromises);\n            const successful = wheelResults.filter(r => r.success);\n            const failed = wheelResults.filter(r => !r.success);\n            console.log(`ðŸ“Š Wheels: ${successful.length}/${wheelFiles.length} successful`);\n            if (failed.length > 0) {\n                console.warn(`âš ï¸ Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n            }\n            // Set up piplite configuration with performance optimizations (if available)\n            try {\n                await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\"ðŸ“‹ Package index configured\")\n    except Exception as e:\n        print(f\"âš ï¸ Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\"âš¡ Piplite optimized for performance\")\nexcept ImportError:\n    print(\"âš ï¸ Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\"âš ï¸ Piplite setup failed: {e}\")\n`);\n            }\n            catch (error) {\n                console.warn(\"âš ï¸ Piplite configuration failed, continuing without it:\", error);\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Package manager initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Package manager initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the kernel with required Python packages\n     * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n     */\n    async initKernel() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Initializing kernel packages with maximum optimization...\");\n        // All packages to install with priority and dependency information\n        const packageConfig = [\n            // High priority: CDN packages (fastest)\n            { name: 'pure-eval', priority: 1, source: 'pyodide' },\n            { name: 'stack-data', priority: 1, source: 'pyodide' },\n            { name: 'pygments', priority: 1, source: 'pyodide' },\n            { name: 'ssl', priority: 1, source: 'pyodide' },\n            { name: 'sqlite3', priority: 1, source: 'pyodide' },\n            { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n            { name: 'jedi', priority: 1, source: 'pyodide' },\n            { name: 'ipython', priority: 1, source: 'pyodide' },\n            // Medium priority: pip packages\n            { name: 'comm', priority: 2, source: 'pip' },\n            { name: 'hypha-rpc', priority: 2, source: 'pip' },\n            { name: 'nbformat', priority: 2, source: 'pip' },\n            // Lower priority: complex packages\n            { name: 'ipykernel', priority: 3, source: 'pip' },\n            { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n        ];\n        try {\n            console.log(`ðŸ“¦ Installing ${packageConfig.length} packages with intelligent optimization...`);\n            // Install ALL packages in parallel with advanced error handling and caching\n            await this.installPackagesWithIntelligentOptimization(packageConfig);\n            // Import the kernel (must be done after packages are installed)\n            console.log(\"ðŸ“¥ Importing pyodide_kernel...\");\n            const importStartTime = Date.now();\n            await this.pyodide.runPythonAsync('import pyodide_kernel');\n            const importTime = Date.now() - importStartTime;\n            console.log(`âœ… pyodide_kernel imported in ${importTime}ms`);\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Kernel packages initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel package initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Install packages with intelligent optimization and advanced caching\n     * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n     */\n    async installPackagesWithIntelligentOptimization(packageConfig) {\n        console.log(`âš¡ Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n        const installPromises = packageConfig.map(async (pkg) => {\n            const startTime = Date.now();\n            try {\n                console.log(`ðŸ”„ Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n                // Try preferred source first, with intelligent fallback\n                if (pkg.source === 'pyodide') {\n                    try {\n                        await this.pyodide.loadPackage([pkg.name]);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n                        return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n                    }\n                    catch (pyodideError) {\n                        // Fallback to pip with enhanced error handling\n                        console.log(`ðŸ“¦ ${pkg.name} not available on CDN, trying pip...`);\n                        await this.installViaPipWithOptimizations(pkg.name);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} installed via pip fallback (${duration}ms)`);\n                        return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n                    }\n                }\n                else {\n                    // Direct pip installation with optimizations\n                    await this.installViaPipWithOptimizations(pkg.name);\n                    const duration = Date.now() - startTime;\n                    console.log(`âœ… ${pkg.name} installed via pip (${duration}ms)`);\n                    return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n                }\n            }\n            catch (error) {\n                const duration = Date.now() - startTime;\n                console.warn(`âŒ Failed to install ${pkg.name} after ${duration}ms:`, error);\n                return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n            }\n        });\n        // Wait for all installations with detailed analysis\n        const results = await Promise.all(installPromises);\n        // Comprehensive performance analysis\n        this.analyzeInstallationResults(results);\n    }\n    /**\n     * Install package via pip with performance optimizations\n     */\n    async installViaPipWithOptimizations(packageName) {\n        await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\"âœ… Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\"âš ï¸ Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\"âœ… Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\"âŒ Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n    }\n    /**\n     * Analyze installation results and provide performance insights\n     */\n    analyzeInstallationResults(results) {\n        const successful = results.filter(r => r.success);\n        const failed = results.filter(r => !r.success);\n        const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n        const pipInstalls = successful.filter(r => r.method === 'pip');\n        const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n        const totalDuration = Math.max(...results.map(r => r.duration));\n        const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n        const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n        console.log(`ðŸŽ¯ INTELLIGENT INSTALLATION COMPLETE!`);\n        console.log(`ðŸ“Š Results: ${successful.length}/${results.length} successful`);\n        console.log(`âš¡ Pyodide CDN: ${pyodideInstalls.length} packages`);\n        console.log(`ðŸ“¦ Direct pip: ${pipInstalls.length} packages`);\n        console.log(`ðŸ”„ Pip fallback: ${fallbackInstalls.length} packages`);\n        console.log(`âŒ Failed: ${failed.length} packages`);\n        console.log(`â±ï¸  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n        console.log(`ðŸš€ Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n        console.log(`ðŸ“ˆ Average per package: ${Math.round(avgDuration)}ms`);\n        if (failed.length > 0) {\n            console.warn(`âš ï¸  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n            // Log specific failure reasons for debugging\n            failed.forEach(f => {\n                console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n            });\n        }\n        // Performance insights\n        const fastestInstall = Math.min(...successful.map(r => r.duration));\n        const slowestInstall = Math.max(...successful.map(r => r.duration));\n        console.log(`ðŸ“Š Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n    }\n    /**\n     * Initialize global objects from the pyodide_kernel package\n     * Based on the PyodideRemoteKernel implementation\n     */\n    async initGlobals() {\n        console.log(\"Initializing globals...\");\n        // Get the globals from the Python environment\n        const { globals } = this.pyodide;\n        // Get the kernel instance and related objects\n        this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n        this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n        this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n        this._interpreter = this._kernel.interpreter.copy();\n        // Set up communication handlers\n        this._interpreter.send_comm = this.sendComm.bind(this);\n        // Set up callbacks\n        this.setupCallbacks();\n    }\n    /**\n     * Setup all necessary callbacks for the Python environment\n     */\n    setupCallbacks() {\n        // Execution result callback\n        const publishExecutionResult = (prompt_count, data, metadata) => {\n            const bundle = {\n                execution_count: prompt_count,\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_result',\n            });\n        };\n        // Error callback\n        const publishExecutionError = (ename, evalue, traceback) => {\n            const bundle = {\n                ename: ename,\n                evalue: evalue,\n                traceback: traceback,\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_error',\n            });\n        };\n        // Clear output callback\n        const clearOutputCallback = (wait) => {\n            const bundle = {\n                wait: this.formatResult(wait),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'clear_output',\n            });\n        };\n        // Display data callback\n        const displayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'display_data',\n            });\n        };\n        // Update display data callback\n        const updateDisplayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'update_display_data',\n            });\n        };\n        // Stream callback\n        const publishStreamCallback = (name, text) => {\n            const bundle = {\n                name: this.formatResult(name),\n                text: this.formatResult(text),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'stream',\n            });\n        };\n        // Assign callbacks to the Python objects\n        this._stdout_stream.publish_stream_callback = publishStreamCallback;\n        this._stderr_stream.publish_stream_callback = publishStreamCallback;\n        this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n        this._interpreter.display_pub.display_data_callback = displayDataCallback;\n        this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n        this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n        this._interpreter.input = this.input.bind(this);\n        this._interpreter.getpass = this.getpass.bind(this);\n    }\n    /**\n     * Process a message from Python environment\n     */\n    _sendMessage(msg) {\n        this._processMessage(msg);\n    }\n    /**\n     * Process a message by emitting the appropriate event\n     */\n    _processMessage(msg) {\n        if (!msg.type) {\n            return;\n        }\n        let eventData;\n        switch (msg.type) {\n            case 'stream': {\n                const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'input_request': {\n                const content = msg.content ?? { prompt: '', password: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.INPUT_REQUEST, content);\n                eventData = content;\n                break;\n            }\n            case 'display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'update_display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'clear_output': {\n                const bundle = msg.bundle ?? { wait: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.CLEAR_OUTPUT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_result': {\n                const bundle = msg.bundle ?? {\n                    execution_count: this.executionCount,\n                    data: {},\n                    metadata: {},\n                };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_error': {\n                const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'comm_open':\n            case 'comm_msg':\n            case 'comm_close': {\n                const content = msg.content ?? {};\n                super.emit(msg.type, content, msg.metadata, msg.buffers);\n                eventData = {\n                    content,\n                    metadata: msg.metadata,\n                    buffers: msg.buffers\n                };\n                break;\n            }\n        }\n        // Emit the ALL event with standardized format\n        if (eventData) {\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, {\n                type: msg.type,\n                data: eventData\n            });\n        }\n    }\n    /**\n     * Check if the kernel has been initialized\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    /**\n     * Makes sure pyodide is ready before continuing, and cache the parent message.\n     */\n    async setup(parent) {\n        await this.initialize();\n        this._parent_header = this.pyodide.toPy(parent || {});\n    }\n    /**\n     * Execute code in the kernel with proper message-based completion detection\n     *\n     * @param code The code to execute\n     * @param parent Parent message header\n     * @returns The result of the execution\n     */\n    async execute(code, parent = {}) {\n        // Simple implementation that collects all outputs from executeStream\n        const outputs = [];\n        try {\n            // Use executeStream to get all outputs\n            for await (const output of this.executeStream(code, parent)) {\n                outputs.push(output);\n            }\n            // Process collected outputs to create a comprehensive result\n            const result = {\n                outputs: [],\n                data: {},\n                metadata: {},\n                execution_count: this.executionCount\n            };\n            // Collect all output types\n            for (const output of outputs) {\n                if (output.type === 'stream') {\n                    // Collect stdout/stderr\n                    if (!result.stdout)\n                        result.stdout = '';\n                    if (!result.stderr)\n                        result.stderr = '';\n                    if (output.data.name === 'stdout') {\n                        result.stdout += output.data.text;\n                    }\n                    else if (output.data.name === 'stderr') {\n                        result.stderr += output.data.text;\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'display_data' || output.type === 'execute_result') {\n                    // Collect display data\n                    if (output.data.data) {\n                        Object.assign(result.data, output.data.data);\n                    }\n                    if (output.data.metadata) {\n                        Object.assign(result.metadata, output.data.metadata);\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'execute_error' || output.type === 'error') {\n                    // Handle errors\n                    const errorData = output.data;\n                    return {\n                        success: false,\n                        error: new Error(`${errorData.ename}: ${errorData.evalue}`),\n                        ename: errorData.ename,\n                        evalue: errorData.evalue,\n                        traceback: errorData.traceback,\n                        outputs: result.outputs\n                    };\n                }\n                else {\n                    // Store any other output type\n                    result.outputs.push(output);\n                }\n            }\n            // Return collected results\n            result.success = true;\n            // Auto-sync native filesystems if enabled\n            if (this.autoSyncFs) {\n                await this.syncAllNativeFs();\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Execute error:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Format the result from the Pyodide evaluation\n     * Based on PyodideRemoteKernel implementation\n     */\n    formatResult(res) {\n        if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n            return res;\n        }\n        try {\n            // Convert PyProxy to JS\n            const m = res.toJs();\n            const results = this.mapToObject(m);\n            return results;\n        }\n        catch (error) {\n            console.error(\"Error formatting result:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    }\n    /**\n     * Convert a Map to a JavaScript object recursively\n     * Based on PyodideRemoteKernel implementation\n     */\n    mapToObject(obj) {\n        const out = obj instanceof Array ? [] : {};\n        obj.forEach((value, key) => {\n            out[key] =\n                value instanceof Map || value instanceof Array\n                    ? this.mapToObject(value)\n                    : value;\n        });\n        return out;\n    }\n    /**\n     * Handle input reply from user\n     */\n    async inputReply(content) {\n        if (this._resolveInputReply) {\n            this._resolveInputReply(content);\n            this._resolveInputReply = null;\n        }\n    }\n    /**\n     * Send a input request to the front-end.\n     */\n    async sendInputRequest(prompt, password) {\n        const content = {\n            prompt,\n            password,\n        };\n        this._sendMessage({\n            type: 'input_request',\n            content,\n            parentHeader: this.formatResult(this._parent_header)['header']\n        });\n    }\n    /**\n     * Get password input (with hidden input)\n     */\n    async getpass(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, true);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Get text input\n     */\n    async input(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, false);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Send a comm message to the front-end.\n     */\n    async sendComm(type, content, metadata, ident, buffers) {\n        this._sendMessage({\n            type: type,\n            content: this.formatResult(content),\n            metadata: this.formatResult(metadata),\n            ident: this.formatResult(ident),\n            buffers: this.formatResult(buffers),\n            parentHeader: this.formatResult(this._parent_header)['header'],\n        });\n    }\n    /**\n     * Complete the code submitted by a user.\n     */\n    async complete(code, cursor_pos, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.complete(code, cursor_pos);\n        return this.formatResult(res);\n    }\n    /**\n     * Inspect the code submitted by a user.\n     */\n    async inspect(code, cursor_pos, detail_level, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.inspect(code, cursor_pos, detail_level);\n        return this.formatResult(res);\n    }\n    /**\n     * Check code for completeness.\n     */\n    async isComplete(code, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.is_complete(code);\n        return this.formatResult(res);\n    }\n    /**\n     * Get information about available comms.\n     */\n    async commInfo(target_name, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_info(target_name);\n        return {\n            comms: this.formatResult(res),\n            status: 'ok',\n        };\n    }\n    /**\n     * Open a COMM\n     */\n    async commOpen(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_open(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Send a message through a COMM\n     */\n    async commMsg(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Close a COMM\n     */\n    async commClose(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_close(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Execute Python code with streaming output\n     * @param code The Python code to execute\n     * @param parent Parent message header\n     * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n     */\n    async *executeStream(code, parent = {}) {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        try {\n            this._status = \"busy\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_BUSY, {});\n            await this.setup(parent);\n            // Create event listeners for streaming\n            const eventQueue = [];\n            let executionComplete = false;\n            let executionResult = null;\n            let executionError = null;\n            const handleAllEvents = (eventData) => {\n                eventQueue.push(eventData);\n            };\n            // Listen for all events BEFORE executing code\n            super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            try {\n                // Execute the code directly\n                this._kernel.run(code).then((result) => {\n                    console.log(\"[KERNEL] Python execution finished\");\n                    executionResult = this.formatResult(result);\n                    // Check if the result indicates an error and emit it as an event\n                    if (executionResult && executionResult.status === 'error') {\n                        console.log(\"[KERNEL] Execution completed with error status, emitting execute_error event\");\n                        // Emit the error event so the UI can display it\n                        this._sendMessage({\n                            parentHeader: this.formatResult(this._parent_header)['header'],\n                            bundle: {\n                                ename: executionResult.ename || 'Error',\n                                evalue: executionResult.evalue || 'Unknown error',\n                                traceback: executionResult.traceback || []\n                            },\n                            type: 'execute_error',\n                        });\n                    }\n                    // Wait a small amount of time for any remaining messages to be processed\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100); // 100ms should be enough for message processing\n                }).catch((error) => {\n                    console.error(\"[KERNEL] Python execution error:\", error);\n                    executionError = error instanceof Error ? error : new Error(String(error));\n                    // Still wait for messages to settle before completing\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100);\n                });\n                // Stream events as they arrive\n                while (!executionComplete || eventQueue.length > 0) {\n                    // Yield queued events\n                    if (eventQueue.length > 0) {\n                        const event = eventQueue.shift();\n                        yield event;\n                    }\n                    else if (!executionComplete) {\n                        // Wait a bit for more events\n                        await new Promise(resolve => setTimeout(resolve, 10));\n                    }\n                }\n                // Process final result\n                this._status = \"active\";\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n                if (executionError) {\n                    return {\n                        success: false,\n                        error: executionError,\n                        result: executionResult\n                    };\n                }\n                // Check if result indicates an error\n                if (executionResult && executionResult.status === 'error') {\n                    const errorMsg = `${executionResult.ename || 'Error'}: ${executionResult.evalue || 'Unknown error'}`;\n                    return {\n                        success: false,\n                        error: new Error(errorMsg),\n                        result: executionResult\n                    };\n                }\n                // Auto-sync native filesystems if enabled\n                if (this.autoSyncFs) {\n                    await this.syncAllNativeFs();\n                }\n                return {\n                    success: true,\n                    result: executionResult\n                };\n            }\n            finally {\n                // Clean up listener\n                super.off(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] ExecuteStream error:\", error);\n            this._status = \"active\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    // Interrupt functionality\n    async interrupt() {\n        if (!this.initialized || !this.pyodide) {\n            console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n            return false;\n        }\n        console.log(\"[KERNEL] Attempting to interrupt execution...\");\n        try {\n            // First priority: Use interrupt buffer if available\n            if (this._interruptBuffer && this._interruptSupported) {\n                console.log(\"[KERNEL] Using interrupt buffer method\");\n                // Set interrupt signal (2 = SIGINT)\n                this._interruptBuffer[0] = 2;\n                // Give the interrupt a moment to be processed\n                await new Promise(resolve => setTimeout(resolve, 100));\n                // Check if the interrupt was processed (buffer should be reset to 0)\n                const wasProcessed = this._interruptBuffer[0] === 0;\n                if (wasProcessed) {\n                    console.log(\"[KERNEL] Interrupt processed successfully via buffer\");\n                    return true;\n                }\n            }\n            // Second priority: Try Python-level interrupt\n            try {\n                console.log(\"[KERNEL] Attempting Python-level interrupt\");\n                // Try to raise KeyboardInterrupt in Python\n                await this.pyodide.runPythonAsync(`\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n`);\n                console.log(\"[KERNEL] Python interrupt signal sent\");\n                return true;\n            }\n            catch (pythonError) {\n                console.log(\"[KERNEL] Python interrupt attempt failed:\", pythonError);\n            }\n            // Third priority: Try interpreter interrupt if available\n            if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n                console.log(\"[KERNEL] Using interpreter interrupt method\");\n                this._interpreter.interrupt();\n                return true;\n            }\n            // Last resort: Send interrupt messages for UI feedback\n            console.log(\"[KERNEL] Sending interrupt messages for UI feedback\");\n            // Send stderr stream first (for Jupyter notebook UI compatibility)\n            this._sendMessage({\n                type: 'stream',\n                bundle: {\n                    name: 'stderr',\n                    text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n                }\n            });\n            this._sendMessage({\n                type: 'execute_error',\n                bundle: {\n                    ename: 'KeyboardInterrupt',\n                    evalue: 'Execution interrupted by user',\n                    traceback: ['KeyboardInterrupt: Execution interrupted by user']\n                }\n            });\n            // Return false since we couldn't actually interrupt the execution\n            return false;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error during interrupt:\", error);\n            return false;\n        }\n    }\n    setInterruptBuffer(buffer) {\n        this._interruptBuffer = buffer;\n        try {\n            if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n                this.pyodide.setInterruptBuffer(buffer);\n                this._interruptSupported = true;\n            }\n            else {\n                console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n                this._interruptSupported = false;\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n            this._interruptSupported = false;\n        }\n    }\n    /**\n     * Verify and request permission for a file system handle\n     * @private\n     */\n    async verifyPermission(fileHandle, permission) {\n        const opts = {};\n        if (permission === 'readwrite') {\n            opts.mode = 'readwrite';\n        }\n        console.log(`[KERNEL] Verifying ${permission} permission for file handle...`);\n        // Check if permission APIs are supported\n        if (typeof fileHandle.queryPermission !== 'function') {\n            console.warn('[KERNEL] queryPermission not supported, assuming permission granted');\n            return true;\n        }\n        try {\n            // Check if we already have permission, if so, return true.\n            const queryResult = await fileHandle.queryPermission(opts);\n            console.log('[KERNEL] Query result:', queryResult);\n            if (queryResult === 'granted') {\n                console.log(`[KERNEL] Permission already granted for ${permission} access`);\n                return true;\n            }\n            // Request permission to the file, if the user grants permission, return true.\n            if (typeof fileHandle.requestPermission === 'function') {\n                console.log(`[KERNEL] Requesting ${permission} permission from user...`);\n                try {\n                    const requestResult = await fileHandle.requestPermission(opts);\n                    console.log('[KERNEL] Request result:', requestResult);\n                    if (requestResult === 'granted') {\n                        console.log(`[KERNEL] Permission granted for ${permission} access`);\n                        return true;\n                    }\n                }\n                catch (requestError) {\n                    console.log('[KERNEL] Permission request failed or was dismissed:', requestError);\n                }\n            }\n            // The user did not grant permission, return false.\n            console.log(`[KERNEL] ${permission} permission not granted`);\n            return false;\n        }\n        catch (error) {\n            console.error('[KERNEL] Error checking permission:', error);\n            // If permission check fails, assume it's granted (more permissive approach)\n            console.warn('[KERNEL] Permission check failed, assuming granted as fallback');\n            return true;\n        }\n    }\n    /**\n     * Mount a native file system directory into the Pyodide filesystem\n     * @param mountPath The path where the directory should be mounted in the Python filesystem\n     * @param dirHandle Optional FileSystemDirectoryHandle. If null/undefined, shows directory picker\n     * @param permission Permission mode:\n     *   - 'read': Read-only access, no syncing capabilities, auto-sync will be skipped (default)\n     *   - 'readwrite': Full read/write access with syncing capabilities\n     * @returns Promise resolving to a handle with syncfs() method for syncing changes\n     * @note syncfs() will throw an error if called on a read-only mounted filesystem\n     * @note Many browsers only offer read permission initially. Explicitly request 'readwrite' if you need write access.\n     */\n    async mountFS(mountPath, dirHandle, permission = 'read') {\n        if (!this.initialized || !this.pyodide) {\n            throw new Error(\"Kernel must be initialized before mounting filesystem\");\n        }\n        // Check if mountNativeFS is available\n        if (typeof this.pyodide.mountNativeFS !== 'function') {\n            throw new Error(\"pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.\");\n        }\n        let handle = dirHandle;\n        // If no dirHandle provided, show directory picker\n        if (!handle) {\n            // Check if we're in a worker context\n            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n                throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter.\");\n            }\n            // Check if showDirectoryPicker is available\n            if (typeof window !== 'undefined' && 'showDirectoryPicker' in window) {\n                try {\n                    handle = await window.showDirectoryPicker({\n                        mode: 'readwrite',\n                    });\n                }\n                catch (error) {\n                    throw new Error(`Failed to show directory picker: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            else {\n                throw new Error(\"showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.\");\n            }\n        }\n        if (!handle) {\n            throw new Error(\"No directory handle available\");\n        }\n        // Verify and request permissions before mounting\n        console.log(`[KERNEL] Verifying ${permission} permissions before mounting...`);\n        const hasRequestedPermission = await this.verifyPermission(handle, permission);\n        if (!hasRequestedPermission) {\n            if (permission === 'readwrite') {\n                throw new Error(`Failed to obtain write permission for directory. ` +\n                    `The browser may only be offering read permission. ` +\n                    `Try mounting with permission: 'read' if you only need to read files, ` +\n                    `or ensure the browser supports write access to this directory.`);\n            }\n            else {\n                throw new Error(`Failed to obtain ${permission} permission for directory.`);\n            }\n        }\n        const actualPermission = permission;\n        // Mount the native filesystem\n        try {\n            console.log(`[KERNEL] Mounting native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Check if the mount point already exists and handle cleanup\n            try {\n                const pathInfo = this.pyodide.FS.analyzePath(mountPath);\n                if (pathInfo.exists) {\n                    console.log(`[KERNEL] Path ${mountPath} exists, checking if it's a mount point`);\n                    // Try to unmount if it's already mounted\n                    try {\n                        await this.pyodide.FS.unmount(mountPath);\n                        console.log(`[KERNEL] Successfully unmounted existing filesystem at ${mountPath}`);\n                    }\n                    catch (unmountError) {\n                        // If unmount fails, it might not be a mount point or might be busy\n                        console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${unmountError}`);\n                    }\n                    // Remove the directory if it exists but is empty\n                    try {\n                        this.pyodide.FS.rmdir(mountPath);\n                        console.log(`[KERNEL] Removed existing directory at ${mountPath}`);\n                    }\n                    catch (rmdirError) {\n                        // Directory might not be empty or might not exist, that's okay\n                        console.log(`[KERNEL] Could not remove directory (this is normal): ${rmdirError}`);\n                    }\n                }\n            }\n            catch (analyzeError) {\n                // analyzePath might fail, that's okay - the path probably doesn't exist\n                console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${analyzeError}`);\n            }\n            // Ensure the parent directory exists\n            const parentPath = mountPath.substring(0, mountPath.lastIndexOf('/')) || '/';\n            try {\n                if (parentPath !== '/' && !this.pyodide.FS.analyzePath(parentPath).exists) {\n                    this.pyodide.FS.mkdir(parentPath);\n                    console.log(`[KERNEL] Created parent directory ${parentPath}`);\n                }\n            }\n            catch (parentError) {\n                console.log(`[KERNEL] Parent directory handling: ${parentError}`);\n            }\n            const nativefs = await this.pyodide.mountNativeFS(mountPath, handle);\n            console.log(`[KERNEL] Successfully mounted native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Create a handle with syncfs method and permission recovery\n            const fsHandle = {\n                syncfs: async () => {\n                    // Check if filesystem is read-only\n                    if (actualPermission === 'read') {\n                        throw new Error(`Cannot sync read-only filesystem at ${mountPath}. Use upgradeFileSystemPermission() to request write access.`);\n                    }\n                    try {\n                        await nativefs.syncfs();\n                        console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                    }\n                    catch (error) {\n                        throw new Error(`Failed to sync filesystem: ${error instanceof Error ? error.message : String(error)}`);\n                    }\n                },\n                dirHandle: handle,\n                permission: actualPermission,\n                nativefs: nativefs\n            };\n            // Store the handle for auto-sync\n            this.nativeFsHandles.set(mountPath, fsHandle);\n            return { syncfs: fsHandle.syncfs };\n        }\n        catch (error) {\n            throw new Error(`Failed to mount native filesystem: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Sync all mounted native filesystems with permission recovery\n     * Only syncs filesystems mounted with 'readwrite' permission\n     * @private\n     */\n    async syncAllNativeFs() {\n        if (this.nativeFsHandles.size === 0) {\n            return;\n        }\n        const syncResults = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            // Skip read-only filesystems\n            if (fsHandle.permission === 'read') {\n                syncResults.push({ mountPath, success: true, skipped: true });\n                console.log(`[KERNEL] Skipping sync for read-only filesystem at ${mountPath}`);\n                continue;\n            }\n            try {\n                // First, try to sync directly\n                await fsHandle.syncfs();\n                syncResults.push({ mountPath, success: true });\n                console.log(`[KERNEL] Successfully synced filesystem at ${mountPath}`);\n            }\n            catch (error) {\n                // If sync fails, check if it's a permission error\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                if (errorMessage.includes('not allowed by the user agent') ||\n                    errorMessage.includes('getFileHandle') ||\n                    errorMessage.includes('permission')) {\n                    console.warn(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                    try {\n                        // Try to recover by re-verifying permissions\n                        const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                        if (hasPermission) {\n                            // Try to remount and sync\n                            console.log(`[KERNEL] Permission recovered for ${mountPath}, attempting remount...`);\n                            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                            // Update the stored handle with the new nativefs\n                            fsHandle.nativefs = newNativefs;\n                            fsHandle.syncfs = async () => {\n                                try {\n                                    await newNativefs.syncfs();\n                                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                                }\n                                catch (syncError) {\n                                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                                }\n                            };\n                            // Try sync again with the new handle\n                            await fsHandle.syncfs();\n                            syncResults.push({ mountPath, success: true });\n                            console.log(`[KERNEL] Successfully recovered and synced filesystem at ${mountPath}`);\n                        }\n                        else {\n                            syncResults.push({\n                                mountPath,\n                                success: false,\n                                error: 'Permission denied by user'\n                            });\n                            console.warn(`[KERNEL] User denied permission for ${mountPath}, skipping sync`);\n                        }\n                    }\n                    catch (recoveryError) {\n                        const recoveryMessage = recoveryError instanceof Error ? recoveryError.message : String(recoveryError);\n                        syncResults.push({\n                            mountPath,\n                            success: false,\n                            error: `Recovery failed: ${recoveryMessage}`\n                        });\n                        console.error(`[KERNEL] Failed to recover permissions for ${mountPath}:`, recoveryError);\n                    }\n                }\n                else {\n                    // Non-permission error\n                    syncResults.push({\n                        mountPath,\n                        success: false,\n                        error: errorMessage\n                    });\n                    console.error(`[KERNEL] Non-permission error syncing ${mountPath}:`, error);\n                }\n            }\n        }\n        // Log summary\n        const successful = syncResults.filter(r => r.success && !r.skipped).length;\n        const skipped = syncResults.filter(r => r.skipped).length;\n        const failed = syncResults.filter(r => !r.success);\n        if (successful > 0 || skipped > 0) {\n            const parts = [];\n            if (successful > 0)\n                parts.push(`${successful} synced`);\n            if (skipped > 0)\n                parts.push(`${skipped} read-only skipped`);\n            console.log(`[KERNEL] Auto-sync completed: ${parts.join(', ')} (${syncResults.length} total filesystems)`);\n        }\n        if (failed.length > 0) {\n            console.warn(`[KERNEL] Auto-sync issues:`, failed.map(f => `${f.mountPath}: ${f.error}`));\n        }\n        // Don't throw - we don't want to fail execution just because sync failed\n    }\n    /**\n     * Get information about mounted native filesystems and their permission status\n     * @returns Array of mounted filesystem information\n     */\n    getMountedFileSystems() {\n        const result = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            result.push({\n                mountPath,\n                permission: fsHandle.permission,\n                canSync: fsHandle.permission === 'readwrite'\n            });\n        }\n        return result;\n    }\n    /**\n     * Manually sync a specific mounted filesystem\n     * @param mountPath The path of the mounted filesystem to sync\n     * @returns Promise resolving to success status\n     */\n    async syncFileSystem(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        // Check if filesystem is read-only\n        if (fsHandle.permission === 'read') {\n            return {\n                success: false,\n                error: `Cannot sync read-only filesystem at ${mountPath}. Mount with 'readwrite' permission to enable syncing.`\n            };\n        }\n        try {\n            await fsHandle.syncfs();\n            return { success: true };\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            // Try permission recovery if it's a permission error\n            if (errorMessage.includes('not allowed by the user agent') ||\n                errorMessage.includes('getFileHandle') ||\n                errorMessage.includes('permission')) {\n                console.log(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                try {\n                    const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                    if (hasPermission) {\n                        // Remount and try again\n                        const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                        fsHandle.nativefs = newNativefs;\n                        fsHandle.syncfs = async () => {\n                            try {\n                                await newNativefs.syncfs();\n                                console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                            }\n                            catch (syncError) {\n                                throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                            }\n                        };\n                        await fsHandle.syncfs();\n                        return { success: true };\n                    }\n                    else {\n                        return {\n                            success: false,\n                            error: 'Permission denied by user'\n                        };\n                    }\n                }\n                catch (recoveryError) {\n                    return {\n                        success: false,\n                        error: `Recovery failed: ${recoveryError instanceof Error ? recoveryError.message : String(recoveryError)}`\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    }\n    /**\n     * Upgrade a mounted filesystem from read-only to read-write permission\n     * @param mountPath The path of the mounted filesystem to upgrade\n     * @returns Promise resolving to success status\n     */\n    async upgradeFileSystemPermission(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        if (fsHandle.permission === 'readwrite') {\n            return {\n                success: true,\n                error: `FileSystem at ${mountPath} already has readwrite permission`\n            };\n        }\n        try {\n            console.log(`[KERNEL] Attempting to upgrade ${mountPath} to readwrite permission...`);\n            // Try to get readwrite permission\n            const hasWritePermission = await this.verifyPermission(fsHandle.dirHandle, 'readwrite');\n            if (!hasWritePermission) {\n                return {\n                    success: false,\n                    error: 'User denied write permission or browser does not support write access to this directory'\n                };\n            }\n            // Remount with write permission\n            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n            // Update the stored handle\n            fsHandle.permission = 'readwrite';\n            fsHandle.nativefs = newNativefs;\n            fsHandle.syncfs = async () => {\n                try {\n                    await newNativefs.syncfs();\n                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                }\n                catch (syncError) {\n                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                }\n            };\n            console.log(`[KERNEL] Successfully upgraded ${mountPath} to readwrite permission`);\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Failed to upgrade permission: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    /**\n     * Set environment variables with performance optimization\n     * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n     */\n    async setEnvironmentVariables() {\n        if (Object.keys(this.environmentVariables).length === 0) {\n            return; // No variables to set\n        }\n        const startTime = Date.now();\n        console.log(`ðŸŒ Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n        try {\n            // Set each environment variable individually to avoid escaping issues\n            for (const [key, value] of Object.entries(this.environmentVariables)) {\n                // Handle edge cases: null, undefined, etc.\n                let processedValue;\n                if (value === null) {\n                    processedValue = ''; // Convert null to empty string\n                }\n                else if (value === undefined) {\n                    processedValue = ''; // Convert undefined to empty string\n                }\n                else {\n                    processedValue = String(value); // Convert everything else to string\n                }\n                await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n            }\n            const duration = Date.now() - startTime;\n            console.log(`âš¡ Environment variables set in ${duration}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Failed to set environment variables:\", error);\n            throw error;\n        }\n    }\n}\n// Only Python kernel is supported\n// Export the manager for advanced usage\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQzNDLElBQUksY0FBc0IsQ0FBQztnQkFDM0IsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQ25CLGNBQWMsR0FBRyxFQUFFLENBQUMsQ0FBRSwrQkFBK0I7Z0JBQ3ZELENBQUM7cUJBQU0sSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFLENBQUM7b0JBQy9CLGNBQWMsR0FBRyxFQUFFLENBQUMsQ0FBRSxvQ0FBb0M7Z0JBQzVELENBQUM7cUJBQU0sQ0FBQztvQkFDTixjQUFjLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUUsb0NBQW9DO2dCQUN2RSxDQUFDO2dCQUVELE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7O2FBRTdCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUM7Q0FDcEUsQ0FBQyxDQUFDO1lBQ0csQ0FBQztZQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUM7WUFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsUUFBUSxJQUFJLENBQUMsQ0FBQztRQUM5RCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDL0QsTUFBTSxLQUFLLENBQUM7UUFDZCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBRUQsa0NBQWtDO0FBRWxDLHdDQUF3QztBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vV2ViUHl0aG9uS2VybmVsLy4vc3JjL2luZGV4LnRzP2ZmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gS2VybmVsIGltcGxlbWVudGF0aW9uIGZvciBEZW5vIHVzaW5nIFB5b2RpZGUgZGlyZWN0bHlcbi8vIEJhc2VkIG9uIHRoZSBQeW9kaWRlUmVtb3RlS2VybmVsIGJ1dCBhZGFwdGVkIGZvciBkaXJlY3QgZXhlY3V0aW9uIGluIG1haW4gdGhyZWFkXG5cbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG4vLyBVc2UgYSBicm93c2VyLWNvbXBhdGlibGUgRXZlbnRFbWl0dGVyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGV2ZW50czogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fTtcblxuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuOiBudW1iZXIpIHtcbiAgICAvLyBOby1vcCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZSBJbXBvcnRpbmcgZnJvbSBucG1cbmltcG9ydCB7IGxvYWRQeW9kaWRlIH0gZnJvbSBcIi4vcHlvZGlkZS1sb2FkZXJcIjtcblxuLy8gSW1wb3J0IHR5cGVzIGFuZCBlbnVtc1xuaW1wb3J0IHsgS2VybmVsRXZlbnRzLCBJRXZlbnREYXRhLCBJTWVzc2FnZSwgSUtlcm5lbCwgSUtlcm5lbE9wdGlvbnMsIElGaWxlU3lzdGVtTW91bnRPcHRpb25zLCBJS2VybmVsRXhlY3V0ZU9wdGlvbnMsIElFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyBJbXBvcnQgUHlQSSBVUkxzXG5pbXBvcnQge1xuICBwaXBsaXRlV2hlZWxVcmwsXG4gIHB5b2RpZGVfa2VybmVsV2hlZWxVcmwsXG4gIGlweWtlcm5lbFdoZWVsVXJsLFxuICBhbGxKU09OVXJsLFxuICB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybCxcbiAgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwxXG59IGZyb20gJy4vX3B5cGknO1xuXG4vLyBFdmVudCB0eXBlcyBmcm9tIEp1cHl0ZXJMYWJcbi8vIFJlLWV4cG9ydCB0eXBlcyB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgeyBLZXJuZWxFdmVudHMgfSBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0IHR5cGUge1xuICBJS2VybmVsLFxuICBJS2VybmVsT3B0aW9ucyxcbiAgSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnMsXG4gIElLZXJuZWxFeGVjdXRlT3B0aW9ucyxcbiAgSU1lc3NhZ2UsXG4gIElFdmVudERhdGEsXG4gIElFdmVudEVtaXR0ZXIsXG4gIElOYXRpdmVGU0hhbmRsZVxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgeyBLZXJuZWxNb2RlLCBLZXJuZWxMYW5ndWFnZSB9IGZyb20gXCIuL21hbmFnZXJcIjtcblxuXG5cblxuZXhwb3J0IGNsYXNzIEtlcm5lbCBleHRlbmRzIEV2ZW50RW1pdHRlciBpbXBsZW1lbnRzIElLZXJuZWwge1xuICBwcml2YXRlIHB5b2RpZGU6IGFueTtcbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBGaWxlU3lzdGVtIG9wdGlvbnNcbiAgcHJpdmF0ZSBmaWxlc3lzdGVtT3B0aW9uczogSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnMgPSB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcm9vdDogXCIuXCIsXG4gICAgbW91bnRQb2ludDogXCIvaG9tZS9weW9kaWRlXCJcbiAgfTtcbiAgXG4gIC8vIEtlcm5lbCBvcHRpb25zXG4gIHByaXZhdGUgbG9ja0ZpbGVVUkw/OiBzdHJpbmc7XG4gIFxuICAvLyBLZXJuZWwgY29tcG9uZW50c1xuICBwcml2YXRlIF9rZXJuZWw6IGFueTtcbiAgcHJpdmF0ZSBfaW50ZXJwcmV0ZXI6IGFueTtcbiAgcHJpdmF0ZSBfc3Rkb3V0X3N0cmVhbTogYW55O1xuICBwcml2YXRlIF9zdGRlcnJfc3RyZWFtOiBhbnk7XG4gIFxuICAvLyBJbnB1dCBoYW5kbGluZ1xuICBwcml2YXRlIF9yZXNvbHZlSW5wdXRSZXBseTogKCh2YWx1ZTogYW55KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gRXhlY3V0aW9uIHN0YXRlXG4gIHByaXZhdGUgX3BhcmVudF9oZWFkZXI6IGFueSA9IHt9O1xuICBwcml2YXRlIGV4ZWN1dGlvbkNvdW50ID0gMDtcbiAgcHJpdmF0ZSBfc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiO1xuICBcbiAgLy8gSW50ZXJydXB0IGhhbmRsaW5nXG4gIHByaXZhdGUgX2ludGVycnVwdEJ1ZmZlcjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgXG4gIC8vIEVudmlyb25tZW50IHZhcmlhYmxlc1xuICBwcml2YXRlIGVudmlyb25tZW50VmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgLy8gTmF0aXZlIGZpbGVzeXN0ZW0gaGFuZGxlc1xuICBwcml2YXRlIG5hdGl2ZUZzSGFuZGxlczogTWFwPHN0cmluZywgeyBcbiAgICBzeW5jZnM6ICgpID0+IFByb21pc2U8dm9pZD47IFxuICAgIGRpckhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZTtcbiAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICBuYXRpdmVmczogYW55O1xuICB9PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBhdXRvU3luY0ZzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMga2VybmVsIGluc3RhbmNlXG4gIHByaXZhdGUgcmVhZG9ubHkga2VybmVsSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnNldE1heExpc3RlbmVycygyMCk7XG4gICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMga2VybmVsIGluc3RhbmNlXG4gICAgdGhpcy5rZXJuZWxJZCA9IGBrZXJuZWxfJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMil9XyR7RGF0ZS5ub3coKX1gO1xuICB9XG5cbiAgLy8gQXN5bmMgbWV0aG9kIGZvciBrZXJuZWwgc3RhdHVzXG4gIGFzeW5jIGdldFN0YXR1cygpOiBQcm9taXNlPFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiPiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBtYXhpbXVtIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICogT1BUSU1JWkVEOiBGdWxsIHBhcmFsbGVsaXphdGlvbiB3aXRoIHNtYXJ0IGNhY2hpbmcgYW5kIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmluaXRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZmlsZXN5c3RlbSBvcHRpb25zIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmZpbGVzeXN0ZW0pIHtcbiAgICAgIHRoaXMuZmlsZXN5c3RlbU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnRoaXMuZmlsZXN5c3RlbU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuZmlsZXN5c3RlbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmVudikge1xuICAgICAgdGhpcy5lbnZpcm9ubWVudFZhcmlhYmxlcyA9IHsgLi4ub3B0aW9ucy5lbnYgfTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbG9ja0ZpbGVVUkwgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucz8ubG9ja0ZpbGVVUkwpIHtcbiAgICAgIHRoaXMubG9ja0ZpbGVVUkwgPSBvcHRpb25zLmxvY2tGaWxlVVJMO1xuICAgIH1cblxuICAgIC8vIFNldCBhdXRvU3luY0ZzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmF1dG9TeW5jRnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hdXRvU3luY0ZzID0gb3B0aW9ucy5hdXRvU3luY0ZzO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLl9pbml0aWFsaXplSW50ZXJuYWwoKTtcbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIG1heGltdW0gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uc1xuICAgKiBPUFRJTUlaRUQ6IEZ1bGwgcGFyYWxsZWxpemF0aW9uIHdpdGggc21hcnQgY2FjaGluZyBhbmQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdGlhbGl6ZUludGVybmFsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coXCLwn5qAIFN0YXJ0aW5nIG9wdGltaXplZCBrZXJuZWwgaW5pdGlhbGl6YXRpb24uLi5cIik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgUHlvZGlkZSBmcm9tIENETlxuICAgICAgY29uc3QgcHlvZGlkZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIENvbmZpZ3VyZSBweW9kaWRlIG9wdGlvbnNcbiAgICAgIGNvbnN0IHB5b2RpZGVDb25maWc6IGFueSA9IHt9O1xuICAgICAgaWYgKHRoaXMubG9ja0ZpbGVVUkwpIHtcbiAgICAgICAgcHlvZGlkZUNvbmZpZy5sb2NrRmlsZVVSTCA9IHRoaXMubG9ja0ZpbGVVUkw7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SSIFVzaW5nIGxvY2tGaWxlVVJMOiAke3RoaXMubG9ja0ZpbGVVUkx9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVzZSBvdXIgQ0ROIGxvYWRlciAtIGl0IHdpbGwgYXV0b21hdGljYWxseSBoYW5kbGUgbWFpbiB0aHJlYWQgdnMgd29ya2VyXG4gICAgICB0aGlzLnB5b2RpZGUgPSBhd2FpdCBsb2FkUHlvZGlkZShweW9kaWRlQ29uZmlnKTtcbiAgICAgIGNvbnN0IHB5b2RpZGVUaW1lID0gRGF0ZS5ub3coKSAtIHB5b2RpZGVTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFB5b2RpZGUgbG9hZGVkIGluICR7cHlvZGlkZVRpbWV9bXNgKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBjb3JlIGNvbXBvbmVudHMgaW4gcGFyYWxsZWxcbiAgICAgIGlmICh0aGlzLmxvY2tGaWxlVVJMKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgbG9ja0ZpbGVVUkwsIHBhY2thZ2VzIGFyZSBwcmUtaW5zdGFsbGVkLCBza2lwIHBhY2thZ2UgaW5zdGFsbGF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+agCBVc2luZyBsb2NrIGZpbGUgLSBza2lwcGluZyBwYWNrYWdlIGluc3RhbGxhdGlvblwiKTtcbiAgICAgICAgY29uc3QgWyxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIDEuIEZpbGVTeXN0ZW0gbW91bnRpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVTeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgIC8vIDIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXR1cFxuICAgICAgICAgIHRoaXMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2xvYmFscyBkaXJlY3RseSAocGFja2FnZXMgYXJlIGFscmVhZHkgYXZhaWxhYmxlKVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGFuZGFyZCBpbml0aWFsaXphdGlvbiB3aXRoIHBhY2thZ2UgaW5zdGFsbGF0aW9uXG4gICAgICAgIGNvbnN0IFssICxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIDEuIEZpbGVTeXN0ZW0gbW91bnRpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVTeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgIC8vIDIuIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXphdGlvblxuICAgICAgICAgIHRoaXMuaW5pdFBhY2thZ2VNYW5hZ2VyKCksXG4gICAgICAgICAgLy8gMy4gRW52aXJvbm1lbnQgdmFyaWFibGVzIHNldHVwXG4gICAgICAgICAgdGhpcy5zZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5zdGFsbCBwYWNrYWdlcyBhbmQgaW5pdGlhbGl6ZSBnbG9iYWxzXG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdEtlcm5lbCgpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBLRVJORUwgSU5JVElBTElaQVRJT04gQ09NUExFVEUgaW4gJHt0b3RhbFRpbWV9bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgUGVyZm9ybWFuY2U6IFB5b2RpZGUoJHtweW9kaWRlVGltZX1tcykgKyBTZXR1cCgke3RvdGFsVGltZSAtIHB5b2RpZGVUaW1lfW1zKWApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIGFzIGluaXRpYWxpemVkXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfn6IgS2VybmVsIGlzIG5vdyBBQ1RJVkUgYW5kIHJlYWR5IGZvciBleGVjdXRpb24hXCIpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgS2VybmVsIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgbG9jYWwgZmlsZXN5c3RlbSB0byB0aGUgUHlvZGlkZSBlbnZpcm9ubWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb3VudEZpbGVTeXN0ZW0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBNb3VudGluZyBmaWxlc3lzdGVtIGZyb20gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3R9IHRvICR7dGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50fWApO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgYXBwcm9hY2ggYXMgaW4gZGVuby1kZW1vLWZzLWFzZ2kuanMgZm9yIG1heGltdW0gY29tcGF0aWJpbGl0eVxuICAgICAgLy8gU2ltcGxlIGFuZCBkaXJlY3QgbW91bnRpbmcgb2YgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5GUy5tb3VudChcbiAgICAgICAgdGhpcy5weW9kaWRlLkZTLmZpbGVzeXN0ZW1zLk5PREVGUyxcbiAgICAgICAgeyByb290OiB0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3QgfHwgXCIuXCIgfSxcbiAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50IHx8IFwiL2hvbWUvcHlvZGlkZVwiXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkZpbGVTeXN0ZW0gbW91bnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgbW91bnQgYnkgbGlzdGluZyB0aGUgZGlyZWN0b3J5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb3VudGVkRmlsZXMgPSB0aGlzLnB5b2RpZGUuRlMucmVhZGRpcih0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnQgfHwgXCIvaG9tZS9weW9kaWRlXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZXMgaW4gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnR9IGRpcmVjdG9yeTogJHttb3VudGVkRmlsZXMuam9pbihcIiwgXCIpfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbGlzdGluZyBtb3VudGVkIGRpcmVjdG9yeTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1vdW50aW5nIGZpbGVzeXN0ZW06XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBQeW9kaWRlIHBhY2thZ2UgbWFuYWdlciB3aXRoIG9wdGltaXplZCB3aGVlbCBsb2FkaW5nXG4gICAqIE9QVElNSVpFRDogU21hcnQgY2FjaGluZyBhbmQgcGFyYWxsZWwgd2hlZWwgaW5zdGFsbGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRQYWNrYWdlTWFuYWdlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwi4pqhIEluaXRpYWxpemluZyBvcHRpbWl6ZWQgcGFja2FnZSBtYW5hZ2VyLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIG1pY3JvcGlwIGFuZCBwYWNrYWdpbmcgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TpiBMb2FkaW5nIG1pY3JvcGlwLCBwYWNrYWdpbmcuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoWydtaWNyb3BpcCcsICdwYWNrYWdpbmcnXSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2FkZWQgbWljcm9waXAsIHBhY2thZ2luZ1wiKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBiYXNlIFVSTCAtIHVzZSB3aW5kb3cubG9jYXRpb24gZm9yIGJyb3dzZXIgb3IgZmFsbGJhY2sgZm9yIHdvcmtlclxuICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gbWFpbiB0aHJlYWQgLSB1c2Ugd2luZG93LmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gd2ViIHdvcmtlciAtIHVzZSBzZWxmLmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCBzZWxmLmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayAtIGFzc3VtZSBjdXJyZW50IG9yaWdpblxuICAgICAgICBiYXNlVXJsID0gXCIvXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFsbEpzb25QYXRoID0gbmV3IFVSTChhbGxKU09OVXJsLCBiYXNlVXJsKS5ocmVmO1xuICAgICAgXG4gICAgICAvLyBQcmVwYXJlIGFsbCB3aGVlbCBVUkxzIGZvciBwYXJhbGxlbCBsb2FkaW5nXG4gICAgICBjb25zdCB3aGVlbEZpbGVzID0gW1xuICAgICAgICBuZXcgVVJMKHBpcGxpdGVXaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTChweW9kaWRlX2tlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKGlweWtlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMSwgYmFzZVVybCkuaHJlZixcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIEluc3RhbGxpbmcgJHt3aGVlbEZpbGVzLmxlbmd0aH0gd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwuLi5gKTtcbiAgICAgIFxuICAgICAgLy8gSW5zdGFsbCBhbGwgd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwgZm9yIG1heGltdW0gc3BlZWRcbiAgICAgIGNvbnN0IHdoZWVsUHJvbWlzZXMgPSB3aGVlbEZpbGVzLm1hcChhc3luYyAod2hlZWxVcmwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHdoZWVsU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IG1pY3JvcGlwXG5hd2FpdCBtaWNyb3BpcC5pbnN0YWxsKCcke3doZWVsVXJsfScsIGtlZXBfZ29pbmc9VHJ1ZSlcbnByaW50KGZcIuKchSBXaGVlbCAke2luZGV4ICsgMX0vJHt3aGVlbEZpbGVzLmxlbmd0aH0gaW5zdGFsbGVkXCIpXG5gKTtcbiAgICAgICAgICBjb25zdCB3aGVlbFRpbWUgPSBEYXRlLm5vdygpIC0gd2hlZWxTdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBXaGVlbCAke2luZGV4ICsgMX0gaW5zdGFsbGVkIGluICR7d2hlZWxUaW1lfW1zYCk7XG4gICAgICAgICAgcmV0dXJuIHsgaW5kZXgsIHN1Y2Nlc3M6IHRydWUsIHRpbWU6IHdoZWVsVGltZSB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IHdoZWVsVGltZSA9IERhdGUubm93KCkgLSB3aGVlbFN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXaGVlbCAke2luZGV4ICsgMX0gZmFpbGVkIGFmdGVyICR7d2hlZWxUaW1lfW1zOmAsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBpbmRleCwgc3VjY2VzczogZmFsc2UsIHRpbWU6IHdoZWVsVGltZSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFsbCB3aGVlbCBpbnN0YWxsYXRpb25zXG4gICAgICBjb25zdCB3aGVlbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh3aGVlbFByb21pc2VzKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSB3aGVlbFJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKTtcbiAgICAgIGNvbnN0IGZhaWxlZCA9IHdoZWVsUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfk4ogV2hlZWxzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3doZWVsRmlsZXMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRmFpbGVkIHdoZWVsczogJHtmYWlsZWQubWFwKGYgPT4gZi5pbmRleCArIDEpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCBwaXBsaXRlIGNvbmZpZ3VyYXRpb24gd2l0aCBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zIChpZiBhdmFpbGFibGUpXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgIGltcG9ydCBwaXBsaXRlLnBpcGxpdGVcbiAgICBpbXBvcnQganNvblxuXG4gICAgIyBMb2FkIHBhY2thZ2UgaW5kZXggZm9yIGZhc3RlciBsb29rdXBzXG4gICAgdHJ5OlxuICAgICAgICBwaXBsaXRlLnBpcGxpdGUuUElQTElURV9VUkwgPSBcIiR7YWxsSnNvblBhdGh9XCJcbiAgICAgICAgIyBQcmUtbG9hZCBwYWNrYWdlIGluZGV4IGZvciBmYXN0ZXIgaW5zdGFsbGF0aW9uXG4gICAgICAgIHByaW50KFwi8J+TiyBQYWNrYWdlIGluZGV4IGNvbmZpZ3VyZWRcIilcbiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgICAgIHByaW50KGZcIuKaoO+4jyBQYWNrYWdlIGluZGV4IHNldHVwIHdhcm5pbmc6IHtlfVwiKVxuXG4gICAgIyBDb25maWd1cmUgcGlwbGl0ZSBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZVxuICAgIHBpcGxpdGUucGlwbGl0ZS5SRVBPREFUQV9JTkZPID0ge31cbiAgICBwcmludChcIuKaoSBQaXBsaXRlIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2VcIilcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcbiAgICBwcmludChcIuKaoO+4jyBQaXBsaXRlIG5vdCBhdmFpbGFibGUsIGNvbnRpbnVpbmcgd2l0aG91dCBpdFwiKVxuZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgIHByaW50KGZcIuKaoO+4jyBQaXBsaXRlIHNldHVwIGZhaWxlZDoge2V9XCIpXG5gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBQaXBsaXRlIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgaXQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXplZCBpbiAke3RvdGFsVGltZX1tc2ApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgUGFja2FnZSBtYW5hZ2VyIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIHJlcXVpcmVkIFB5dGhvbiBwYWNrYWdlc1xuICAgKiBPUFRJTUlaRUQ6IE1heGltdW0gcGFyYWxsZWxpemF0aW9uIHdpdGggaW50ZWxsaWdlbnQgZGVwZW5kZW5jeSByZXNvbHV0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRLZXJuZWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIvCfmoAgSW5pdGlhbGl6aW5nIGtlcm5lbCBwYWNrYWdlcyB3aXRoIG1heGltdW0gb3B0aW1pemF0aW9uLi4uXCIpO1xuICAgIFxuICAgIC8vIEFsbCBwYWNrYWdlcyB0byBpbnN0YWxsIHdpdGggcHJpb3JpdHkgYW5kIGRlcGVuZGVuY3kgaW5mb3JtYXRpb25cbiAgICBjb25zdCBwYWNrYWdlQ29uZmlnID0gW1xuICAgICAgLy8gSGlnaCBwcmlvcml0eTogQ0ROIHBhY2thZ2VzIChmYXN0ZXN0KVxuICAgICAgeyBuYW1lOiAncHVyZS1ldmFsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzdGFjay1kYXRhJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdweWdtZW50cycsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnc3NsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzcWxpdGUzJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdwcm9tcHRfdG9vbGtpdCcsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnamVkaScsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnaXB5dGhvbicsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgXG4gICAgICAvLyBNZWRpdW0gcHJpb3JpdHk6IHBpcCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnY29tbScsIHByaW9yaXR5OiAyLCBzb3VyY2U6ICdwaXAnIH0sXG4gICAgICB7IG5hbWU6ICdoeXBoYS1ycGMnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgeyBuYW1lOiAnbmJmb3JtYXQnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgXG4gICAgICAvLyBMb3dlciBwcmlvcml0eTogY29tcGxleCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnaXB5a2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfSxcbiAgICAgIHsgbmFtZTogJ3B5b2RpZGVfa2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfVxuICAgIF07XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfk6YgSW5zdGFsbGluZyAke3BhY2thZ2VDb25maWcubGVuZ3RofSBwYWNrYWdlcyB3aXRoIGludGVsbGlnZW50IG9wdGltaXphdGlvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBJbnN0YWxsIEFMTCBwYWNrYWdlcyBpbiBwYXJhbGxlbCB3aXRoIGFkdmFuY2VkIGVycm9yIGhhbmRsaW5nIGFuZCBjYWNoaW5nXG4gICAgICBhd2FpdCB0aGlzLmluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnKTtcbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IHRoZSBrZXJuZWwgKG11c3QgYmUgZG9uZSBhZnRlciBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkKVxuICAgICAgY29uc29sZS5sb2coXCLwn5OlIEltcG9ydGluZyBweW9kaWRlX2tlcm5lbC4uLlwiKTtcbiAgICAgIGNvbnN0IGltcG9ydFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoJ2ltcG9ydCBweW9kaWRlX2tlcm5lbCcpO1xuICAgICAgY29uc3QgaW1wb3J0VGltZSA9IERhdGUubm93KCkgLSBpbXBvcnRTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIHB5b2RpZGVfa2VybmVsIGltcG9ydGVkIGluICR7aW1wb3J0VGltZX1tc2ApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gS2VybmVsIHBhY2thZ2VzIGluaXRpYWxpemVkIGluICR7dG90YWxUaW1lfW1zYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBLZXJuZWwgcGFja2FnZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEluc3RhbGwgcGFja2FnZXMgd2l0aCBpbnRlbGxpZ2VudCBvcHRpbWl6YXRpb24gYW5kIGFkdmFuY2VkIGNhY2hpbmdcbiAgICogT1BUSU1JWkVEOiBTbWFydCBzb3VyY2Ugc2VsZWN0aW9uLCBwYXJhbGxlbCBpbnN0YWxsYXRpb24sIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnOiBBcnJheTx7bmFtZTogc3RyaW5nLCBwcmlvcml0eTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZ30+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coYOKaoSBTdGFydGluZyBpbnRlbGxpZ2VudCBwYXJhbGxlbCBpbnN0YWxsYXRpb24gb2YgJHtwYWNrYWdlQ29uZmlnLmxlbmd0aH0gcGFja2FnZXMuLi5gKTtcbiAgICBcbiAgICBjb25zdCBpbnN0YWxsUHJvbWlzZXMgPSBwYWNrYWdlQ29uZmlnLm1hcChhc3luYyAocGtnKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgSW5zdGFsbGluZyAke3BrZy5uYW1lfSAocHJpb3JpdHk6ICR7cGtnLnByaW9yaXR5fSwgcHJlZmVycmVkOiAke3BrZy5zb3VyY2V9KS4uLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHByZWZlcnJlZCBzb3VyY2UgZmlyc3QsIHdpdGggaW50ZWxsaWdlbnQgZmFsbGJhY2tcbiAgICAgICAgaWYgKHBrZy5zb3VyY2UgPT09ICdweW9kaWRlJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoW3BrZy5uYW1lXSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGxvYWRlZCBmcm9tIFB5b2RpZGUgQ0ROICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3B5b2RpZGUnLCBkdXJhdGlvbiwgc3VjY2VzczogdHJ1ZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSB9O1xuICAgICAgICAgIH0gY2F0Y2ggKHB5b2RpZGVFcnJvcikge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcGlwIHdpdGggZW5oYW5jZWQgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OmICR7cGtnLm5hbWV9IG5vdCBhdmFpbGFibGUgb24gQ0ROLCB0cnlpbmcgcGlwLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGxWaWFQaXBXaXRoT3B0aW1pemF0aW9ucyhwa2cubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGluc3RhbGxlZCB2aWEgcGlwIGZhbGxiYWNrICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3BpcC1mYWxsYmFjaycsIGR1cmF0aW9uLCBzdWNjZXNzOiB0cnVlLCBwcmlvcml0eTogcGtnLnByaW9yaXR5IH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpcmVjdCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggb3B0aW1pemF0aW9uc1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBrZy5uYW1lKTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3BrZy5uYW1lfSBpbnN0YWxsZWQgdmlhIHBpcCAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgICByZXR1cm4geyBwYWNrYWdlOiBwa2cubmFtZSwgbWV0aG9kOiAncGlwJywgZHVyYXRpb24sIHN1Y2Nlc3M6IHRydWUsIHByaW9yaXR5OiBwa2cucHJpb3JpdHkgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBjb25zb2xlLndhcm4oYOKdjCBGYWlsZWQgdG8gaW5zdGFsbCAke3BrZy5uYW1lfSBhZnRlciAke2R1cmF0aW9ufW1zOmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ2ZhaWxlZCcsIGR1cmF0aW9uLCBzdWNjZXNzOiBmYWxzZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSwgZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBhbGwgaW5zdGFsbGF0aW9ucyB3aXRoIGRldGFpbGVkIGFuYWx5c2lzXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbGxQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBhbmFseXNpc1xuICAgIHRoaXMuYW5hbHl6ZUluc3RhbGxhdGlvblJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnN0YWxsIHBhY2thZ2UgdmlhIHBpcCB3aXRoIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgICMgSW1wb3J0IHBpcGxpdGUgZmlyc3RcbiAgICBpbXBvcnQgcGlwbGl0ZVxuICAgICMgVXNlIG9wdGltaXplZCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggY2FjaGluZ1xuICAgIGF3YWl0IHBpcGxpdGUuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUsIGRlcHM9VHJ1ZSlcbiAgICBwcmludChcIuKchSBTdWNjZXNzZnVsbHkgaW5zdGFsbGVkICR7cGFja2FnZU5hbWV9IHZpYSBvcHRpbWl6ZWQgcGlwXCIpXG5leGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgcHJpbnQoXCLimqDvuI8gV2FybmluZzogRmFpbGVkIHRvIGluc3RhbGwgJHtwYWNrYWdlTmFtZX06XCIsIHN0cihlKSlcbiAgICAjIFRyeSBhbHRlcm5hdGl2ZSBpbnN0YWxsYXRpb24gbWV0aG9kXG4gICAgdHJ5OlxuICAgICAgICBpbXBvcnQgbWljcm9waXBcbiAgICAgICAgYXdhaXQgbWljcm9waXAuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUpXG4gICAgICAgIHByaW50KFwi4pyFIFN1Y2Nlc3NmdWxseSBpbnN0YWxsZWQgJHtwYWNrYWdlTmFtZX0gdmlhIG1pY3JvcGlwIGZhbGxiYWNrXCIpXG4gICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlMjpcbiAgICAgICAgcHJpbnQoXCLinYwgQm90aCBwaXAgbWV0aG9kcyBmYWlsZWQgZm9yICR7cGFja2FnZU5hbWV9OlwiLCBzdHIoZTIpKVxuICAgICAgICByYWlzZSBlMlxuYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBBbmFseXplIGluc3RhbGxhdGlvbiByZXN1bHRzIGFuZCBwcm92aWRlIHBlcmZvcm1hbmNlIGluc2lnaHRzXG4gICAqL1xuICBwcml2YXRlIGFuYWx5emVJbnN0YWxsYXRpb25SZXN1bHRzKHJlc3VsdHM6IEFycmF5PGFueT4pOiB2b2lkIHtcbiAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpO1xuICAgIGNvbnN0IGZhaWxlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgY29uc3QgcHlvZGlkZUluc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3B5b2RpZGUnKTtcbiAgICBjb25zdCBwaXBJbnN0YWxscyA9IHN1Y2Nlc3NmdWwuZmlsdGVyKHIgPT4gci5tZXRob2QgPT09ICdwaXAnKTtcbiAgICBjb25zdCBmYWxsYmFja0luc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3BpcC1mYWxsYmFjaycpO1xuICAgIFxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBNYXRoLm1heCguLi5yZXN1bHRzLm1hcChyID0+IHIuZHVyYXRpb24pKTtcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc3QgZXN0aW1hdGVkU2VxdWVudGlhbCA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn46vIElOVEVMTElHRU5UIElOU1RBTExBVElPTiBDT01QTEVURSFgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBSZXN1bHRzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3Jlc3VsdHMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgY29uc29sZS5sb2coYOKaoSBQeW9kaWRlIENETjogJHtweW9kaWRlSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OmIERpcmVjdCBwaXA6ICR7cGlwSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFBpcCBmYWxsYmFjazogJHtmYWxsYmFja0luc3RhbGxzLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg4p2MIEZhaWxlZDogJHtmYWlsZWQubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDij7HvuI8gIFRvdGFsIHRpbWU6ICR7dG90YWxEdXJhdGlvbn1tcyAodnMgfiR7ZXN0aW1hdGVkU2VxdWVudGlhbH1tcyBzZXF1ZW50aWFsKWApO1xuICAgIGNvbnNvbGUubG9nKGDwn5qAIFNwZWVkIGltcHJvdmVtZW50OiB+JHtNYXRoLnJvdW5kKGVzdGltYXRlZFNlcXVlbnRpYWwgLyB0b3RhbER1cmF0aW9uKX14IGZhc3RlcmApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OIIEF2ZXJhZ2UgcGVyIHBhY2thZ2U6ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXNgKTtcbiAgICBcbiAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBGYWlsZWQgcGFja2FnZXM6ICR7ZmFpbGVkLm1hcChmID0+IGYucGFja2FnZSkuam9pbignLCAnKX1gKTtcbiAgICAgIC8vIExvZyBzcGVjaWZpYyBmYWlsdXJlIHJlYXNvbnMgZm9yIGRlYnVnZ2luZ1xuICAgICAgZmFpbGVkLmZvckVhY2goZiA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAgLSAke2YucGFja2FnZX06ICR7Zi5lcnJvcj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGVyZm9ybWFuY2UgaW5zaWdodHNcbiAgICBjb25zdCBmYXN0ZXN0SW5zdGFsbCA9IE1hdGgubWluKC4uLnN1Y2Nlc3NmdWwubWFwKHIgPT4gci5kdXJhdGlvbikpO1xuICAgIGNvbnN0IHNsb3dlc3RJbnN0YWxsID0gTWF0aC5tYXgoLi4uc3VjY2Vzc2Z1bC5tYXAociA9PiByLmR1cmF0aW9uKSk7XG4gICAgY29uc29sZS5sb2coYPCfk4ogUGVyZm9ybWFuY2UgcmFuZ2U6ICR7ZmFzdGVzdEluc3RhbGx9bXMgKGZhc3Rlc3QpIHRvICR7c2xvd2VzdEluc3RhbGx9bXMgKHNsb3dlc3QpYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGdsb2JhbCBvYmplY3RzIGZyb20gdGhlIHB5b2RpZGVfa2VybmVsIHBhY2thZ2VcbiAgICogQmFzZWQgb24gdGhlIFB5b2RpZGVSZW1vdGVLZXJuZWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdEdsb2JhbHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgZ2xvYmFscy4uLlwiKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGdsb2JhbHMgZnJvbSB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAgY29uc3QgeyBnbG9iYWxzIH0gPSB0aGlzLnB5b2RpZGU7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBrZXJuZWwgaW5zdGFuY2UgYW5kIHJlbGF0ZWQgb2JqZWN0c1xuICAgIHRoaXMuX2tlcm5lbCA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLmtlcm5lbF9pbnN0YW5jZS5jb3B5KCk7XG4gICAgdGhpcy5fc3Rkb3V0X3N0cmVhbSA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLnN0ZG91dF9zdHJlYW0uY29weSgpO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0gPSBnbG9iYWxzLmdldCgncHlvZGlkZV9rZXJuZWwnKS5zdGRlcnJfc3RyZWFtLmNvcHkoKTtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IHRoaXMuX2tlcm5lbC5pbnRlcnByZXRlci5jb3B5KCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNvbW11bmljYXRpb24gaGFuZGxlcnNcbiAgICB0aGlzLl9pbnRlcnByZXRlci5zZW5kX2NvbW0gPSB0aGlzLnNlbmRDb21tLmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNhbGxiYWNrc1xuICAgIHRoaXMuc2V0dXBDYWxsYmFja3MoKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGFsbCBuZWNlc3NhcnkgY2FsbGJhY2tzIGZvciB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIC8vIEV4ZWN1dGlvbiByZXN1bHQgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uUmVzdWx0ID0gKFxuICAgICAgcHJvbXB0X2NvdW50OiBhbnksXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBtZXRhZGF0YTogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBleGVjdXRpb25fY291bnQ6IHByb21wdF9jb3VudCxcbiAgICAgICAgZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChtZXRhZGF0YSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdleGVjdXRlX3Jlc3VsdCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uRXJyb3IgPSAoZW5hbWU6IGFueSwgZXZhbHVlOiBhbnksIHRyYWNlYmFjazogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGVuYW1lOiBlbmFtZSxcbiAgICAgICAgZXZhbHVlOiBldmFsdWUsXG4gICAgICAgIHRyYWNlYmFjazogdHJhY2ViYWNrLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDbGVhciBvdXRwdXQgY2FsbGJhY2tcbiAgICBjb25zdCBjbGVhck91dHB1dENhbGxiYWNrID0gKHdhaXQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICAgICAgd2FpdDogdGhpcy5mb3JtYXRSZXN1bHQod2FpdCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgICAgdHlwZTogJ2NsZWFyX291dHB1dCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRGlzcGxheSBkYXRhIGNhbGxiYWNrXG4gICAgY29uc3QgZGlzcGxheURhdGFDYWxsYmFjayA9IChkYXRhOiBhbnksIG1ldGFkYXRhOiBhbnksIHRyYW5zaWVudDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQobWV0YWRhdGEpLFxuICAgICAgICB0cmFuc2llbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KHRyYW5zaWVudCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5X2RhdGEnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBkaXNwbGF5IGRhdGEgY2FsbGJhY2tcbiAgICBjb25zdCB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrID0gKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgbWV0YWRhdGE6IGFueSxcbiAgICAgIHRyYW5zaWVudDogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChkYXRhKSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgICAgdHJhbnNpZW50OiB0aGlzLmZvcm1hdFJlc3VsdCh0cmFuc2llbnQpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICB0eXBlOiAndXBkYXRlX2Rpc3BsYXlfZGF0YScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gU3RyZWFtIGNhbGxiYWNrXG4gICAgY29uc3QgcHVibGlzaFN0cmVhbUNhbGxiYWNrID0gKG5hbWU6IGFueSwgdGV4dDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuZm9ybWF0UmVzdWx0KG5hbWUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmZvcm1hdFJlc3VsdCh0ZXh0KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXNzaWduIGNhbGxiYWNrcyB0byB0aGUgUHl0aG9uIG9iamVjdHNcbiAgICB0aGlzLl9zdGRvdXRfc3RyZWFtLnB1Ymxpc2hfc3RyZWFtX2NhbGxiYWNrID0gcHVibGlzaFN0cmVhbUNhbGxiYWNrO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0ucHVibGlzaF9zdHJlYW1fY2FsbGJhY2sgPSBwdWJsaXNoU3RyZWFtQ2FsbGJhY2s7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZGlzcGxheV9wdWIuY2xlYXJfb3V0cHV0X2NhbGxiYWNrID0gY2xlYXJPdXRwdXRDYWxsYmFjaztcbiAgICB0aGlzLl9pbnRlcnByZXRlci5kaXNwbGF5X3B1Yi5kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSBkaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlfcHViLnVwZGF0ZV9kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlob29rLnB1Ymxpc2hfZXhlY3V0aW9uX3Jlc3VsdCA9IHB1Ymxpc2hFeGVjdXRpb25SZXN1bHQ7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuaW5wdXQgPSB0aGlzLmlucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZ2V0cGFzcyA9IHRoaXMuZ2V0cGFzcy5iaW5kKHRoaXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgZnJvbSBQeXRob24gZW52aXJvbm1lbnRcbiAgICovXG4gIHByaXZhdGUgX3NlbmRNZXNzYWdlKG1zZzogSU1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgYnkgZW1pdHRpbmcgdGhlIGFwcHJvcHJpYXRlIGV2ZW50XG4gICAqL1xuICBwcml2YXRlIF9wcm9jZXNzTWVzc2FnZShtc2c6IElNZXNzYWdlKTogdm9pZCB7XG4gICAgaWYgKCFtc2cudHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBldmVudERhdGE6IGFueTtcblxuICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmVhbSc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IG5hbWU6ICdzdGRvdXQnLCB0ZXh0OiAnJyB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5TVFJFQU0sIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdpbnB1dF9yZXF1ZXN0Jzoge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbXNnLmNvbnRlbnQgPz8geyBwcm9tcHQ6ICcnLCBwYXNzd29yZDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuSU5QVVRfUkVRVUVTVCwgY29udGVudCk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5ESVNQTEFZX0RBVEEsIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd1cGRhdGVfZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5VUERBVEVfRElTUExBWV9EQVRBLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY2xlYXJfb3V0cHV0Jzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgd2FpdDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuQ0xFQVJfT1VUUFVULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9yZXN1bHQnOiB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG1zZy5idW5kbGUgPz8ge1xuICAgICAgICAgIGV4ZWN1dGlvbl9jb3VudDogdGhpcy5leGVjdXRpb25Db3VudCxcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfUkVTVUxULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9lcnJvcic6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IGVuYW1lOiAnJywgZXZhbHVlOiAnJywgdHJhY2ViYWNrOiBbXSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29tbV9vcGVuJzpcbiAgICAgIGNhc2UgJ2NvbW1fbXNnJzpcbiAgICAgIGNhc2UgJ2NvbW1fY2xvc2UnOiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtc2cuY29udGVudCA/PyB7fTtcbiAgICAgICAgc3VwZXIuZW1pdChtc2cudHlwZSwgY29udGVudCwgbXNnLm1ldGFkYXRhLCBtc2cuYnVmZmVycyk7XG4gICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIG1ldGFkYXRhOiBtc2cubWV0YWRhdGEsXG4gICAgICAgICAgYnVmZmVyczogbXNnLmJ1ZmZlcnNcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1pdCB0aGUgQUxMIGV2ZW50IHdpdGggc3RhbmRhcmRpemVkIGZvcm1hdFxuICAgIGlmIChldmVudERhdGEpIHtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkFMTCwge1xuICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgZGF0YTogZXZlbnREYXRhXG4gICAgICB9IGFzIElFdmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICovXG4gIHB1YmxpYyBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICB9XG4gIFxuICAvKipcbiAgICogTWFrZXMgc3VyZSBweW9kaWRlIGlzIHJlYWR5IGJlZm9yZSBjb250aW51aW5nLCBhbmQgY2FjaGUgdGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cChwYXJlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuX3BhcmVudF9oZWFkZXIgPSB0aGlzLnB5b2RpZGUudG9QeShwYXJlbnQgfHwge30pO1xuICB9XG4gIFxuICAvKipcbiAgICogRXhlY3V0ZSBjb2RlIGluIHRoZSBrZXJuZWwgd2l0aCBwcm9wZXIgbWVzc2FnZS1iYXNlZCBjb21wbGV0aW9uIGRldGVjdGlvblxuICAgKiBcbiAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCBvdXRwdXRzPzogYW55LCBlcnJvcj86IEVycm9yLCBlbmFtZT86IHN0cmluZywgZXZhbHVlPzogc3RyaW5nLCB0cmFjZWJhY2s/OiBhbnkgfT4ge1xuICAgIC8vIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGNvbGxlY3RzIGFsbCBvdXRwdXRzIGZyb20gZXhlY3V0ZVN0cmVhbVxuICAgIGNvbnN0IG91dHB1dHM6IGFueVtdID0gW107XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBleGVjdXRlU3RyZWFtIHRvIGdldCBhbGwgb3V0cHV0c1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBvdXRwdXQgb2YgdGhpcy5leGVjdXRlU3RyZWFtKGNvZGUsIHBhcmVudCkpIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgY29sbGVjdGVkIG91dHB1dHMgdG8gY3JlYXRlIGEgY29tcHJlaGVuc2l2ZSByZXN1bHRcbiAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0ge1xuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgZXhlY3V0aW9uX2NvdW50OiB0aGlzLmV4ZWN1dGlvbkNvdW50XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDb2xsZWN0IGFsbCBvdXRwdXQgdHlwZXNcbiAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgaWYgKG91dHB1dC50eXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc3Rkb3V0L3N0ZGVyclxuICAgICAgICAgIGlmICghcmVzdWx0LnN0ZG91dCkgcmVzdWx0LnN0ZG91dCA9ICcnO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN0ZGVycikgcmVzdWx0LnN0ZGVyciA9ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChvdXRwdXQuZGF0YS5uYW1lID09PSAnc3Rkb3V0Jykge1xuICAgICAgICAgICAgcmVzdWx0LnN0ZG91dCArPSBvdXRwdXQuZGF0YS50ZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LmRhdGEubmFtZSA9PT0gJ3N0ZGVycicpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGRlcnIgKz0gb3V0cHV0LmRhdGEudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnR5cGUgPT09ICdkaXNwbGF5X2RhdGEnIHx8IG91dHB1dC50eXBlID09PSAnZXhlY3V0ZV9yZXN1bHQnKSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBkaXNwbGF5IGRhdGFcbiAgICAgICAgICBpZiAob3V0cHV0LmRhdGEuZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuZGF0YSwgb3V0cHV0LmRhdGEuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXQuZGF0YS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQubWV0YWRhdGEsIG91dHB1dC5kYXRhLm1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnR5cGUgPT09ICdleGVjdXRlX2Vycm9yJyB8fCBvdXRwdXQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBvdXRwdXQuZGF0YTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke2Vycm9yRGF0YS5lbmFtZX06ICR7ZXJyb3JEYXRhLmV2YWx1ZX1gKSxcbiAgICAgICAgICAgIGVuYW1lOiBlcnJvckRhdGEuZW5hbWUsXG4gICAgICAgICAgICBldmFsdWU6IGVycm9yRGF0YS5ldmFsdWUsXG4gICAgICAgICAgICB0cmFjZWJhY2s6IGVycm9yRGF0YS50cmFjZWJhY2ssXG4gICAgICAgICAgICBvdXRwdXRzOiByZXN1bHQub3V0cHV0c1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU3RvcmUgYW55IG90aGVyIG91dHB1dCB0eXBlXG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gY29sbGVjdGVkIHJlc3VsdHNcbiAgICAgIHJlc3VsdC5zdWNjZXNzID0gdHJ1ZTtcblxuICAgICAgLy8gQXV0by1zeW5jIG5hdGl2ZSBmaWxlc3lzdGVtcyBpZiBlbmFibGVkXG4gICAgICBpZiAodGhpcy5hdXRvU3luY0ZzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3luY0FsbE5hdGl2ZUZzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEV4ZWN1dGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgcmVzdWx0IGZyb20gdGhlIFB5b2RpZGUgZXZhbHVhdGlvblxuICAgKiBCYXNlZCBvbiBQeW9kaWRlUmVtb3RlS2VybmVsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFJlc3VsdChyZXM6IGFueSk6IGFueSB7XG4gICAgaWYgKCEocmVzIGluc3RhbmNlb2YgdGhpcy5weW9kaWRlLmZmaS5QeVByb3h5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgUHlQcm94eSB0byBKU1xuICAgICAgY29uc3QgbSA9IHJlcy50b0pzKCk7XG4gICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5tYXBUb09iamVjdChtKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZm9ybWF0dGluZyByZXN1bHQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTWFwIHRvIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICogQmFzZWQgb24gUHlvZGlkZVJlbW90ZUtlcm5lbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBtYXBUb09iamVjdChvYmo6IGFueSkge1xuICAgIGNvbnN0IG91dDogYW55ID0gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuICAgIFxuICAgIG9iai5mb3JFYWNoKCh2YWx1ZTogYW55LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgb3V0W2tleV0gPSBcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgID8gdGhpcy5tYXBUb09iamVjdCh2YWx1ZSlcbiAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGUgaW5wdXQgcmVwbHkgZnJvbSB1c2VyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5wdXRSZXBseShjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkoY29udGVudCk7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IG51bGw7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIGlucHV0IHJlcXVlc3QgdG8gdGhlIGZyb250LWVuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2VuZElucHV0UmVxdWVzdChwcm9tcHQ6IHN0cmluZywgcGFzc3dvcmQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgcHJvbXB0LFxuICAgICAgcGFzc3dvcmQsXG4gICAgfTtcblxuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICdpbnB1dF9yZXF1ZXN0JyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXNzd29yZCBpbnB1dCAod2l0aCBoaWRkZW4gaW5wdXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldHBhc3MocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb21wdCA9IHR5cGVvZiBwcm9tcHQgPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9tcHQ7XG4gICAgYXdhaXQgdGhpcy5zZW5kSW5wdXRSZXF1ZXN0KHByb21wdCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVwbHlQcm9taXNlID0gbmV3IFByb21pc2U8eyB2YWx1ZTogc3RyaW5nIH0+KChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbHlQcm9taXNlO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRleHQgaW5wdXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5wdXQocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb21wdCA9IHR5cGVvZiBwcm9tcHQgPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9tcHQ7XG4gICAgYXdhaXQgdGhpcy5zZW5kSW5wdXRSZXF1ZXN0KHByb21wdCwgZmFsc2UpO1xuICAgIGNvbnN0IHJlcGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlPHsgdmFsdWU6IHN0cmluZyB9PigocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGx5UHJvbWlzZTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIGNvbW0gbWVzc2FnZSB0byB0aGUgZnJvbnQtZW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZW5kQ29tbSh0eXBlOiBzdHJpbmcsIGNvbnRlbnQ6IGFueSwgbWV0YWRhdGE6IGFueSwgaWRlbnQ6IGFueSwgYnVmZmVyczogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KGNvbnRlbnQpLFxuICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgIGlkZW50OiB0aGlzLmZvcm1hdFJlc3VsdChpZGVudCksXG4gICAgICBidWZmZXJzOiB0aGlzLmZvcm1hdFJlc3VsdChidWZmZXJzKSxcbiAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgdGhlIGNvZGUgc3VibWl0dGVkIGJ5IGEgdXNlci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21wbGV0ZShjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IHRoZSBjb2RlIHN1Ym1pdHRlZCBieSBhIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5zcGVjdChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgZGV0YWlsX2xldmVsOiAwIHwgMSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgY29kZSBmb3IgY29tcGxldGVuZXNzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzQ29tcGxldGUoY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmlzX2NvbXBsZXRlKGNvZGUpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhdmFpbGFibGUgY29tbXMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbUluZm8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9pbmZvKHRhcmdldF9uYW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbXM6IHRoaXMuZm9ybWF0UmVzdWx0KHJlcyksXG4gICAgICBzdGF0dXM6ICdvaycsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1PcGVuKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fb3BlbihcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShjb250ZW50KVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0aHJvdWdoIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1Nc2coY29udGVudDogYW55LCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21tX21hbmFnZXIuY29tbV9tc2coXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xvc2UgYSBDT01NXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbUNsb3NlKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fY2xvc2UoXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgUHl0aG9uIGNvZGUgd2l0aCBzdHJlYW1pbmcgb3V0cHV0XG4gICAqIEBwYXJhbSBjb2RlIFRoZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgUGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIGludGVybWVkaWF0ZSBvdXRwdXRzIGFuZCBmaW5hbGx5IHRoZSBleGVjdXRpb24gcmVzdWx0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMqIGV4ZWN1dGVTdHJlYW0oY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSA9IHt9KTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJidXN5XCI7XG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5LRVJORUxfQlVTWSwge30pO1xuICAgICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgICAgLy8gQ3JlYXRlIGV2ZW50IGxpc3RlbmVycyBmb3Igc3RyZWFtaW5nXG4gICAgICBjb25zdCBldmVudFF1ZXVlOiBJRXZlbnREYXRhW10gPSBbXTtcbiAgICAgIGxldCBleGVjdXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgbGV0IGV4ZWN1dGlvblJlc3VsdDogYW55ID0gbnVsbDtcbiAgICAgIGxldCBleGVjdXRpb25FcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICAgIFxuICAgICAgY29uc3QgaGFuZGxlQWxsRXZlbnRzID0gKGV2ZW50RGF0YTogSUV2ZW50RGF0YSkgPT4ge1xuICAgICAgICBldmVudFF1ZXVlLnB1c2goZXZlbnREYXRhKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgYWxsIGV2ZW50cyBCRUZPUkUgZXhlY3V0aW5nIGNvZGVcbiAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5BTEwsIGhhbmRsZUFsbEV2ZW50cyk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvZGUgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5fa2VybmVsLnJ1bihjb2RlKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gUHl0aG9uIGV4ZWN1dGlvbiBmaW5pc2hlZFwiKTtcbiAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB0aGlzLmZvcm1hdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZXN1bHQgaW5kaWNhdGVzIGFuIGVycm9yIGFuZCBlbWl0IGl0IGFzIGFuIGV2ZW50XG4gICAgICAgICAgaWYgKGV4ZWN1dGlvblJlc3VsdCAmJiBleGVjdXRpb25SZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEV4ZWN1dGlvbiBjb21wbGV0ZWQgd2l0aCBlcnJvciBzdGF0dXMsIGVtaXR0aW5nIGV4ZWN1dGVfZXJyb3IgZXZlbnRcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVtaXQgdGhlIGVycm9yIGV2ZW50IHNvIHRoZSBVSSBjYW4gZGlzcGxheSBpdFxuICAgICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgICAgICAgYnVuZGxlOiB7XG4gICAgICAgICAgICAgICAgZW5hbWU6IGV4ZWN1dGlvblJlc3VsdC5lbmFtZSB8fCAnRXJyb3InLFxuICAgICAgICAgICAgICAgIGV2YWx1ZTogZXhlY3V0aW9uUmVzdWx0LmV2YWx1ZSB8fCAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgdHJhY2ViYWNrOiBleGVjdXRpb25SZXN1bHQudHJhY2ViYWNrIHx8IFtdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGEgc21hbGwgYW1vdW50IG9mIHRpbWUgZm9yIGFueSByZW1haW5pbmcgbWVzc2FnZXMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgfSwgMTAwKTsgLy8gMTAwbXMgc2hvdWxkIGJlIGVub3VnaCBmb3IgbWVzc2FnZSBwcm9jZXNzaW5nXG4gICAgICAgICAgXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIFB5dGhvbiBleGVjdXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICBleGVjdXRpb25FcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGlsbCB3YWl0IGZvciBtZXNzYWdlcyB0byBzZXR0bGUgYmVmb3JlIGNvbXBsZXRpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0cmVhbSBldmVudHMgYXMgdGhleSBhcnJpdmVcbiAgICAgICAgd2hpbGUgKCFleGVjdXRpb25Db21wbGV0ZSB8fCBldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBZaWVsZCBxdWV1ZWQgZXZlbnRzXG4gICAgICAgICAgaWYgKGV2ZW50UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIG1vcmUgZXZlbnRzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZmluYWwgcmVzdWx0XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLktFUk5FTF9JRExFLCB7fSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhlY3V0aW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXhlY3V0aW9uRXJyb3IsXG4gICAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHJlc3VsdCBpbmRpY2F0ZXMgYW4gZXJyb3JcbiAgICAgICAgaWYgKGV4ZWN1dGlvblJlc3VsdCAmJiBleGVjdXRpb25SZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgJHtleGVjdXRpb25SZXN1bHQuZW5hbWUgfHwgJ0Vycm9yJ306ICR7ZXhlY3V0aW9uUmVzdWx0LmV2YWx1ZSB8fCAnVW5rbm93biBlcnJvcid9YDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGVycm9yTXNnKSxcbiAgICAgICAgICAgIHJlc3VsdDogZXhlY3V0aW9uUmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1dG8tc3luYyBuYXRpdmUgZmlsZXN5c3RlbXMgaWYgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5hdXRvU3luY0ZzKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zeW5jQWxsTmF0aXZlRnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICB9O1xuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBDbGVhbiB1cCBsaXN0ZW5lclxuICAgICAgICBzdXBlci5vZmYoS2VybmVsRXZlbnRzLkFMTCwgaGFuZGxlQWxsRXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0tFUk5FTF0gRXhlY3V0ZVN0cmVhbSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLktFUk5FTF9JRExFLCB7fSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIHB1YmxpYyBhc3luYyBpbnRlcnJ1cHQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkIHx8ICF0aGlzLnB5b2RpZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltLRVJORUxdIENhbm5vdCBpbnRlcnJ1cHQ6IGtlcm5lbCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gQXR0ZW1wdGluZyB0byBpbnRlcnJ1cHQgZXhlY3V0aW9uLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBwcmlvcml0eTogVXNlIGludGVycnVwdCBidWZmZXIgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5faW50ZXJydXB0QnVmZmVyICYmIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFVzaW5nIGludGVycnVwdCBidWZmZXIgbWV0aG9kXCIpO1xuICAgICAgICAvLyBTZXQgaW50ZXJydXB0IHNpZ25hbCAoMiA9IFNJR0lOVClcbiAgICAgICAgdGhpcy5faW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgICAgXG4gICAgICAgIC8vIEdpdmUgdGhlIGludGVycnVwdCBhIG1vbWVudCB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGludGVycnVwdCB3YXMgcHJvY2Vzc2VkIChidWZmZXIgc2hvdWxkIGJlIHJlc2V0IHRvIDApXG4gICAgICAgIGNvbnN0IHdhc1Byb2Nlc3NlZCA9IHRoaXMuX2ludGVycnVwdEJ1ZmZlclswXSA9PT0gMDtcbiAgICAgICAgaWYgKHdhc1Byb2Nlc3NlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gSW50ZXJydXB0IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkgdmlhIGJ1ZmZlclwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZWNvbmQgcHJpb3JpdHk6IFRyeSBQeXRob24tbGV2ZWwgaW50ZXJydXB0XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEF0dGVtcHRpbmcgUHl0aG9uLWxldmVsIGludGVycnVwdFwiKTtcbiAgICAgICAgLy8gVHJ5IHRvIHJhaXNlIEtleWJvYXJkSW50ZXJydXB0IGluIFB5dGhvblxuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IHN5c1xuaW1wb3J0IF90aHJlYWRcbiMgVHJ5IHRvIGludGVycnVwdCB0aGUgbWFpbiB0aHJlYWRcbl90aHJlYWQuaW50ZXJydXB0X21haW4oKVxuYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gUHl0aG9uIGludGVycnVwdCBzaWduYWwgc2VudFwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChweXRob25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFB5dGhvbiBpbnRlcnJ1cHQgYXR0ZW1wdCBmYWlsZWQ6XCIsIHB5dGhvbkVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGhpcmQgcHJpb3JpdHk6IFRyeSBpbnRlcnByZXRlciBpbnRlcnJ1cHQgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5faW50ZXJwcmV0ZXIgJiYgdHlwZW9mIHRoaXMuX2ludGVycHJldGVyLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFVzaW5nIGludGVycHJldGVyIGludGVycnVwdCBtZXRob2RcIik7XG4gICAgICAgIHRoaXMuX2ludGVycHJldGVyLmludGVycnVwdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTGFzdCByZXNvcnQ6IFNlbmQgaW50ZXJydXB0IG1lc3NhZ2VzIGZvciBVSSBmZWVkYmFja1xuICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBTZW5kaW5nIGludGVycnVwdCBtZXNzYWdlcyBmb3IgVUkgZmVlZGJhY2tcIik7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgc3RkZXJyIHN0cmVhbSBmaXJzdCAoZm9yIEp1cHl0ZXIgbm90ZWJvb2sgVUkgY29tcGF0aWJpbGl0eSlcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgIG5hbWU6ICdzdGRlcnInLFxuICAgICAgICAgIHRleHQ6ICdLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcXG4nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgICAgYnVuZGxlOiB7XG4gICAgICAgICAgZW5hbWU6ICdLZXlib2FyZEludGVycnVwdCcsXG4gICAgICAgICAgZXZhbHVlOiAnRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXInLFxuICAgICAgICAgIHRyYWNlYmFjazogWydLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXInXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGZhbHNlIHNpbmNlIHdlIGNvdWxkbid0IGFjdHVhbGx5IGludGVycnVwdCB0aGUgZXhlY3V0aW9uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFcnJvciBkdXJpbmcgaW50ZXJydXB0OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldEludGVycnVwdEJ1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLl9pbnRlcnJ1cHRCdWZmZXIgPSBidWZmZXI7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHlvZGlkZSAmJiB0eXBlb2YgdGhpcy5weW9kaWRlLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnB5b2RpZGUuc2V0SW50ZXJydXB0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbS0VSTkVMXSBweW9kaWRlLnNldEludGVycnVwdEJ1ZmZlciBub3QgYXZhaWxhYmxlLCBpbnRlcnJ1cHQgc3VwcG9ydCBsaW1pdGVkXCIpO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEVycm9yIHNldHRpbmcgaW50ZXJydXB0IGJ1ZmZlcjpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5faW50ZXJydXB0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhbmQgcmVxdWVzdCBwZXJtaXNzaW9uIGZvciBhIGZpbGUgc3lzdGVtIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2ZXJpZnlQZXJtaXNzaW9uKFxuICAgIGZpbGVIYW5kbGU6IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsXG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSdcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgb3B0czogYW55ID0ge307XG4gICAgaWYgKHBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICBvcHRzLm1vZGUgPSAncmVhZHdyaXRlJztcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVmVyaWZ5aW5nICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBmb3IgZmlsZSBoYW5kbGUuLi5gKTtcblxuICAgIC8vIENoZWNrIGlmIHBlcm1pc3Npb24gQVBJcyBhcmUgc3VwcG9ydGVkXG4gICAgaWYgKHR5cGVvZiAoZmlsZUhhbmRsZSBhcyBhbnkpLnF1ZXJ5UGVybWlzc2lvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdbS0VSTkVMXSBxdWVyeVBlcm1pc3Npb24gbm90IHN1cHBvcnRlZCwgYXNzdW1pbmcgcGVybWlzc2lvbiBncmFudGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHBlcm1pc3Npb24sIGlmIHNvLCByZXR1cm4gdHJ1ZS5cbiAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgKGZpbGVIYW5kbGUgYXMgYW55KS5xdWVyeVBlcm1pc3Npb24ob3B0cyk7XG4gICAgICBjb25zb2xlLmxvZygnW0tFUk5FTF0gUXVlcnkgcmVzdWx0OicsIHF1ZXJ5UmVzdWx0KTtcbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5UmVzdWx0ID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gYWxyZWFkeSBncmFudGVkIGZvciAke3Blcm1pc3Npb259IGFjY2Vzc2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVxdWVzdCBwZXJtaXNzaW9uIHRvIHRoZSBmaWxlLCBpZiB0aGUgdXNlciBncmFudHMgcGVybWlzc2lvbiwgcmV0dXJuIHRydWUuXG4gICAgICBpZiAodHlwZW9mIChmaWxlSGFuZGxlIGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFJlcXVlc3RpbmcgJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9uIGZyb20gdXNlci4uLmApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0UmVzdWx0ID0gYXdhaXQgKGZpbGVIYW5kbGUgYXMgYW55KS5yZXF1ZXN0UGVybWlzc2lvbihvcHRzKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0tFUk5FTF0gUmVxdWVzdCByZXN1bHQ6JywgcmVxdWVzdFJlc3VsdCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJlcXVlc3RSZXN1bHQgPT09ICdncmFudGVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gZ3JhbnRlZCBmb3IgJHtwZXJtaXNzaW9ufSBhY2Nlc3NgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVxdWVzdEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tLRVJORUxdIFBlcm1pc3Npb24gcmVxdWVzdCBmYWlsZWQgb3Igd2FzIGRpc21pc3NlZDonLCByZXF1ZXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSB1c2VyIGRpZCBub3QgZ3JhbnQgcGVybWlzc2lvbiwgcmV0dXJuIGZhbHNlLlxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBub3QgZ3JhbnRlZGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tLRVJORUxdIEVycm9yIGNoZWNraW5nIHBlcm1pc3Npb246JywgZXJyb3IpO1xuICAgICAgLy8gSWYgcGVybWlzc2lvbiBjaGVjayBmYWlscywgYXNzdW1lIGl0J3MgZ3JhbnRlZCAobW9yZSBwZXJtaXNzaXZlIGFwcHJvYWNoKVxuICAgICAgY29uc29sZS53YXJuKCdbS0VSTkVMXSBQZXJtaXNzaW9uIGNoZWNrIGZhaWxlZCwgYXNzdW1pbmcgZ3JhbnRlZCBhcyBmYWxsYmFjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IGEgbmF0aXZlIGZpbGUgc3lzdGVtIGRpcmVjdG9yeSBpbnRvIHRoZSBQeW9kaWRlIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCB3aGVyZSB0aGUgZGlyZWN0b3J5IHNob3VsZCBiZSBtb3VudGVkIGluIHRoZSBQeXRob24gZmlsZXN5c3RlbVxuICAgKiBAcGFyYW0gZGlySGFuZGxlIE9wdGlvbmFsIEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUuIElmIG51bGwvdW5kZWZpbmVkLCBzaG93cyBkaXJlY3RvcnkgcGlja2VyXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9uIFBlcm1pc3Npb24gbW9kZTpcbiAgICogICAtICdyZWFkJzogUmVhZC1vbmx5IGFjY2Vzcywgbm8gc3luY2luZyBjYXBhYmlsaXRpZXMsIGF1dG8tc3luYyB3aWxsIGJlIHNraXBwZWQgKGRlZmF1bHQpXG4gICAqICAgLSAncmVhZHdyaXRlJzogRnVsbCByZWFkL3dyaXRlIGFjY2VzcyB3aXRoIHN5bmNpbmcgY2FwYWJpbGl0aWVzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgaGFuZGxlIHdpdGggc3luY2ZzKCkgbWV0aG9kIGZvciBzeW5jaW5nIGNoYW5nZXNcbiAgICogQG5vdGUgc3luY2ZzKCkgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb24gYSByZWFkLW9ubHkgbW91bnRlZCBmaWxlc3lzdGVtXG4gICAqIEBub3RlIE1hbnkgYnJvd3NlcnMgb25seSBvZmZlciByZWFkIHBlcm1pc3Npb24gaW5pdGlhbGx5LiBFeHBsaWNpdGx5IHJlcXVlc3QgJ3JlYWR3cml0ZScgaWYgeW91IG5lZWQgd3JpdGUgYWNjZXNzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIG1vdW50RlMoXG4gICAgbW91bnRQYXRoOiBzdHJpbmcsXG4gICAgZGlySGFuZGxlPzogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8IG51bGwsXG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZScgPSAncmVhZCdcbiAgKTogUHJvbWlzZTx7IHN5bmNmczogKCkgPT4gUHJvbWlzZTx2b2lkPiB9PiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkIHx8ICF0aGlzLnB5b2RpZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBtdXN0IGJlIGluaXRpYWxpemVkIGJlZm9yZSBtb3VudGluZyBmaWxlc3lzdGVtXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIG1vdW50TmF0aXZlRlMgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB0aGlzLnB5b2RpZGUubW91bnROYXRpdmVGUyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHlvZGlkZS5tb3VudE5hdGl2ZUZTIGlzIG5vdCBhdmFpbGFibGUuIE1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgUHlvZGlkZSAwLjIzLjAgb3IgbGF0ZXIuXCIpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGUgPSBkaXJIYW5kbGU7XG5cbiAgICAvLyBJZiBubyBkaXJIYW5kbGUgcHJvdmlkZWQsIHNob3cgZGlyZWN0b3J5IHBpY2tlclxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBhIHdvcmtlciBjb250ZXh0XG4gICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNob3cgZGlyZWN0b3J5IHBpY2tlciBpbiB3b3JrZXIgY29udGV4dC4gUGxlYXNlIHByb3ZpZGUgYSBkaXJIYW5kbGUgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgc2hvd0RpcmVjdG9yeVBpY2tlciBpcyBhdmFpbGFibGVcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2hvd0RpcmVjdG9yeVBpY2tlcicgaW4gd2luZG93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlID0gYXdhaXQgKHdpbmRvdyBhcyBhbnkpLnNob3dEaXJlY3RvcnlQaWNrZXIoe1xuICAgICAgICAgICAgbW9kZTogJ3JlYWR3cml0ZScsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2hvdyBkaXJlY3RvcnkgcGlja2VyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hvd0RpcmVjdG9yeVBpY2tlciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gUGxlYXNlIHByb3ZpZGUgYSBkaXJIYW5kbGUgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGlyZWN0b3J5IGhhbmRsZSBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IGFuZCByZXF1ZXN0IHBlcm1pc3Npb25zIGJlZm9yZSBtb3VudGluZ1xuICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBWZXJpZnlpbmcgJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9ucyBiZWZvcmUgbW91bnRpbmcuLi5gKTtcbiAgICBjb25zdCBoYXNSZXF1ZXN0ZWRQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQZXJtaXNzaW9uKGhhbmRsZSwgcGVybWlzc2lvbik7XG4gICAgXG4gICAgaWYgKCFoYXNSZXF1ZXN0ZWRQZXJtaXNzaW9uKSB7XG4gICAgICBpZiAocGVybWlzc2lvbiA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gb2J0YWluIHdyaXRlIHBlcm1pc3Npb24gZm9yIGRpcmVjdG9yeS4gYCArXG4gICAgICAgICAgYFRoZSBicm93c2VyIG1heSBvbmx5IGJlIG9mZmVyaW5nIHJlYWQgcGVybWlzc2lvbi4gYCArXG4gICAgICAgICAgYFRyeSBtb3VudGluZyB3aXRoIHBlcm1pc3Npb246ICdyZWFkJyBpZiB5b3Ugb25seSBuZWVkIHRvIHJlYWQgZmlsZXMsIGAgK1xuICAgICAgICAgIGBvciBlbnN1cmUgdGhlIGJyb3dzZXIgc3VwcG9ydHMgd3JpdGUgYWNjZXNzIHRvIHRoaXMgZGlyZWN0b3J5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9idGFpbiAke3Blcm1pc3Npb259IHBlcm1pc3Npb24gZm9yIGRpcmVjdG9yeS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgYWN0dWFsUGVybWlzc2lvbiA9IHBlcm1pc3Npb247XG5cbiAgICAvLyBNb3VudCB0aGUgbmF0aXZlIGZpbGVzeXN0ZW1cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIE1vdW50aW5nIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofSB3aXRoICR7YWN0dWFsUGVybWlzc2lvbn0gcGVybWlzc2lvbmApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbW91bnQgcG9pbnQgYWxyZWFkeSBleGlzdHMgYW5kIGhhbmRsZSBjbGVhbnVwXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXRoSW5mbyA9IHRoaXMucHlvZGlkZS5GUy5hbmFseXplUGF0aChtb3VudFBhdGgpO1xuICAgICAgICBpZiAocGF0aEluZm8uZXhpc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhdGggJHttb3VudFBhdGh9IGV4aXN0cywgY2hlY2tpbmcgaWYgaXQncyBhIG1vdW50IHBvaW50YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHVubW91bnQgaWYgaXQncyBhbHJlYWR5IG1vdW50ZWRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLkZTLnVubW91bnQobW91bnRQYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTdWNjZXNzZnVsbHkgdW5tb3VudGVkIGV4aXN0aW5nIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAodW5tb3VudEVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB1bm1vdW50IGZhaWxzLCBpdCBtaWdodCBub3QgYmUgYSBtb3VudCBwb2ludCBvciBtaWdodCBiZSBidXN5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVW5tb3VudCBmYWlsZWQgKHRoaXMgaXMgbm9ybWFsIGlmIG5vdCBtb3VudGVkKTogJHt1bm1vdW50RXJyb3J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZGlyZWN0b3J5IGlmIGl0IGV4aXN0cyBidXQgaXMgZW1wdHlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5weW9kaWRlLkZTLnJtZGlyKG1vdW50UGF0aCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUmVtb3ZlZCBleGlzdGluZyBkaXJlY3RvcnkgYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAocm1kaXJFcnJvcikge1xuICAgICAgICAgICAgLy8gRGlyZWN0b3J5IG1pZ2h0IG5vdCBiZSBlbXB0eSBvciBtaWdodCBub3QgZXhpc3QsIHRoYXQncyBva2F5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ291bGQgbm90IHJlbW92ZSBkaXJlY3RvcnkgKHRoaXMgaXMgbm9ybWFsKTogJHtybWRpckVycm9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoYW5hbHl6ZUVycm9yKSB7XG4gICAgICAgIC8vIGFuYWx5emVQYXRoIG1pZ2h0IGZhaWwsIHRoYXQncyBva2F5IC0gdGhlIHBhdGggcHJvYmFibHkgZG9lc24ndCBleGlzdFxuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUGF0aCBhbmFseXNpcyBmYWlsZWQgKHBhdGggcHJvYmFibHkgZG9lc24ndCBleGlzdCk6ICR7YW5hbHl6ZUVycm9yfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICBjb25zdCBwYXJlbnRQYXRoID0gbW91bnRQYXRoLnN1YnN0cmluZygwLCBtb3VudFBhdGgubGFzdEluZGV4T2YoJy8nKSkgfHwgJy8nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGggIT09ICcvJyAmJiAhdGhpcy5weW9kaWRlLkZTLmFuYWx5emVQYXRoKHBhcmVudFBhdGgpLmV4aXN0cykge1xuICAgICAgICAgIHRoaXMucHlvZGlkZS5GUy5ta2RpcihwYXJlbnRQYXRoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ3JlYXRlZCBwYXJlbnQgZGlyZWN0b3J5ICR7cGFyZW50UGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocGFyZW50RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhcmVudCBkaXJlY3RvcnkgaGFuZGxpbmc6ICR7cGFyZW50RXJyb3J9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG5hdGl2ZWZzID0gYXdhaXQgdGhpcy5weW9kaWRlLm1vdW50TmF0aXZlRlMobW91bnRQYXRoLCBoYW5kbGUpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9IHdpdGggJHthY3R1YWxQZXJtaXNzaW9ufSBwZXJtaXNzaW9uYCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGhhbmRsZSB3aXRoIHN5bmNmcyBtZXRob2QgYW5kIHBlcm1pc3Npb24gcmVjb3ZlcnlcbiAgICAgIGNvbnN0IGZzSGFuZGxlID0ge1xuICAgICAgICBzeW5jZnM6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlc3lzdGVtIGlzIHJlYWQtb25seVxuICAgICAgICAgIGlmIChhY3R1YWxQZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN5bmMgcmVhZC1vbmx5IGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9LiBVc2UgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uKCkgdG8gcmVxdWVzdCB3cml0ZSBhY2Nlc3MuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBuYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpckhhbmRsZTogaGFuZGxlLFxuICAgICAgICBwZXJtaXNzaW9uOiBhY3R1YWxQZXJtaXNzaW9uLFxuICAgICAgICBuYXRpdmVmczogbmF0aXZlZnNcbiAgICAgIH07XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoYW5kbGUgZm9yIGF1dG8tc3luY1xuICAgICAgdGhpcy5uYXRpdmVGc0hhbmRsZXMuc2V0KG1vdW50UGF0aCwgZnNIYW5kbGUpO1xuXG4gICAgICByZXR1cm4geyBzeW5jZnM6IGZzSGFuZGxlLnN5bmNmcyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBtb3VudCBuYXRpdmUgZmlsZXN5c3RlbTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmMgYWxsIG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW1zIHdpdGggcGVybWlzc2lvbiByZWNvdmVyeVxuICAgKiBPbmx5IHN5bmNzIGZpbGVzeXN0ZW1zIG1vdW50ZWQgd2l0aCAncmVhZHdyaXRlJyBwZXJtaXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHN5bmNBbGxOYXRpdmVGcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5uYXRpdmVGc0hhbmRsZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bmNSZXN1bHRzOiBBcnJheTx7IG1vdW50UGF0aDogc3RyaW5nOyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgc2tpcHBlZD86IGJvb2xlYW4gfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21vdW50UGF0aCwgZnNIYW5kbGVdIG9mIHRoaXMubmF0aXZlRnNIYW5kbGVzLmVudHJpZXMoKSkge1xuICAgICAgLy8gU2tpcCByZWFkLW9ubHkgZmlsZXN5c3RlbXNcbiAgICAgIGlmIChmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSwgc2tpcHBlZDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFNraXBwaW5nIHN5bmMgZm9yIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzeW5jIGRpcmVjdGx5XG4gICAgICAgIGF3YWl0IGZzSGFuZGxlLnN5bmNmcygpO1xuICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgbW91bnRQYXRoLCBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IHN5bmNlZCBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc3luYyBmYWlscywgY2hlY2sgaWYgaXQncyBhIHBlcm1pc3Npb24gZXJyb3JcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm90IGFsbG93ZWQgYnkgdGhlIHVzZXIgYWdlbnQnKSB8fCBcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2V0RmlsZUhhbmRsZScpIHx8XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUud2FybihgW0tFUk5FTF0gUGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofSwgYXR0ZW1wdGluZyByZWNvdmVyeS4uLmApO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmVjb3ZlciBieSByZS12ZXJpZnlpbmcgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCBmc0hhbmRsZS5wZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlbW91bnQgYW5kIHN5bmNcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gcmVjb3ZlcmVkIGZvciAke21vdW50UGF0aH0sIGF0dGVtcHRpbmcgcmVtb3VudC4uLmApO1xuICAgICAgICAgICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RvcmVkIGhhbmRsZSB3aXRoIHRoZSBuZXcgbmF0aXZlZnNcbiAgICAgICAgICAgICAgZnNIYW5kbGUubmF0aXZlZnMgPSBuZXdOYXRpdmVmcztcbiAgICAgICAgICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXdOYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN5bmMgZmlsZXN5c3RlbTogJHtzeW5jRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHN5bmNFcnJvci5tZXNzYWdlIDogU3RyaW5nKHN5bmNFcnJvcil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVHJ5IHN5bmMgYWdhaW4gd2l0aCB0aGUgbmV3IGhhbmRsZVxuICAgICAgICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSByZWNvdmVyZWQgYW5kIHN5bmNlZCBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IFxuICAgICAgICAgICAgICAgIG1vdW50UGF0aCwgXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICAgIGVycm9yOiAnUGVybWlzc2lvbiBkZW5pZWQgYnkgdXNlcicgXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtLRVJORUxdIFVzZXIgZGVuaWVkIHBlcm1pc3Npb24gZm9yICR7bW91bnRQYXRofSwgc2tpcHBpbmcgc3luY2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHJlY292ZXJ5RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY292ZXJ5TWVzc2FnZSA9IHJlY292ZXJ5RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJlY292ZXJ5RXJyb3IubWVzc2FnZSA6IFN0cmluZyhyZWNvdmVyeUVycm9yKTtcbiAgICAgICAgICAgIHN5bmNSZXN1bHRzLnB1c2goeyBcbiAgICAgICAgICAgICAgbW91bnRQYXRoLCBcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICBlcnJvcjogYFJlY292ZXJ5IGZhaWxlZDogJHtyZWNvdmVyeU1lc3NhZ2V9YCBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0tFUk5FTF0gRmFpbGVkIHRvIHJlY292ZXIgcGVybWlzc2lvbnMgZm9yICR7bW91bnRQYXRofTpgLCByZWNvdmVyeUVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLXBlcm1pc3Npb24gZXJyb3JcbiAgICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgXG4gICAgICAgICAgICBtb3VudFBhdGgsIFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbS0VSTkVMXSBOb24tcGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb2cgc3VtbWFyeVxuICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MgJiYgIXIuc2tpcHBlZCkubGVuZ3RoO1xuICAgIGNvbnN0IHNraXBwZWQgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiByLnNraXBwZWQpLmxlbmd0aDtcbiAgICBjb25zdCBmYWlsZWQgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICBcbiAgICBpZiAoc3VjY2Vzc2Z1bCA+IDAgfHwgc2tpcHBlZCA+IDApIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBpZiAoc3VjY2Vzc2Z1bCA+IDApIHBhcnRzLnB1c2goYCR7c3VjY2Vzc2Z1bH0gc3luY2VkYCk7XG4gICAgICBpZiAoc2tpcHBlZCA+IDApIHBhcnRzLnB1c2goYCR7c2tpcHBlZH0gcmVhZC1vbmx5IHNraXBwZWRgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBBdXRvLXN5bmMgY29tcGxldGVkOiAke3BhcnRzLmpvaW4oJywgJyl9ICgke3N5bmNSZXN1bHRzLmxlbmd0aH0gdG90YWwgZmlsZXN5c3RlbXMpYCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmYWlsZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBbS0VSTkVMXSBBdXRvLXN5bmMgaXNzdWVzOmAsIGZhaWxlZC5tYXAoZiA9PiBgJHtmLm1vdW50UGF0aH06ICR7Zi5lcnJvcn1gKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHRocm93IC0gd2UgZG9uJ3Qgd2FudCB0byBmYWlsIGV4ZWN1dGlvbiBqdXN0IGJlY2F1c2Ugc3luYyBmYWlsZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgbW91bnRlZCBuYXRpdmUgZmlsZXN5c3RlbXMgYW5kIHRoZWlyIHBlcm1pc3Npb24gc3RhdHVzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIG1vdW50ZWQgZmlsZXN5c3RlbSBpbmZvcm1hdGlvblxuICAgKi9cbiAgcHVibGljIGdldE1vdW50ZWRGaWxlU3lzdGVtcygpOiBBcnJheTx7XG4gICAgbW91bnRQYXRoOiBzdHJpbmc7XG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSc7XG4gICAgY2FuU3luYzogYm9vbGVhbjtcbiAgfT4ge1xuICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8e1xuICAgICAgbW91bnRQYXRoOiBzdHJpbmc7XG4gICAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICAgIGNhblN5bmM6IGJvb2xlYW47XG4gICAgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21vdW50UGF0aCwgZnNIYW5kbGVdIG9mIHRoaXMubmF0aXZlRnNIYW5kbGVzLmVudHJpZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBtb3VudFBhdGgsXG4gICAgICAgIHBlcm1pc3Npb246IGZzSGFuZGxlLnBlcm1pc3Npb24sXG4gICAgICAgIGNhblN5bmM6IGZzSGFuZGxlLnBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHN5bmMgYSBzcGVjaWZpYyBtb3VudGVkIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgbW91bnRlZCBmaWxlc3lzdGVtIHRvIHN5bmNcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3VjY2VzcyBzdGF0dXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW5jRmlsZVN5c3RlbShtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgZnNIYW5kbGUgPSB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5nZXQobW91bnRQYXRoKTtcbiAgICBcbiAgICBpZiAoIWZzSGFuZGxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBObyBmaWxlc3lzdGVtIG1vdW50ZWQgYXQgJHttb3VudFBhdGh9YFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBmaWxlc3lzdGVtIGlzIHJlYWQtb25seVxuICAgIGlmIChmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogYENhbm5vdCBzeW5jIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofS4gTW91bnQgd2l0aCAncmVhZHdyaXRlJyBwZXJtaXNzaW9uIHRvIGVuYWJsZSBzeW5jaW5nLmBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzSGFuZGxlLnN5bmNmcygpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFRyeSBwZXJtaXNzaW9uIHJlY292ZXJ5IGlmIGl0J3MgYSBwZXJtaXNzaW9uIGVycm9yXG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdub3QgYWxsb3dlZCBieSB0aGUgdXNlciBhZ2VudCcpIHx8IFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2V0RmlsZUhhbmRsZScpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdwZXJtaXNzaW9uJykpIHtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQZXJtaXNzaW9uIGVycm9yIHN5bmNpbmcgJHttb3VudFBhdGh9LCBhdHRlbXB0aW5nIHJlY292ZXJ5Li4uYCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCBmc0hhbmRsZS5wZXJtaXNzaW9uKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbikge1xuICAgICAgICAgICAgLy8gUmVtb3VudCBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgICAgICAgIGZzSGFuZGxlLm5hdGl2ZWZzID0gbmV3TmF0aXZlZnM7XG4gICAgICAgICAgICBmc0hhbmRsZS5zeW5jZnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3TmF0aXZlZnMuc3luY2ZzKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN5bmNlZCBjaGFuZ2VzIHRvIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzeW5jIGZpbGVzeXN0ZW06ICR7c3luY0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzeW5jRXJyb3IubWVzc2FnZSA6IFN0cmluZyhzeW5jRXJyb3IpfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiAnUGVybWlzc2lvbiBkZW5pZWQgYnkgdXNlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChyZWNvdmVyeUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGBSZWNvdmVyeSBmYWlsZWQ6ICR7cmVjb3ZlcnlFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gcmVjb3ZlcnlFcnJvci5tZXNzYWdlIDogU3RyaW5nKHJlY292ZXJ5RXJyb3IpfWBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIGEgbW91bnRlZCBmaWxlc3lzdGVtIGZyb20gcmVhZC1vbmx5IHRvIHJlYWQtd3JpdGUgcGVybWlzc2lvblxuICAgKiBAcGFyYW0gbW91bnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBtb3VudGVkIGZpbGVzeXN0ZW0gdG8gdXBncmFkZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdWNjZXNzIHN0YXR1c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbihtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgZnNIYW5kbGUgPSB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5nZXQobW91bnRQYXRoKTtcbiAgICBcbiAgICBpZiAoIWZzSGFuZGxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBObyBmaWxlc3lzdGVtIG1vdW50ZWQgYXQgJHttb3VudFBhdGh9YFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoZnNIYW5kbGUucGVybWlzc2lvbiA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGVycm9yOiBgRmlsZVN5c3RlbSBhdCAke21vdW50UGF0aH0gYWxyZWFkeSBoYXMgcmVhZHdyaXRlIHBlcm1pc3Npb25gXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQXR0ZW1wdGluZyB0byB1cGdyYWRlICR7bW91bnRQYXRofSB0byByZWFkd3JpdGUgcGVybWlzc2lvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBUcnkgdG8gZ2V0IHJlYWR3cml0ZSBwZXJtaXNzaW9uXG4gICAgICBjb25zdCBoYXNXcml0ZVBlcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCAncmVhZHdyaXRlJyk7XG4gICAgICBcbiAgICAgIGlmICghaGFzV3JpdGVQZXJtaXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdVc2VyIGRlbmllZCB3cml0ZSBwZXJtaXNzaW9uIG9yIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3cml0ZSBhY2Nlc3MgdG8gdGhpcyBkaXJlY3RvcnknXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW91bnQgd2l0aCB3cml0ZSBwZXJtaXNzaW9uXG4gICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBzdG9yZWQgaGFuZGxlXG4gICAgICBmc0hhbmRsZS5wZXJtaXNzaW9uID0gJ3JlYWR3cml0ZSc7XG4gICAgICBmc0hhbmRsZS5uYXRpdmVmcyA9IG5ld05hdGl2ZWZzO1xuICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5ld05hdGl2ZWZzLnN5bmNmcygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgfSBjYXRjaCAoc3luY0Vycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke3N5bmNFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gc3luY0Vycm9yLm1lc3NhZ2UgOiBTdHJpbmcoc3luY0Vycm9yKX1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSB1cGdyYWRlZCAke21vdW50UGF0aH0gdG8gcmVhZHdyaXRlIHBlcm1pc3Npb25gKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gdXBncmFkZSBwZXJtaXNzaW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGggcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAqIE9QVElNSVpFRDogUGFyYWxsZWwgdmFyaWFibGUgc2V0dGluZyBhbmQgdmFsaWRhdGlvbiB3aXRoIHByb3BlciBlc2NhcGluZyBhbmQgZWRnZSBjYXNlIGhhbmRsaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldEVudmlyb25tZW50VmFyaWFibGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gTm8gdmFyaWFibGVzIHRvIHNldFxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKGDwn4yNIFNldHRpbmcgJHtPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGh9IGVudmlyb25tZW50IHZhcmlhYmxlcy4uLmApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTZXQgZWFjaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbmRpdmlkdWFsbHkgdG8gYXZvaWQgZXNjYXBpbmcgaXNzdWVzXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKSkge1xuICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlczogbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGxldCBwcm9jZXNzZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCB1bmRlZmluZWQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSBTdHJpbmcodmFsdWUpOyAgLy8gQ29udmVydCBldmVyeXRoaW5nIGVsc2UgdG8gc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5ydW5QeXRob25Bc3luYyhgXG5pbXBvcnQgb3Ncbm9zLmVudmlyb25bJHtKU09OLnN0cmluZ2lmeShrZXkpfV0gPSAke0pTT04uc3RyaW5naWZ5KHByb2Nlc3NlZFZhbHVlKX1cbmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXQgaW4gJHtkdXJhdGlvbn1tc2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gT25seSBQeXRob24ga2VybmVsIGlzIHN1cHBvcnRlZFxuXG4vLyBFeHBvcnQgdGhlIG1hbmFnZXIgZm9yIGFkdmFuY2VkIHVzYWdlXG5leHBvcnQgeyBLZXJuZWxNYW5hZ2VyIH0gZnJvbSBcIi4vbWFuYWdlclwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n\n}");

/***/ }),

/***/ "./src/manager.ts":
/*!************************!*\
  !*** ./src/manager.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelLanguage: () => (/* binding */ KernelLanguage),\n/* harmony export */   KernelManager: () => (/* binding */ KernelManager),\n/* harmony export */   KernelMode: () => (/* binding */ KernelMode)\n/* harmony export */ });\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    removeListener(eventName, listener) {\n        this.off(eventName, listener);\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n\n\n// Re-export KernelEvents for test usage\n\n// Execution mode enum\nvar KernelMode;\n(function (KernelMode) {\n    KernelMode[\"MAIN_THREAD\"] = \"main_thread\";\n    KernelMode[\"WORKER\"] = \"worker\";\n})(KernelMode || (KernelMode = {}));\n// Kernel language enum\nvar KernelLanguage;\n(function (KernelLanguage) {\n    KernelLanguage[\"PYTHON\"] = \"python\";\n})(KernelLanguage || (KernelLanguage = {}));\n/**\n * KernelManager class manages multiple kernel instances\n * in either main thread or worker mode\n */\nclass KernelManager extends EventEmitter {\n    /**\n     * Resolve the worker URL based on the current environment\n     * @private\n     * @returns The resolved worker URL\n     */\n    resolveWorkerUrl() {\n        // If a custom worker URL is provided, use it\n        if (this.workerUrl) {\n            return this.workerUrl;\n        }\n        // Try to detect the current script location and derive the worker URL\n        if (typeof window !== 'undefined' && window.location) {\n            // Browser environment\n            const currentScript = document.currentScript ||\n                Array.from(document.getElementsByTagName('script')).pop();\n            if (currentScript && currentScript.src) {\n                // Get the base URL from the current script\n                const scriptUrl = new URL(currentScript.src);\n                const baseUrl = scriptUrl.href.substring(0, scriptUrl.href.lastIndexOf('/'));\n                // Check if we're loading from a CDN (jsdelivr, unpkg, etc.)\n                if (scriptUrl.hostname.includes('jsdelivr.net') ||\n                    scriptUrl.hostname.includes('unpkg.com') ||\n                    scriptUrl.hostname.includes('cdnjs.cloudflare.com')) {\n                    // For CDN, the worker should be at the same path\n                    return `${baseUrl}/kernel.worker.js`;\n                }\n                // For local development or custom deployments\n                return `${baseUrl}/kernel.worker.js`;\n            }\n            // Fallback to relative path from current location\n            const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n            return `${baseUrl}/dist/kernel.worker.js`;\n        }\n        // Node.js or unknown environment - use relative path\n        // This may not work in Node.js but is provided as a fallback\n        return './kernel.worker.js';\n    }\n    /**\n     * Helper function to check if an error is a KeyboardInterrupt\n     * @private\n     */\n    isKeyboardInterrupt(error) {\n        return error &&\n            typeof error === 'object' &&\n            (('type' in error && error.type === \"KeyboardInterrupt\") ||\n                ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n    }\n    /**\n     * Helper function to create a standardized KeyboardInterrupt error result\n     * @private\n     */\n    createKeyboardInterruptResult() {\n        return {\n            success: false,\n            error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n            result: {\n                status: \"error\",\n                ename: \"KeyboardInterrupt\",\n                evalue: \"Execution interrupted by user\",\n                traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n            }\n        };\n    }\n    /**\n     * Store an AbortController for a specific kernel execution\n     * @private\n     */\n    storeAbortController(kernelId, executionId, controller) {\n        if (!this.abortControllers.has(kernelId)) {\n            this.abortControllers.set(kernelId, new Map());\n        }\n        this.abortControllers.get(kernelId).set(executionId, controller);\n    }\n    /**\n     * Remove and return an AbortController for a specific kernel execution\n     * @private\n     */\n    removeAbortController(kernelId, executionId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return undefined;\n        const controller = kernelControllers.get(executionId);\n        if (controller) {\n            kernelControllers.delete(executionId);\n            if (kernelControllers.size === 0) {\n                this.abortControllers.delete(kernelId);\n            }\n        }\n        return controller;\n    }\n    /**\n     * Abort all ongoing operations for a specific kernel\n     * @private\n     */\n    abortAllKernelOperations(kernelId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return;\n        for (const [executionId, controller] of kernelControllers) {\n            try {\n                controller.abort();\n                console.log(`ðŸš« Aborted execution ${executionId} for kernel ${kernelId}`);\n            }\n            catch (error) {\n                console.warn(`âš ï¸ Error aborting execution ${executionId}:`, error);\n            }\n        }\n        // Clear all controllers for this kernel\n        this.abortControllers.delete(kernelId);\n    }\n    constructor(options = {}) {\n        super();\n        this.kernels = new Map();\n        // Track listeners for each kernel to enable individual removal\n        this.listenerWrappers = new Map();\n        // Track last activity time for each kernel\n        this.lastActivityTime = new Map();\n        // Store inactivity timers for each kernel\n        this.inactivityTimers = new Map();\n        // Track ongoing executions for each kernel\n        this.ongoingExecutions = new Map();\n        // Track execution timeouts for detecting stuck/dead kernels\n        this.executionTimeouts = new Map();\n        // Track execution start times for accurate duration calculation\n        this.executionStartTimes = new Map();\n        // Track execution metadata for better monitoring\n        this.executionMetadata = new Map();\n        // Track AbortControllers for each kernel's ongoing operations\n        this.abortControllers = new Map();\n        // Pool management - now using promises for immediate response\n        this.pool = new Map();\n        this.isPreloading = false;\n        // Track which pool keys are currently being prefilled to prevent duplicates\n        this.prefillingInProgress = new Map();\n        // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n        this.interruptBuffers = new Map();\n        super.setMaxListeners(100); // Allow many listeners for kernel events\n        // Set interruption mode (default to 'auto')\n        this.interruptionMode = options.interruptionMode || 'auto';\n        // Set worker URL if provided\n        this.workerUrl = options.workerUrl;\n        // Set default allowed kernel types (worker mode only for security)\n        this.allowedKernelTypes = options.allowedKernelTypes || [\n            { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n        ];\n        // Initialize pool configuration with defaults based on allowed types\n        const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n        );\n        this.poolConfig = {\n            enabled: false,\n            poolSize: 2,\n            autoRefill: true,\n            preloadConfigs: defaultPreloadConfigs,\n            ...options.pool\n        };\n        // Validate that pool preload configs are within allowed types\n        if (this.poolConfig.preloadConfigs) {\n            this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n                const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n                if (!isAllowed) {\n                    console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n                }\n                return isAllowed;\n            });\n        }\n        // Start preloading if pool is enabled\n        if (this.poolConfig.enabled) {\n            this.preloadPool().catch(error => {\n                console.error(\"Error preloading kernel pool:\", error);\n            });\n        }\n    }\n    /**\n     * Generate a pool key for a given mode and language combination\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Pool key string\n     * @private\n     */\n    getPoolKey(mode, language) {\n        return `${mode}-${language}`;\n    }\n    /**\n     * Get a kernel promise from the pool if available\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel promise or null if none available\n     * @private\n     */\n    getFromPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return null;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey);\n        if (!poolPromises || poolPromises.length === 0) {\n            return null;\n        }\n        // Remove and return the first promise from the pool (FIFO)\n        const kernelPromise = poolPromises.shift();\n        // Immediately trigger background refill to add one promise back\n        if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n                this.refillPoolSingle(mode, language).catch(error => {\n                    console.error(`Error refilling single kernel for ${poolKey}:`, error);\n                });\n            }, 0);\n        }\n        return kernelPromise;\n    }\n    /**\n     * Add a kernel promise to the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param kernelPromise Kernel promise\n     * @private\n     */\n    addToPool(mode, language, kernelPromise) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        if (!this.pool.has(poolKey)) {\n            this.pool.set(poolKey, []);\n        }\n        const poolPromises = this.pool.get(poolKey);\n        // Only add if we haven't reached the pool size limit\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            poolPromises.push(kernelPromise);\n            // Handle promise rejection to prevent unhandled rejections\n            kernelPromise.catch(error => {\n                console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n                // Remove the failed promise from the pool\n                const index = poolPromises.indexOf(kernelPromise);\n                if (index !== -1) {\n                    poolPromises.splice(index, 1);\n                }\n            });\n        }\n        else {\n            // Pool is full, let the excess promise resolve and then destroy the kernel\n            kernelPromise.then(kernel => {\n                kernel.destroy().catch(error => {\n                    console.error(\"Error destroying excess pool kernel:\", error);\n                });\n            }).catch(error => {\n                console.error(\"Excess pool kernel promise rejected:\", error);\n            });\n        }\n    }\n    /**\n     * Refill the pool with a single kernel promise\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPoolSingle(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey) || [];\n        // Only add one if we're below the pool size\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            const kernelPromise = this.createPoolKernelPromise(mode, language);\n            this.addToPool(mode, language, kernelPromise);\n        }\n    }\n    /**\n     * Refill the pool for a specific configuration with parallel creation\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        // Check if already prefilling this pool key to prevent duplicates\n        if (this.prefillingInProgress.get(poolKey)) {\n            return;\n        }\n        // Set prefilling flag\n        this.prefillingInProgress.set(poolKey, true);\n        try {\n            const poolPromises = this.pool.get(poolKey) || [];\n            const needed = this.poolConfig.poolSize - poolPromises.length;\n            if (needed <= 0) {\n                return;\n            }\n            // Create all needed kernel promises in parallel\n            const newPromises = Array.from({ length: needed }, () => this.createPoolKernelPromise(mode, language));\n            // Add all promises to the pool\n            for (const kernelPromise of newPromises) {\n                this.addToPool(mode, language, kernelPromise);\n            }\n        }\n        catch (error) {\n            console.error(`Error refilling pool for ${poolKey}:`, error);\n        }\n        finally {\n            // Always clear the prefilling flag\n            this.prefillingInProgress.set(poolKey, false);\n        }\n    }\n    /**\n     * Create a kernel promise for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Promise that resolves to a kernel instance\n     * @private\n     */\n    createPoolKernelPromise(mode, language) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                const kernel = await this.createPoolKernel(mode, language);\n                // Mark as taken from pool\n                kernel.isFromPool = true;\n                resolve(kernel);\n            }\n            catch (error) {\n                console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n                reject(error);\n            }\n        });\n    }\n    /**\n     * Create a kernel specifically for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel instance\n     * @private\n     */\n    async createPoolKernel(mode, language) {\n        // Generate a temporary ID for the pool kernel\n        const tempId = `pool-${crypto.randomUUID()}`;\n        // Create kernel with minimal configuration\n        const options = {\n            mode,\n            lang: language\n        };\n        // Store options temporarily - but don't store incomplete instance in kernels map\n        // Instead, we'll pass the options directly to the creation methods\n        let instance;\n        try {\n            if (mode === KernelMode.MAIN_THREAD) {\n                // For main thread, we need to temporarily store the instance for createMainThreadKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createMainThreadKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n            else {\n                // For worker mode, we need to temporarily store the instance for createWorkerKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createWorkerKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n        }\n        catch (error) {\n            // Ensure cleanup on any error\n            this.kernels.delete(tempId);\n            throw error;\n        }\n        return instance;\n    }\n    /**\n     * Preload the kernel pool with configured kernel types\n     * @private\n     */\n    async preloadPool() {\n        if (!this.poolConfig.enabled || this.isPreloading) {\n            return;\n        }\n        this.isPreloading = true;\n        try {\n            // Preload kernels for each configured type\n            for (const config of this.poolConfig.preloadConfigs) {\n                try {\n                    await this.refillPool(config.mode, config.language);\n                }\n                catch (error) {\n                    console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n                    // Continue with other configurations\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error during kernel pool preloading:\", error);\n        }\n        finally {\n            this.isPreloading = false;\n        }\n    }\n    /**\n     * Check if a kernel request can use the pool\n     * @param options Kernel creation options\n     * @returns True if the request can use pool\n     * @private\n     */\n    canUsePool(options) {\n        // Don't use pool if it's disabled\n        if (!this.poolConfig.enabled) {\n            return false;\n        }\n        // Don't use pool if custom filesystem or permissions are specified\n        if (options.filesystem || options.deno?.permissions) {\n            return false;\n        }\n        // Don't use pool if custom timeouts are specified\n        if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Reassign a pool kernel with new ID and options\n     * @param poolKernel Kernel from pool\n     * @param newId New kernel ID\n     * @param options Kernel options\n     * @returns Updated kernel instance\n     * @private\n     */\n    reassignPoolKernel(poolKernel, newId, options) {\n        // Create a new instance object explicitly to avoid spread operator issues\n        const updatedInstance = {\n            id: newId,\n            kernel: poolKernel.kernel,\n            mode: poolKernel.mode,\n            language: poolKernel.language,\n            worker: poolKernel.worker,\n            created: new Date().toISOString(), // Update creation time\n            options: { ...poolKernel.options, ...options },\n            isFromPool: true,\n            destroy: poolKernel.destroy // Preserve the original destroy function\n        };\n        // Verify the destroy function is properly set\n        if (typeof updatedInstance.destroy !== 'function') {\n            console.error('Failed to preserve destroy function during pool kernel reassignment');\n            console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n            console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n            throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n        }\n        return updatedInstance;\n    }\n    /**\n     * Get pool statistics for debugging/monitoring\n     * @returns Pool statistics\n     */\n    getPoolStats() {\n        const stats = {};\n        for (const [poolKey, promises] of this.pool.entries()) {\n            stats[poolKey] = {\n                available: promises.length,\n                total: this.poolConfig.poolSize\n            };\n        }\n        return stats;\n    }\n    /**\n     * Get pool configuration information\n     * @returns Pool configuration details\n     */\n    getPoolConfig() {\n        return {\n            enabled: this.poolConfig.enabled,\n            poolSize: this.poolConfig.poolSize,\n            autoRefill: this.poolConfig.autoRefill,\n            preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n            isPreloading: this.isPreloading\n        };\n    }\n    /**\n     * Get the current worker URL configuration\n     * @returns The worker URL or undefined if using auto-detection\n     */\n    getWorkerUrl() {\n        return this.workerUrl;\n    }\n    /**\n     * Set a custom worker URL for kernel workers\n     * @param url The URL to the kernel.worker.js file\n     * @example\n     * // For CDN usage:\n     * manager.setWorkerUrl('https://cdn.jsdelivr.net/npm/web-python-kernel@latest/dist/kernel.worker.js');\n     * // For local development:\n     * manager.setWorkerUrl('/dist/kernel.worker.js');\n     */\n    setWorkerUrl(url) {\n        this.workerUrl = url;\n    }\n    /**\n     * Create a new kernel instance\n     * @param options Options for creating the kernel\n     * @param options.id Optional custom ID for the kernel\n     * @param options.mode Optional kernel mode (main_thread or worker)\n     * @param options.lang Optional kernel language (python or typescript)\n     * @param options.namespace Optional namespace prefix for the kernel ID\n     * @param options.deno.permissions Optional Deno permissions for worker mode\n     * @param options.filesystem Optional filesystem mounting options\n     * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n     * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n     * @returns Promise resolving to the kernel instance ID\n     */\n    async createKernel(options = {}) {\n        // make sure the options.id does not contain colons because it will be used as a namespace prefix\n        if (options.id && options.id.includes(':')) {\n            throw new Error('Kernel ID cannot contain colons');\n        }\n        const baseId = options.id || crypto.randomUUID();\n        const mode = options.mode || KernelMode.WORKER;\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Check if the requested kernel type is allowed\n        if (!this.isKernelTypeAllowed(mode, language)) {\n            throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')}`);\n        }\n        // Apply namespace prefix if provided\n        const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n        // Check if kernel with this ID already exists\n        if (this.kernels.has(id)) {\n            throw new Error(`Kernel with ID ${id} already exists`);\n        }\n        // Try to get from pool if possible\n        if (this.canUsePool(options)) {\n            const poolKey = this.getPoolKey(mode, language);\n            // Check if this kernel type is configured for pooling\n            const isPooledType = this.poolConfig.preloadConfigs.some(config => config.mode === mode && config.language === language);\n            if (isPooledType) {\n                // First try to get from existing pool\n                let poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n                // Pool is empty, but this type should be pooled\n                // Create a new promise immediately and trigger background refill\n                try {\n                    // Create a new kernel promise specifically for this request\n                    const newKernelPromise = this.createPoolKernelPromise(mode, language);\n                    // Trigger background refill to replenish the pool for future requests\n                    if (this.poolConfig.autoRefill) {\n                        setTimeout(() => {\n                            this.refillPool(mode, language).catch(error => {\n                                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n                            });\n                        }, 0);\n                    }\n                    return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n                }\n                catch (error) {\n                    console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n                    // Fall through to on-demand creation as last resort\n                }\n            }\n            else {\n                // This kernel type is not configured for pooling, try to get from pool anyway\n                // in case there are kernels available from previous configurations\n                const poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n            }\n        }\n        // Fall back to creating a new kernel on-demand\n        return this.createOnDemandKernel(id, mode, language, options);\n    }\n    /**\n     * Setup a pool kernel from a promise with new ID and options\n     * @param poolKernelPromise Kernel promise from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID (returned after kernel is ready)\n     * @private\n     */\n    async setupPoolKernelFromPromise(poolKernelPromise, id, options) {\n        try {\n            // Wait for the pool kernel to be ready\n            const poolKernel = await poolKernelPromise;\n            // Reassign the pool kernel with the new ID and options\n            const instance = this.reassignPoolKernel(poolKernel, id, options);\n            // For worker kernels, we need to recreate the event handler with the new ID\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // Get the worker and create new message channel\n                const worker = instance.worker;\n                // Create a new message channel for the reassigned kernel\n                const { port1, port2 } = new MessageChannel();\n                // Send the new event port to the worker\n                worker.postMessage({\n                    type: \"SET_EVENT_PORT\",\n                    port: port2\n                }, [port2]);\n                // Create a new event handler with the correct kernel ID\n                const eventHandler = (event) => {\n                    if (event.data && event.data.type) {\n                        // Emit the event from the manager with kernel ID\n                        // This structure matches the setupEventForwarding method for main thread kernels\n                        super.emit(event.data.type, {\n                            kernelId: id,\n                            data: event.data.data\n                        });\n                    }\n                };\n                // Listen for events from the worker with the new handler\n                port1.addEventListener('message', eventHandler);\n                port1.start();\n                // Update the destroy function to clean up the new event handler\n                const originalDestroy = instance.destroy;\n                instance.destroy = async () => {\n                    port1.removeEventListener('message', eventHandler);\n                    port1.close();\n                    return originalDestroy();\n                };\n            }\n            // Store the kernel instance\n            this.kernels.set(id, instance);\n            // Forward kernel events to manager (for main thread kernels)\n            this.setupEventForwarding(instance);\n            // Initialize activity tracking\n            this.updateKernelActivity(id);\n            // Set up inactivity timeout if specified and greater than 0\n            if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n                this.setupInactivityTimeout(id, options.inactivityTimeout);\n            }\n            // Setup handlers for stalled executions if maxExecutionTime is specified\n            if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n                this.setupStalledExecutionHandler(id);\n            }\n            return id;\n        }\n        catch (error) {\n            console.error(`Error setting up pool kernel ${id}:`, error);\n            // Emit an error event for this kernel\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelSetupError\",\n                    evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n                    traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n                }\n            });\n            throw error; // Re-throw to let the caller handle it\n        }\n    }\n    /**\n     * Setup a pool kernel with new ID and options (for already resolved kernels)\n     * @param poolKernel Kernel from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    setupPoolKernel(poolKernel, id, options) {\n        // Reassign the pool kernel with the new ID and options\n        const instance = this.reassignPoolKernel(poolKernel, id, options);\n        // For worker kernels, we need to recreate the event handler with the new ID\n        if (instance.mode === KernelMode.WORKER && instance.worker) {\n            // Get the worker and create new message channel\n            const worker = instance.worker;\n            // Create a new message channel for the reassigned kernel\n            const { port1, port2 } = new MessageChannel();\n            // Send the new event port to the worker\n            worker.postMessage({\n                type: \"SET_EVENT_PORT\",\n                port: port2\n            }, [port2]);\n            // Create a new event handler with the correct kernel ID\n            const eventHandler = (event) => {\n                if (event.data && event.data.type) {\n                    // Emit the event from the manager with kernel ID\n                    // This structure matches the setupEventForwarding method for main thread kernels\n                    super.emit(event.data.type, {\n                        kernelId: id,\n                        data: event.data.data\n                    });\n                }\n            };\n            // Listen for events from the worker with the new handler\n            port1.addEventListener('message', eventHandler);\n            port1.start();\n            // Update the destroy function to clean up the new event handler\n            const originalDestroy = instance.destroy;\n            instance.destroy = async () => {\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                return originalDestroy();\n            };\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager (for main thread kernels)\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel on-demand (not from pool)\n     * @param id Kernel ID\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    async createOnDemandKernel(id, mode, language, options) {\n        // Store options temporarily to be used in createWorkerKernel\n        const tempInstance = {\n            id,\n            options: { ...options, lang: language },\n            mode,\n            language\n        };\n        this.kernels.set(id, tempInstance);\n        // Create the appropriate kernel instance\n        let instance;\n        if (mode === KernelMode.MAIN_THREAD) {\n            instance = await this.createMainThreadKernel(id);\n        }\n        else {\n            instance = await this.createWorkerKernel(id);\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel instance running in the main thread\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createMainThreadKernel(id) {\n        // Get options from the temporary instance\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create the Python kernel\n        const kernel = new _index__WEBPACK_IMPORTED_MODULE_2__.Kernel();\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel,\n            mode: KernelMode.MAIN_THREAD,\n            language,\n            created: new Date().toISOString(),\n            options,\n            destroy: async () => {\n                // Nothing special to do for main thread kernel\n                return Promise.resolve();\n            }\n        };\n        // Initialize the kernel with filesystem options\n        const kernelOptions = {};\n        // Add filesystem options if provided\n        if (options.filesystem) {\n            kernelOptions.filesystem = options.filesystem;\n        }\n        // Add environment variables if provided\n        if (options.env) {\n            kernelOptions.env = options.env;\n        }\n        // Add lockFileURL if provided\n        if (options.lockFileURL) {\n            kernelOptions.lockFileURL = options.lockFileURL;\n        }\n        // Add autoSyncFs if provided\n        if (options.autoSyncFs !== undefined) {\n            kernelOptions.autoSyncFs = options.autoSyncFs;\n        }\n        // Initialize the kernel\n        await kernel.initialize(kernelOptions);\n        return instance;\n    }\n    /**\n     * Create a kernel instance running in a worker\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createWorkerKernel(id) {\n        // Get permissions from options when creating the kernel\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create a new worker with optional permissions\n        const workerOptions = {\n            type: \"module\",\n        };\n        // If Deno permissions are provided, use them.\n        // Otherwise don't specify Deno permissions at all to inherit from host script\n        if (options.deno?.permissions) {\n            workerOptions.deno = {\n                permissions: options.deno.permissions\n            };\n        }\n        // Determine the worker URL based on the environment\n        const workerUrl = this.resolveWorkerUrl();\n        const worker = new Worker(workerUrl, { type: 'classic' });\n        // Create a message channel for events\n        const { port1, port2 } = new MessageChannel();\n        // Create a promise that will resolve when the kernel is initialized\n        const initPromise = new Promise((resolve, reject) => {\n            const initHandler = (event) => {\n                if (event.data?.type === \"KERNEL_INITIALIZED\") {\n                    if (event.data.data.success) {\n                        port1.removeEventListener('message', initHandler);\n                        resolve();\n                    }\n                    else {\n                        port1.removeEventListener('message', initHandler);\n                        reject(new Error(\"Kernel initialization failed\"));\n                    }\n                }\n            };\n            port1.addEventListener('message', initHandler);\n        });\n        // Send the port to the worker\n        worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n        // Create a proxy to the worker using Comlink\n        const kernelProxy = comlink__WEBPACK_IMPORTED_MODULE_0__.wrap(worker);\n        // Add a local event handler to bridge the worker events\n        // This works around the limitation that Comlink doesn't proxy event emitters\n        const eventHandler = (event) => {\n            if (event.data && event.data.type) {\n                // Emit the event from the manager with kernel ID\n                // This structure matches the setupEventForwarding method for main thread kernels\n                super.emit(event.data.type, {\n                    kernelId: id,\n                    data: event.data.data\n                });\n            }\n        };\n        // Listen for events from the worker\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        // Initialize the kernel with filesystem options\n        // We need to pass these options to the worker\n        worker.postMessage({\n            type: \"INITIALIZE_KERNEL\",\n            options: {\n                filesystem: options.filesystem,\n                env: options.env,\n                lockFileURL: options.lockFileURL,\n                autoSyncFs: options.autoSyncFs,\n                lang: language\n            }\n        });\n        // Wait for kernel initialization\n        await initPromise;\n        // Set up interrupt buffer automatically for worker kernels\n        await this.setupWorkerInterruptBuffer(id, worker);\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel: {\n                // Map methods from the Comlink proxy to the IKernel interface\n                initialize: async (options) => {\n                    return kernelProxy.initialize(options);\n                },\n                execute: async (code, parent) => {\n                    const result = await kernelProxy.execute(code, parent);\n                    // Handle Python worker results (no special display reconstruction needed)\n                    return result;\n                },\n                isInitialized: () => {\n                    return kernelProxy.isInitialized();\n                },\n                inputReply: async (content) => {\n                    return kernelProxy.inputReply(content);\n                },\n                // Map async getStatus method\n                getStatus: async () => {\n                    try {\n                        if (typeof kernelProxy.getStatus === 'function') {\n                            return await kernelProxy.getStatus();\n                        }\n                        else {\n                            return \"unknown\";\n                        }\n                    }\n                    catch (error) {\n                        return \"unknown\";\n                    }\n                },\n                // Map completion methods\n                complete: async (code, cursor_pos, parent) => {\n                    try {\n                        if (typeof kernelProxy.complete === 'function') {\n                            return await kernelProxy.complete(code, cursor_pos, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Completion not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                inspect: async (code, cursor_pos, detail_level, parent) => {\n                    try {\n                        if (typeof kernelProxy.inspect === 'function') {\n                            return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Inspection not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                isComplete: async (code, parent) => {\n                    try {\n                        if (typeof kernelProxy.isComplete === 'function') {\n                            return await kernelProxy.isComplete(code, parent);\n                        }\n                        else {\n                            return { status: 'unknown' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                // Map interrupt methods\n                interrupt: async () => {\n                    try {\n                        if (typeof kernelProxy.interrupt === 'function') {\n                            return await kernelProxy.interrupt();\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                },\n                setInterruptBuffer: (buffer) => {\n                    try {\n                        if (typeof kernelProxy.setInterruptBuffer === 'function') {\n                            kernelProxy.setInterruptBuffer(buffer);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to set interrupt buffer:', error);\n                    }\n                },\n                // Map mountFS method\n                mountFS: async (mountPath, dirHandle, permission) => {\n                    try {\n                        if (typeof kernelProxy.mountFS === 'function') {\n                            return await kernelProxy.mountFS(mountPath, dirHandle, permission);\n                        }\n                        else {\n                            throw new Error('mountFS is not supported by this kernel');\n                        }\n                    }\n                    catch (error) {\n                        throw error;\n                    }\n                },\n                // Map filesystem sync methods\n                getMountedFileSystems: () => {\n                    try {\n                        if (typeof kernelProxy.getMountedFileSystems === 'function') {\n                            return kernelProxy.getMountedFileSystems();\n                        }\n                        else {\n                            return [];\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to get mounted filesystems:', error);\n                        return [];\n                    }\n                },\n                syncFileSystem: async (mountPath) => {\n                    try {\n                        if (typeof kernelProxy.syncFileSystem === 'function') {\n                            return await kernelProxy.syncFileSystem(mountPath);\n                        }\n                        else {\n                            return { success: false, error: 'syncFileSystem is not supported by this kernel' };\n                        }\n                    }\n                    catch (error) {\n                        return { success: false, error: error instanceof Error ? error.message : String(error) };\n                    }\n                },\n                upgradeFileSystemPermission: async (mountPath) => {\n                    try {\n                        if (typeof kernelProxy.upgradeFileSystemPermission === 'function') {\n                            return await kernelProxy.upgradeFileSystemPermission(mountPath);\n                        }\n                        else {\n                            return { success: false, error: 'upgradeFileSystemPermission is not supported by this kernel' };\n                        }\n                    }\n                    catch (error) {\n                        return { success: false, error: error instanceof Error ? error.message : String(error) };\n                    }\n                },\n                // Map comm methods\n                commInfo: async (target_name, parent) => {\n                    try {\n                        if (typeof kernelProxy.commInfo === 'function') {\n                            return await kernelProxy.commInfo(target_name, parent);\n                        }\n                        else {\n                            return { comms: {}, status: 'ok' };\n                        }\n                    }\n                    catch (error) {\n                        return { comms: {}, status: 'error', error: String(error) };\n                    }\n                },\n                commOpen: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commOpen === 'function') {\n                            return await kernelProxy.commOpen(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to open comm:', error);\n                    }\n                },\n                commMsg: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commMsg === 'function') {\n                            return await kernelProxy.commMsg(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to send comm message:', error);\n                    }\n                },\n                commClose: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commClose === 'function') {\n                            return await kernelProxy.commClose(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to close comm:', error);\n                    }\n                }\n            },\n            mode: KernelMode.WORKER,\n            language,\n            worker,\n            created: new Date().toISOString(),\n            options, // Store the options for reference\n            destroy: async () => {\n                // Clean up the worker and event listeners\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                worker.terminate();\n                return Promise.resolve();\n            }\n        };\n        return instance;\n    }\n    /**\n     * Setup event forwarding from kernel to manager\n     * @param instance Kernel instance\n     */\n    setupEventForwarding(instance) {\n        // Only needed for main thread kernels as worker events are handled directly\n        if (instance.mode === KernelMode.MAIN_THREAD) {\n            // Forward all kernel events to the manager with kernel ID\n            Object.values(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents).forEach((eventType) => {\n                // Access the kernel as a Kernel instance which extends EventEmitter\n                const kernelEmitter = instance.kernel;\n                // Add event listener to forward events\n                kernelEmitter.on(eventType, (data) => {\n                    super.emit(eventType, {\n                        kernelId: instance.id,\n                        data\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * Get a kernel instance by ID\n     * @param id Kernel ID\n     * @returns Kernel instance or undefined if not found\n     */\n    getKernel(id) {\n        return this.kernels.get(id);\n    }\n    /**\n     * Get a list of all kernel IDs\n     * @returns Array of kernel IDs\n     */\n    getKernelIds() {\n        return Array.from(this.kernels.keys());\n    }\n    /**\n     * Get a list of all kernels with their details\n     * @param namespace Optional namespace to filter kernels by\n     * @returns Array of kernel information objects\n     */\n    async listKernels(namespace) {\n        const filteredKernels = Array.from(this.kernels.entries())\n            .filter(([id]) => {\n            // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n            if (id.startsWith(\"pool-\"))\n                return false;\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Use Promise.all to get all statuses concurrently\n        const kernelInfos = await Promise.all(filteredKernels.map(async ([id, instance]) => {\n            // Extract namespace from id if present\n            const namespaceMatch = id.match(/^([^:]+):/);\n            const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n            // Get status using async getStatus method\n            let status = \"unknown\";\n            try {\n                if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n                    status = await instance.kernel.getStatus();\n                }\n            }\n            catch (error) {\n                console.warn(`Error getting status for kernel ${id}:`, error);\n                status = \"unknown\";\n            }\n            return {\n                id,\n                mode: instance.mode,\n                language: instance.language,\n                status,\n                created: instance.created || new Date().toISOString(),\n                namespace: extractedNamespace,\n                deno: instance.options?.deno\n            };\n        }));\n        return kernelInfos;\n    }\n    /**\n     * Destroy a kernel instance\n     * @param id Kernel ID\n     * @returns Promise resolving when kernel is destroyed\n     */\n    async destroyKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            // Handle gracefully - kernel may already be destroyed\n            return;\n        }\n        // Verify the destroy function exists\n        if (typeof instance.destroy !== 'function') {\n            throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n        }\n        // Abort all ongoing operations for this kernel first\n        this.abortAllKernelOperations(id);\n        // Clear any inactivity timer\n        this.clearInactivityTimeout(id);\n        // Clean up execution timeouts\n        if (this.executionTimeouts.has(id)) {\n            const timeouts = this.executionTimeouts.get(id);\n            for (const timeoutId of timeouts.values()) {\n                clearTimeout(timeoutId);\n            }\n            this.executionTimeouts.delete(id);\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(id)) {\n            this.executionStartTimes.delete(id);\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(id)) {\n            this.executionMetadata.delete(id);\n        }\n        // Clean up interrupt buffers\n        if (this.interruptBuffers.has(id)) {\n            this.interruptBuffers.delete(id);\n        }\n        // Clean up ongoing executions tracking\n        this.ongoingExecutions.delete(id);\n        // Clean up activity tracking\n        this.lastActivityTime.delete(id);\n        // Remove all event listeners for this kernel\n        this.removeAllKernelListeners(id);\n        // Destroy the kernel instance\n        await instance.destroy();\n        // Remove the kernel from the map\n        this.kernels.delete(id);\n    }\n    /**\n     * Destroy all kernel instances\n     * @param namespace Optional namespace to filter kernels to destroy\n     * @returns Promise resolving when all kernels are destroyed\n     */\n    async destroyAll(namespace) {\n        const ids = Array.from(this.kernels.keys())\n            .filter(id => {\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Destroy all kernels, but skip incomplete instances\n        const destroyPromises = ids.map(async (id) => {\n            const instance = this.kernels.get(id);\n            if (!instance || typeof instance.destroy !== 'function') {\n                console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n                // Just remove it from the map\n                this.kernels.delete(id);\n                return;\n            }\n            return this.destroyKernel(id);\n        });\n        await Promise.all(destroyPromises);\n        // If no namespace specified, also clean up the pool\n        if (!namespace) {\n            await this.destroyPool();\n        }\n    }\n    /**\n     * Destroy all kernels in the pool\n     * @private\n     */\n    async destroyPool() {\n        const destroyPromises = [];\n        for (const [poolKey, promises] of this.pool.entries()) {\n            for (const kernelPromise of promises) {\n                // Handle each promise - if it resolves, destroy the kernel\n                const destroyPromise = kernelPromise.then(kernel => {\n                    return kernel.destroy();\n                }).catch(error => {\n                    console.error(`Error destroying pool kernel from promise:`, error);\n                    // Don't re-throw to avoid unhandled rejections\n                });\n                destroyPromises.push(destroyPromise);\n            }\n        }\n        // Wait for all pool kernels to be destroyed\n        await Promise.all(destroyPromises);\n        // Clear the pool and prefilling flags\n        this.pool.clear();\n        this.prefillingInProgress.clear();\n    }\n    /**\n     * Register an event listener for a specific kernel's events\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    onKernelEvent(kernelId, eventType, listener) {\n        // Check if kernel exists\n        if (!this.kernels.has(kernelId)) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Create wrapper that filters events for this specific kernel\n        const wrapper = {\n            original: listener,\n            wrapped: (event) => {\n                if (event.kernelId === kernelId) {\n                    // Pass just the data to the listener\n                    // The data structure is consistent across main thread and worker modes\n                    listener(event.data);\n                }\n            }\n        };\n        // Store the wrapper for later removal\n        this.storeListener(kernelId, eventType, listener, wrapper);\n        // Add the wrapped listener to the manager\n        super.on(eventType, wrapper.wrapped);\n    }\n    /**\n     * Remove an event listener for a specific kernel\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    offKernelEvent(kernelId, eventType, listener) {\n        const wrapper = this.getListener(kernelId, eventType, listener);\n        if (wrapper) {\n            // Remove the wrapped listener from the manager\n            super.removeListener(eventType, wrapper.wrapped);\n            // Remove the wrapper from our tracking map\n            this.removeStoredListener(kernelId, eventType, listener);\n        }\n    }\n    /**\n     * Store a listener wrapper for later removal\n     */\n    storeListener(kernelId, eventType, original, wrapper) {\n        // Get or create kernel map\n        if (!this.listenerWrappers.has(kernelId)) {\n            this.listenerWrappers.set(kernelId, new Map());\n        }\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        // Get or create event type map\n        if (!kernelMap.has(eventType)) {\n            kernelMap.set(eventType, new Map());\n        }\n        const eventMap = kernelMap.get(eventType);\n        // Store the wrapper\n        eventMap.set(original, wrapper);\n    }\n    /**\n     * Get a stored listener wrapper\n     */\n    getListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return undefined;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return undefined;\n        return eventMap.get(original);\n    }\n    /**\n     * Remove a stored listener wrapper\n     */\n    removeStoredListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return;\n        // Remove the listener\n        eventMap.delete(original);\n        // Clean up empty maps\n        if (eventMap.size === 0) {\n            kernelMap.delete(eventType);\n        }\n        if (kernelMap.size === 0) {\n            this.listenerWrappers.delete(kernelId);\n        }\n    }\n    /**\n     * Remove all listeners for a specific kernel\n     */\n    removeAllKernelListeners(kernelId) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        // For each event type\n        for (const [eventType, eventMap] of kernelMap.entries()) {\n            // For each original listener\n            for (const wrapper of eventMap.values()) {\n                // Remove the wrapped listener from the manager\n                super.removeListener(eventType, wrapper.wrapped);\n            }\n        }\n        // Clear the kernel's listener map\n        this.listenerWrappers.delete(kernelId);\n    }\n    /**\n     * Get all listeners for a specific kernel and event type\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @returns Array of listeners\n     */\n    getListeners(kernelId, eventType) {\n        const kernelListeners = this.listenerWrappers.get(kernelId);\n        if (!kernelListeners) {\n            return [];\n        }\n        const eventListeners = kernelListeners.get(eventType);\n        if (!eventListeners) {\n            return [];\n        }\n        return Array.from(eventListeners.keys());\n    }\n    /**\n     * Execute Python code with streaming output\n     * This method works in both main thread and worker modes\n     * @param kernelId ID of the kernel to use\n     * @param code The Python code to execute\n     * @param parent Optional parent message header\n     * @returns AsyncGenerator yielding intermediate outputs\n     */\n    async *executeStream(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Update kernel activity\n        this.updateKernelActivity(kernelId);\n        // Track this execution with the code for better monitoring\n        const executionId = this.trackExecution(kernelId, code);\n        // Create AbortController for this execution to enable cancellation\n        const abortController = new AbortController();\n        this.storeAbortController(kernelId, executionId, abortController);\n        try {\n            // For main thread kernels, we can use the executeStream method directly\n            if (instance.mode === KernelMode.MAIN_THREAD) {\n                const kernel = instance.kernel;\n                // Forward to the kernel's executeStream method\n                if (typeof kernel.executeStream === 'function') {\n                    try {\n                        yield* kernel.executeStream(code, parent);\n                        // Update activity after execution completes\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking\n                        this.completeExecution(kernelId, executionId);\n                        return { success: true };\n                    }\n                    catch (error) {\n                        console.error(`Error in main thread executeStream:`, error);\n                        // Update activity even if there's an error\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking even on error\n                        this.completeExecution(kernelId, executionId);\n                        return {\n                            success: false,\n                            error: error instanceof Error ? error : new Error(String(error))\n                        };\n                    }\n                }\n            }\n            // For worker mode, we need to implement streaming via events with proper isolation\n            try {\n                // Event-based approach for worker kernels or main thread kernels without executeStream\n                const streamQueue = [];\n                let executionComplete = false;\n                let executionResult = { success: true };\n                // Store handler references for guaranteed cleanup\n                const eventHandlers = new Map();\n                // Helper function to clean up all event handlers\n                const cleanupHandlers = () => {\n                    for (const [eventType, handler] of eventHandlers.entries()) {\n                        super.off(eventType, handler);\n                    }\n                    eventHandlers.clear();\n                };\n                // Create execution-specific event handlers that include executionId check\n                const createHandler = (eventType) => {\n                    const handler = (event) => {\n                        // Only process events for this specific kernel and while this execution is active\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            streamQueue.push({\n                                type: eventType,\n                                data: event.data,\n                                executionId // Include execution ID for debugging\n                            });\n                            // Events also count as activity\n                            this.updateKernelActivity(kernelId);\n                        }\n                    };\n                    eventHandlers.set(eventType, handler);\n                    return handler;\n                };\n                // Create and register all event handlers\n                const handleStreamEvent = createHandler('stream');\n                const handleDisplayEvent = createHandler('display_data');\n                const handleUpdateDisplayEvent = createHandler('update_display_data');\n                const handleResultEvent = createHandler('execute_result');\n                const handleErrorEvent = createHandler('execute_error');\n                // Register handlers\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, handleStreamEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, handleResultEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n                // Create a promise that will resolve when execution is complete\n                const executionPromise = new Promise((resolve, reject) => {\n                    // Set up a handler for execution errors specifically\n                    const handleExecutionError = (event) => {\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            // Mark execution as complete to stop processing more events\n                            executionComplete = true;\n                            // Store the error for the final result\n                            executionResult = {\n                                success: false,\n                                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                                result: event.data\n                            };\n                            // Update activity\n                            this.updateKernelActivity(kernelId);\n                            resolve(executionResult);\n                        }\n                    };\n                    // Add error handler to our cleanup list\n                    eventHandlers.set('execute_error_completion', handleExecutionError);\n                    super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleExecutionError);\n                    // Check if already aborted\n                    if (abortController.signal.aborted) {\n                        executionComplete = true;\n                        resolve({\n                            success: false,\n                            error: new Error('Execution was aborted')\n                        });\n                        return;\n                    }\n                    // Set up abort handler\n                    const abortHandler = () => {\n                        if (!executionComplete) {\n                            console.log(`ðŸš« Execution ${executionId} aborted`);\n                            executionComplete = true;\n                            resolve({\n                                success: false,\n                                error: new Error('Execution was aborted')\n                            });\n                        }\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    // Execute the code\n                    // We know the execute method is available directly on the kernel object\n                    try {\n                        const executePromise = instance.kernel.execute(code, parent);\n                        executePromise.then((result) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                // Check if the execution result indicates an error (for Python kernels)\n                                if (result.success && result.result && result.result.status === \"error\") {\n                                    // Handle as error\n                                    const errorData = {\n                                        status: result.result.status,\n                                        ename: result.result.ename,\n                                        evalue: result.result.evalue,\n                                        traceback: result.result.traceback\n                                    };\n                                    // Push error to stream queue directly \n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorData,\n                                        executionId\n                                    });\n                                    // Update execution result to reflect the error\n                                    executionResult = {\n                                        success: false,\n                                        error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                                        result: result.result\n                                    };\n                                }\n                                else {\n                                    executionResult = result;\n                                }\n                                executionComplete = true;\n                                // Update activity when execution completes\n                                this.updateKernelActivity(kernelId);\n                                resolve(executionResult);\n                            }\n                        }).catch((error) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                                // Check if this is a KeyboardInterrupt and handle it specially\n                                let errorResult;\n                                if (this.isKeyboardInterrupt(error)) {\n                                    console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                                    errorResult = this.createKeyboardInterruptResult();\n                                    // Also push to stream queue for immediate feedback\n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorResult.result,\n                                        executionId\n                                    });\n                                }\n                                else {\n                                    // Handle other errors normally\n                                    errorResult = {\n                                        success: false,\n                                        error: error instanceof Error ? error : new Error(String(error))\n                                    };\n                                }\n                                executionComplete = true;\n                                executionResult = errorResult;\n                                // Update activity even on error\n                                this.updateKernelActivity(kernelId);\n                                resolve(errorResult);\n                            }\n                        });\n                    }\n                    catch (error) {\n                        // Only process if execution hasn't been marked complete already\n                        if (!executionComplete) {\n                            console.error(`Error calling execute for kernel ${kernelId}:`, error);\n                            // Simple error handling\n                            const errorResult = {\n                                success: false,\n                                error: error instanceof Error ? error : new Error(String(error))\n                            };\n                            executionComplete = true;\n                            executionResult = errorResult;\n                            // Update activity even on direct error\n                            this.updateKernelActivity(kernelId);\n                            resolve(errorResult);\n                        }\n                    }\n                });\n                // Use try/finally to guarantee cleanup\n                try {\n                    // Monitor the stream queue and yield results\n                    // Continue until execution is complete AND all queued events have been yielded\n                    while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n                        // If there are items in the queue, yield them\n                        if (streamQueue.length > 0) {\n                            const event = streamQueue.shift();\n                            yield event;\n                            continue;\n                        }\n                        // If no more events but execution is not complete, wait a little\n                        if (!executionComplete) {\n                            // Use abort signal to cancel the wait\n                            try {\n                                await new Promise((resolve, reject) => {\n                                    const timeoutId = setTimeout(resolve, 10);\n                                    abortController.signal.addEventListener('abort', () => {\n                                        clearTimeout(timeoutId);\n                                        reject(new Error('Aborted'));\n                                    });\n                                });\n                            }\n                            catch (error) {\n                                // If aborted, break out of loop\n                                if (abortController.signal.aborted) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Check if execution was aborted during stream monitoring\n                    if (abortController.signal.aborted && !executionComplete) {\n                        throw new Error('Execution was aborted during stream monitoring');\n                    }\n                    // Wait for the final result\n                    const result = await executionPromise;\n                    return result;\n                }\n                finally {\n                    // ALWAYS clean up event handlers regardless of how execution ends\n                    cleanupHandlers();\n                    // Remove AbortController to prevent memory leaks\n                    this.removeAbortController(kernelId, executionId);\n                    // Complete execution tracking\n                    this.completeExecution(kernelId, executionId);\n                }\n            }\n            catch (error) {\n                // Complete execution tracking on any outer error\n                this.completeExecution(kernelId, executionId);\n                console.error(`Unexpected error in executeStream:`, error);\n                return {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                };\n            }\n        }\n        catch (error) {\n            // Complete execution tracking on any outer error\n            this.completeExecution(kernelId, executionId);\n            console.error(`Unexpected error in executeStream:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Track a new execution task for a kernel\n     * @param kernelId Kernel ID\n     * @param code Optional code being executed for metadata\n     * @returns Unique execution ID\n     * @private\n     */\n    trackExecution(kernelId, code) {\n        // Create a unique execution ID\n        const executionId = `exec-${crypto.randomUUID()}`;\n        const startTime = Date.now();\n        // Reset interrupt buffer for worker kernels before each new execution\n        // This ensures the kernel can be interrupted multiple times\n        const instance = this.kernels.get(kernelId);\n        if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n            const interruptBuffer = this.interruptBuffers.get(kernelId);\n            // Reset buffer to 0 (no interrupt signal) to ensure clean state\n            interruptBuffer[0] = 0;\n        }\n        // Get or create the set of ongoing executions for this kernel\n        if (!this.ongoingExecutions.has(kernelId)) {\n            this.ongoingExecutions.set(kernelId, new Set());\n        }\n        // Add this execution to the set\n        this.ongoingExecutions.get(kernelId).add(executionId);\n        // Track execution start time\n        if (!this.executionStartTimes.has(kernelId)) {\n            this.executionStartTimes.set(kernelId, new Map());\n        }\n        this.executionStartTimes.get(kernelId).set(executionId, startTime);\n        // Track execution metadata\n        if (!this.executionMetadata.has(kernelId)) {\n            this.executionMetadata.set(kernelId, new Map());\n        }\n        // Update activity timestamp\n        this.updateKernelActivity(kernelId);\n        // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n        if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n            // Get or create the map of execution timeouts for this kernel\n            if (!this.executionTimeouts.has(kernelId)) {\n                this.executionTimeouts.set(kernelId, new Map());\n            }\n            // Set a timeout for this execution with enhanced handling\n            const timeoutId = setTimeout(() => {\n                console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n                // Get execution metadata for better error reporting\n                const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n                const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n                // Emit a stalled execution event with enhanced information\n                super.emit('execution_stalled', {\n                    kernelId,\n                    executionId,\n                    maxExecutionTime: instance.options.maxExecutionTime,\n                    actualRuntime,\n                    code: metadata?.code || code,\n                    startTime: metadata?.startTime || startTime\n                });\n                // Auto-handle stuck execution if configured\n                this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n            }, instance.options.maxExecutionTime);\n            // Store the timeout ID\n            this.executionTimeouts.get(kernelId).set(executionId, timeoutId);\n            // Store metadata including timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code,\n                timeoutId\n            });\n        }\n        else {\n            // Store metadata without timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code\n            });\n        }\n        return executionId;\n    }\n    /**\n     * Complete tracking for an execution\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID\n     * @private\n     */\n    completeExecution(kernelId, executionId) {\n        // Clear any execution timeout\n        if (this.executionTimeouts.has(kernelId)) {\n            const timeouts = this.executionTimeouts.get(kernelId);\n            if (timeouts.has(executionId)) {\n                clearTimeout(timeouts.get(executionId));\n                timeouts.delete(executionId);\n            }\n            // Clean up empty maps\n            if (timeouts.size === 0) {\n                this.executionTimeouts.delete(kernelId);\n            }\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(kernelId)) {\n            const startTimes = this.executionStartTimes.get(kernelId);\n            startTimes.delete(executionId);\n            // Clean up empty maps\n            if (startTimes.size === 0) {\n                this.executionStartTimes.delete(kernelId);\n            }\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(kernelId)) {\n            const metadata = this.executionMetadata.get(kernelId);\n            metadata.delete(executionId);\n            // Clean up empty maps\n            if (metadata.size === 0) {\n                this.executionMetadata.delete(kernelId);\n            }\n        }\n        // Remove from ongoing executions\n        if (this.ongoingExecutions.has(kernelId)) {\n            const executions = this.ongoingExecutions.get(kernelId);\n            executions.delete(executionId);\n            // Clean up empty sets\n            if (executions.size === 0) {\n                this.ongoingExecutions.delete(kernelId);\n                // Update activity timestamp for completed execution\n                this.updateKernelActivity(kernelId);\n            }\n        }\n    }\n    /**\n     * Check if a kernel has any ongoing executions\n     * @param kernelId Kernel ID\n     * @returns True if the kernel has ongoing executions\n     * @private\n     */\n    hasOngoingExecutions(kernelId) {\n        return this.ongoingExecutions.has(kernelId) &&\n            this.ongoingExecutions.get(kernelId).size > 0;\n    }\n    /**\n     * Get the count of ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Number of ongoing executions\n     */\n    getOngoingExecutionCount(id) {\n        if (!this.ongoingExecutions.has(id)) {\n            return 0;\n        }\n        return this.ongoingExecutions.get(id).size;\n    }\n    /**\n     * Set up an inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds\n     * @private\n     */\n    setupInactivityTimeout(id, timeout) {\n        // Don't set up a timer if timeout is 0 or negative\n        if (timeout <= 0) {\n            return;\n        }\n        // Always clear any existing timer first\n        this.clearInactivityTimeout(id);\n        // Calculate remaining time based on last activity\n        const lastActivity = this.lastActivityTime.get(id) || Date.now();\n        const elapsed = Date.now() - lastActivity;\n        const remainingTime = Math.max(0, timeout - elapsed);\n        // If no time remaining, destroy immediately\n        if (remainingTime === 0) {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            // Destroy immediately\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n            return;\n        }\n        // Create a timer to destroy the kernel after the remaining timeout\n        const timer = setTimeout(() => {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n        }, remainingTime);\n        // Store the timer ID\n        this.inactivityTimers.set(id, timer);\n    }\n    /**\n     * Clear any existing inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @private\n     */\n    clearInactivityTimeout(id) {\n        if (this.inactivityTimers.has(id)) {\n            const timerId = this.inactivityTimers.get(id);\n            clearTimeout(timerId);\n            this.inactivityTimers.delete(id);\n        }\n    }\n    /**\n     * Update activity timestamp for a kernel and reset inactivity timer if present\n     * @param id Kernel ID\n     * @private\n     */\n    updateKernelActivity(id) {\n        // Update the last activity time\n        this.lastActivityTime.set(id, Date.now());\n        // Get the kernel options\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return;\n        const timeout = instance.options.inactivityTimeout;\n        // Reset the inactivity timer if timeout is enabled (greater than 0)\n        if (timeout && timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n    }\n    /**\n     * Get the last activity time for a kernel\n     * @param id Kernel ID\n     * @returns Last activity time in milliseconds since epoch, or undefined if not found\n     */\n    getLastActivityTime(id) {\n        return this.lastActivityTime.get(id);\n    }\n    /**\n     * Get the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @returns Inactivity timeout in milliseconds, or undefined if not set\n     */\n    getInactivityTimeout(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        return instance.options.inactivityTimeout;\n    }\n    /**\n     * Set or update the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds, or 0 to disable\n     * @returns True if the timeout was set, false if the kernel was not found\n     */\n    setInactivityTimeout(id, timeout) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return false;\n        // Update the timeout in the options\n        instance.options.inactivityTimeout = timeout;\n        // Clear any existing timer\n        this.clearInactivityTimeout(id);\n        // If timeout is greater than 0, set up a new timer\n        if (timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n        return true;\n    }\n    /**\n     * Get time until auto-shutdown for a kernel\n     * @param id Kernel ID\n     * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n     */\n    getTimeUntilShutdown(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        const timeout = instance.options.inactivityTimeout;\n        if (!timeout || timeout <= 0)\n            return undefined;\n        const lastActivity = this.lastActivityTime.get(id);\n        if (!lastActivity)\n            return undefined;\n        const elapsedTime = Date.now() - lastActivity;\n        const remainingTime = timeout - elapsedTime;\n        return Math.max(0, remainingTime);\n    }\n    /**\n     * Get the map of inactivity timers (for debugging/testing only)\n     * @returns Object with kernel IDs as keys and timer IDs as values\n     */\n    getInactivityTimers() {\n        // Convert Map to Object for easier inspection\n        const timers = {};\n        this.inactivityTimers.forEach((value, key) => {\n            timers[key] = value;\n        });\n        return timers;\n    }\n    /**\n     * Set up a handler for stalled executions\n     * @param id Kernel ID\n     * @private\n     */\n    setupStalledExecutionHandler(id) {\n        // Listen for stalled execution events\n        super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTION_STALLED, (event) => {\n            if (event.kernelId === id) {\n                console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n                // Emit an event for clients to handle\n                const instance = this.kernels.get(id);\n                if (instance) {\n                    super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                        kernelId: id,\n                        data: {\n                            ename: \"ExecutionStalledError\",\n                            evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n                            traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n                        }\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Force terminate a potentially stuck kernel\n     * @param id Kernel ID\n     * @param reason Optional reason for termination\n     * @returns Promise resolving to true if the kernel was terminated\n     */\n    async forceTerminateKernel(id, reason = \"Force terminated due to stalled execution\") {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        try {\n            // Log the forced termination\n            console.warn(`Force terminating kernel ${id}: ${reason}`);\n            // Emit an error event to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelForcedTermination\",\n                    evalue: reason,\n                    traceback: [\"Kernel was forcefully terminated by the system.\"]\n                }\n            });\n            // Destroy the kernel\n            await this.destroyKernel(id);\n            return true;\n        }\n        catch (error) {\n            console.error(`Error during forced termination of kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Get information about ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Information about ongoing executions with accurate timing\n     */\n    getExecutionInfo(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        // Handle partially initialized kernels where options may not be fully set\n        if (!instance.options) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        const executionIds = this.ongoingExecutions.get(id)\n            ? Array.from(this.ongoingExecutions.get(id))\n            : [];\n        const count = executionIds.length;\n        const currentTime = Date.now();\n        const maxExecutionTime = instance.options.maxExecutionTime;\n        // Build detailed execution information\n        const executions = [];\n        let longestRunningTime = undefined;\n        let anyStuck = false;\n        // Get execution start times and metadata\n        const startTimes = this.executionStartTimes.get(id);\n        const metadata = this.executionMetadata.get(id);\n        for (const executionId of executionIds) {\n            const startTime = startTimes?.get(executionId);\n            const execMetadata = metadata?.get(executionId);\n            if (startTime !== undefined) {\n                const runtime = currentTime - startTime;\n                const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n                executions.push({\n                    id: executionId,\n                    startTime,\n                    runtime,\n                    code: execMetadata?.code,\n                    isStuck\n                });\n                // Track longest running time\n                if (longestRunningTime === undefined || runtime > longestRunningTime) {\n                    longestRunningTime = runtime;\n                }\n                // Track if any execution is stuck\n                if (isStuck) {\n                    anyStuck = true;\n                }\n            }\n            else {\n                // Fallback for executions without start time tracking\n                console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n                executions.push({\n                    id: executionId,\n                    startTime: 0,\n                    runtime: 0,\n                    code: execMetadata?.code,\n                    isStuck: false\n                });\n            }\n        }\n        // Sort executions by start time (oldest first)\n        executions.sort((a, b) => a.startTime - b.startTime);\n        return {\n            count,\n            isStuck: anyStuck,\n            executionIds,\n            longestRunningTime,\n            executions\n        };\n    }\n    /**\n     * Execute Python code in a kernel\n     * Uses executeStream to collect all outputs and return them\n     * @param kernelId ID of the kernel to use\n     * @param code Python code to execute\n     * @param parent Optional parent message header\n     * @returns Promise resolving to execution result with collected outputs\n     */\n    async execute(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        return await instance.kernel.execute(code, parent);\n    }\n    /**\n     * Check if a kernel type is allowed\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns True if the kernel type is allowed\n     * @private\n     */\n    isKernelTypeAllowed(mode, language) {\n        return this.allowedKernelTypes.some(type => type.mode === mode && type.language === language);\n    }\n    /**\n     * Get the list of allowed kernel types\n     * @returns Array of allowed kernel type configurations\n     */\n    getAllowedKernelTypes() {\n        return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n    }\n    /**\n     * Ping a kernel to reset its activity timer and extend the deadline\n     * @param id Kernel ID\n     * @returns True if the kernel was pinged successfully, false if not found\n     */\n    pingKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        // Update kernel activity (this will reset the inactivity timer)\n        this.updateKernelActivity(id);\n        return true;\n    }\n    /**\n     * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n     */\n    async restartKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot restart kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            // Store the current configuration\n            const currentConfig = {\n                mode: instance.mode,\n                language: instance.language,\n                options: { ...instance.options }\n            };\n            // Extract namespace from ID if present\n            let namespace;\n            let baseId;\n            if (id.includes(':')) {\n                const parts = id.split(':');\n                namespace = parts[0];\n                baseId = parts[1];\n            }\n            else {\n                baseId = id;\n            }\n            // Destroy the existing kernel\n            await this.destroyKernel(id);\n            // Create a new kernel with the same configuration\n            const restartOptions = {\n                id: baseId,\n                mode: currentConfig.mode,\n                lang: currentConfig.language,\n                namespace,\n                deno: currentConfig.options.deno,\n                filesystem: currentConfig.options.filesystem,\n                inactivityTimeout: currentConfig.options.inactivityTimeout,\n                maxExecutionTime: currentConfig.options.maxExecutionTime\n            };\n            // Create the new kernel\n            const newKernelId = await this.createKernel(restartOptions);\n            // Verify the new kernel has the same ID\n            if (newKernelId !== id) {\n                console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n                return false;\n            }\n            return true;\n        }\n        catch (error) {\n            console.error(`Error restarting kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Interrupt a running kernel execution\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n     */\n    async interruptKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // For worker kernels, use SharedArrayBuffer interrupt method\n                return await this.interruptWorkerKernel(id, instance);\n            }\n            else {\n                // For main thread kernels, try to interrupt (will throw error if not supported)\n                return await this.interruptMainThreadKernel(id, instance);\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n            return false;\n        }\n    }\n    /**\n     * Interrupt a main thread kernel\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptMainThreadKernel(id, instance) {\n        // Main thread kernels don't support proper interruption like worker kernels do\n        // Even if they have an interrupt method, it's limited and unreliable\n        throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n    }\n    /**\n     * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernel(id, instance) {\n        try {\n            const worker = instance.worker;\n            if (!worker) {\n                console.error(`Worker not found for kernel ${id}`);\n                return false;\n            }\n            // If interruption mode is 'kernel-interrupt', use fallback directly\n            if (this.interruptionMode === 'kernel-interrupt') {\n                return await this.interruptWorkerKernelFallback(id, worker);\n            }\n            // Check if we already have an interrupt buffer for this kernel\n            let interruptBuffer = this.interruptBuffers.get(id);\n            if (!interruptBuffer) {\n                // Create a new SharedArrayBuffer for interrupt control\n                try {\n                    // Try to create SharedArrayBuffer (requires specific security headers)\n                    const sharedBuffer = new SharedArrayBuffer(1);\n                    interruptBuffer = new Uint8Array(sharedBuffer);\n                    // Initialize buffer to 0 (no interrupt signal)\n                    interruptBuffer[0] = 0;\n                    // Store the buffer for future use\n                    this.interruptBuffers.set(id, interruptBuffer);\n                    // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n                    worker.postMessage({\n                        type: \"SET_INTERRUPT_BUFFER\",\n                        buffer: interruptBuffer\n                    });\n                    // Wait for the worker to confirm buffer setup\n                    await new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                        }, 2000);\n                        const handler = (event) => {\n                            if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                                worker.removeEventListener(\"message\", handler);\n                                clearTimeout(timeout);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener(\"message\", handler);\n                    });\n                    console.log(`Interrupt buffer set up for kernel ${id}`);\n                }\n                catch (error) {\n                    // Handle based on interruption mode\n                    if (this.interruptionMode === 'shared-array-buffer') {\n                        // If explicitly set to shared-array-buffer, this is an error\n                        console.error(`âŒ Cannot create SharedArrayBuffer for interrupt handling in kernel ${id}`);\n                        throw new Error(`SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })`);\n                    }\n                    else {\n                        // Auto mode: fall back to kernel.interrupt()\n                        console.info(`â„¹ï¸ Using message-based interrupt for kernel ${id} (SharedArrayBuffer not available)`);\n                        // Fallback: use message-based interrupt\n                        return await this.interruptWorkerKernelFallback(id, worker);\n                    }\n                }\n            }\n            // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n            console.log(`Setting interrupt signal for kernel ${id}...`);\n            interruptBuffer[0] = 2;\n            // Wait for Pyodide to process the interrupt\n            // Pyodide will reset the buffer to 0 when it processes the interrupt\n            let attempts = 0;\n            const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n            while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                attempts++;\n            }\n            if (interruptBuffer[0] === 0) {\n                console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n                return true;\n            }\n            else {\n                console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n                // Still return true as we set the signal - the interrupt may be processed later\n                return true;\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting worker kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernelFallback(id, worker) {\n        return new Promise((resolve) => {\n            // Set up a listener for the interrupt response\n            const responseHandler = (event) => {\n                if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n                    worker.removeEventListener(\"message\", responseHandler);\n                    const success = event.data.data?.success || false;\n                    resolve(success);\n                }\n            };\n            // Listen for the response\n            worker.addEventListener(\"message\", responseHandler);\n            // Send the interrupt message\n            worker.postMessage({\n                type: \"INTERRUPT_KERNEL\"\n            });\n            // Set a timeout in case we don't get a response\n            setTimeout(() => {\n                worker.removeEventListener(\"message\", responseHandler);\n                console.warn(`â±ï¸ Interrupt request timed out for kernel ${id} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`);\n                resolve(false);\n            }, 5000); // 5 second timeout\n        });\n    }\n    /**\n     * Handle a stuck execution with configurable strategies\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID that's stuck\n     * @param actualRuntime How long the execution has been running\n     * @param code The code that was being executed\n     * @private\n     */\n    async handleStuckExecution(kernelId, executionId, actualRuntime, code) {\n        const instance = this.kernels.get(kernelId);\n        if (!instance) {\n            return;\n        }\n        console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n        // Strategy 1: Try to interrupt the kernel first\n        const interruptSuccess = await this.interruptKernel(kernelId);\n        if (interruptSuccess) {\n            console.log(`Successfully interrupted kernel ${kernelId}`);\n            // Emit an execution error to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"ExecutionInterrupted\",\n                    evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n                    traceback: [\n                        `Execution was automatically interrupted due to timeout.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 2: If interrupt failed, try restarting the kernel\n        console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n        const restartSuccess = await this.restartKernel(kernelId);\n        if (restartSuccess) {\n            console.log(`Successfully restarted kernel ${kernelId}`);\n            // Emit a restart notification\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"KernelRestarted\",\n                    evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n                    traceback: [\n                        `Kernel was automatically restarted due to stuck execution.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        `Interrupt attempt failed, kernel was restarted instead.`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 3: If restart failed, force terminate the kernel\n        console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n        const terminateSuccess = await this.forceTerminateKernel(kernelId, `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`);\n        if (terminateSuccess) {\n            console.log(`Successfully terminated kernel ${kernelId}`);\n        }\n        else {\n            console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n            // Emit a critical error\n            super.emit('kernel_unrecoverable', {\n                kernelId: kernelId,\n                executionId: executionId,\n                actualRuntime: actualRuntime,\n                code: code,\n                message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n            });\n        }\n    }\n    /**\n     * Get detailed information about stuck executions across all kernels\n     * @returns Array of stuck execution details\n     */\n    getStuckExecutions() {\n        const stuckExecutions = [];\n        const currentTime = Date.now();\n        for (const [kernelId, instance] of this.kernels.entries()) {\n            // Skip pool kernels\n            if (kernelId.startsWith(\"pool-\"))\n                continue;\n            // Skip kernels without maxExecutionTime configured\n            if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n                continue;\n            }\n            const maxExecutionTime = instance.options.maxExecutionTime;\n            const startTimes = this.executionStartTimes.get(kernelId);\n            const metadata = this.executionMetadata.get(kernelId);\n            const ongoingExecs = this.ongoingExecutions.get(kernelId);\n            if (!ongoingExecs || ongoingExecs.size === 0) {\n                continue;\n            }\n            for (const executionId of ongoingExecs) {\n                const startTime = startTimes?.get(executionId);\n                if (startTime === undefined)\n                    continue;\n                const runtime = currentTime - startTime;\n                // Check if this execution is stuck\n                if (runtime > maxExecutionTime) {\n                    const execMetadata = metadata?.get(executionId);\n                    stuckExecutions.push({\n                        kernelId,\n                        executionId,\n                        startTime,\n                        runtime,\n                        maxAllowed: maxExecutionTime,\n                        code: execMetadata?.code,\n                        kernelMode: instance.mode,\n                        kernelLanguage: instance.language\n                    });\n                }\n            }\n        }\n        // Sort by runtime (longest running first)\n        stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n        return stuckExecutions;\n    }\n    /**\n     * Force interrupt all stuck executions across all kernels\n     * @returns Promise resolving to array of intervention results\n     */\n    async handleAllStuckExecutions() {\n        const stuckExecutions = this.getStuckExecutions();\n        const results = [];\n        console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n        // Group by kernel to avoid multiple interventions on the same kernel\n        const kernelGroups = new Map();\n        for (const exec of stuckExecutions) {\n            if (!kernelGroups.has(exec.kernelId)) {\n                kernelGroups.set(exec.kernelId, []);\n            }\n            kernelGroups.get(exec.kernelId).push(exec);\n        }\n        // Handle each kernel's stuck executions\n        for (const [kernelId, executions] of kernelGroups) {\n            try {\n                // Pick the longest running execution as the primary one\n                const primaryExec = executions[0]; // Already sorted by runtime desc\n                console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n                // Use the automated handling system\n                await this.handleStuckExecution(kernelId, primaryExec.executionId, primaryExec.runtime, primaryExec.code);\n                // Mark all executions for this kernel as handled\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'interrupted', // We don't know the exact action, but it was handled\n                        success: true\n                    });\n                }\n            }\n            catch (error) {\n                console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n                // Mark all executions for this kernel as failed\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'failed',\n                        success: false,\n                        error: error instanceof Error ? error.message : String(error)\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Set up interrupt buffer for a worker kernel during creation\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @private\n     */\n    async setupWorkerInterruptBuffer(id, worker) {\n        // Skip SharedArrayBuffer setup if mode is 'kernel-interrupt'\n        if (this.interruptionMode === 'kernel-interrupt') {\n            console.log(`Skipping SharedArrayBuffer setup for kernel ${id} - using kernel.interrupt() mode`);\n            return;\n        }\n        try {\n            // Python kernels support interrupt buffers\n            // For Python kernels, create actual SharedArrayBuffer\n            const sharedBuffer = new SharedArrayBuffer(1);\n            const interruptBuffer = new Uint8Array(sharedBuffer);\n            // Initialize buffer to 0 (no interrupt signal)\n            interruptBuffer[0] = 0;\n            // Store the buffer for future use\n            this.interruptBuffers.set(id, interruptBuffer);\n            // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n            worker.postMessage({\n                type: \"SET_INTERRUPT_BUFFER\",\n                buffer: interruptBuffer\n            });\n            // Wait for the worker to confirm buffer setup\n            await new Promise((resolve, reject) => {\n                const timeout = setTimeout(() => {\n                    reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                }, 5000);\n                const handler = (event) => {\n                    if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                        worker.removeEventListener(\"message\", handler);\n                        clearTimeout(timeout);\n                        resolve();\n                    }\n                };\n                worker.addEventListener(\"message\", handler);\n            });\n        }\n        catch (error) {\n            // Handle based on interruption mode\n            if (this.interruptionMode === 'shared-array-buffer') {\n                // If explicitly set to shared-array-buffer, this is an error\n                console.error(`âŒ SharedArrayBuffer required but not available for kernel ${id}`);\n                throw new Error(`SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.`);\n            }\n            else {\n                // Auto mode: fall back to kernel.interrupt()\n                console.info(`â„¹ï¸ SharedArrayBuffer not available for kernel ${id}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`);\n                // Don't throw - kernel can still work without interrupt buffer\n            }\n        }\n    }\n    /**\n     * Get information about mounted filesystems for a specific kernel\n     * @param id Kernel ID\n     * @returns Promise resolving to array of mounted filesystem info\n     */\n    async getMountedFileSystems(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            throw new Error(`Kernel ${id} not found`);\n        }\n        try {\n            if (typeof instance.kernel.getMountedFileSystems === 'function') {\n                return instance.kernel.getMountedFileSystems();\n            }\n            else {\n                console.warn(`Kernel ${id} does not support getMountedFileSystems method`);\n                return [];\n            }\n        }\n        catch (error) {\n            console.error(`Error getting mounted filesystems for kernel ${id}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Manually sync a specific mounted filesystem for a kernel\n     * @param id Kernel ID\n     * @param mountPath The path of the mounted filesystem to sync\n     * @returns Promise resolving to sync result\n     */\n    async syncFileSystem(id, mountPath) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            throw new Error(`Kernel ${id} not found`);\n        }\n        try {\n            if (typeof instance.kernel.syncFileSystem === 'function') {\n                return await instance.kernel.syncFileSystem(mountPath);\n            }\n            else {\n                console.warn(`Kernel ${id} does not support syncFileSystem method`);\n                return {\n                    success: false,\n                    error: 'syncFileSystem is not supported by this kernel'\n                };\n            }\n        }\n        catch (error) {\n            console.error(`Error syncing filesystem for kernel ${id}:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n    /**\n     * Upgrade a mounted filesystem from read-only to read-write permission\n     * @param id Kernel ID\n     * @param mountPath The path of the mounted filesystem to upgrade\n     * @returns Promise resolving to upgrade result\n     */\n    async upgradeFileSystemPermission(id, mountPath) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            throw new Error(`Kernel ${id} not found`);\n        }\n        try {\n            if (typeof instance.kernel.upgradeFileSystemPermission === 'function') {\n                return await instance.kernel.upgradeFileSystemPermission(mountPath);\n            }\n            else {\n                console.warn(`Kernel ${id} does not support upgradeFileSystemPermission method`);\n                return {\n                    success: false,\n                    error: 'upgradeFileSystemPermission is not supported by this kernel'\n                };\n            }\n        }\n        catch (error) {\n            console.error(`Error upgrading filesystem permission for kernel ${id}:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gS2VybmVsIE1hbmFnZXIgZm9yIERlbm8gQXBwIEVuZ2luZVxuLy8gVGhpcyBmaWxlIG1hbmFnZXMga2VybmVsIGluc3RhbmNlcyBpbiBlaXRoZXIgbWFpbiB0aHJlYWQgb3Igd29ya2VyIG1vZGVcblxuaW1wb3J0ICogYXMgQ29tbGluayBmcm9tIFwiY29tbGlua1wiO1xuLy8gQHRzLWlnbm9yZSBJbXBvcnRpbmcgZnJvbSBucG1cbi8vIFVzZSBhIGJyb3dzZXItY29tcGF0aWJsZSBFdmVudEVtaXR0ZXJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgZXZlbnRzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uW10gfSA9IHt9O1xuXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgZW1pdChldmVudE5hbWU6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoLi4uYXJncykpO1xuICB9XG5cbiAgc2V0TWF4TGlzdGVuZXJzKG46IG51bWJlcikge1xuICAgIC8vIE5vLW9wIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbiAgfVxufVxuaW1wb3J0IHsgS2VybmVsRXZlbnRzLCBJS2VybmVsLCBJS2VybmVsT3B0aW9ucywgSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgS2VybmVsIH0gZnJvbSBcIi4vaW5kZXhcIjtcblxuLy8gUmUtZXhwb3J0IEtlcm5lbEV2ZW50cyBmb3IgdGVzdCB1c2FnZVxuZXhwb3J0IHsgS2VybmVsRXZlbnRzIH07XG5cbi8vIEV4ZWN1dGlvbiBtb2RlIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbE1vZGUge1xuICBNQUlOX1RIUkVBRCA9IFwibWFpbl90aHJlYWRcIixcbiAgV09SS0VSID0gXCJ3b3JrZXJcIlxufVxuXG4vLyBLZXJuZWwgbGFuZ3VhZ2UgZW51bVxuZXhwb3J0IGVudW0gS2VybmVsTGFuZ3VhZ2Uge1xuICBQWVRIT04gPSBcInB5dGhvblwiXG59XG5cbi8vIEV4dGVuZGVkIFdvcmtlck9wdGlvbnMgaW50ZXJmYWNlIHRvIGluY2x1ZGUgRGVubyBwZXJtaXNzaW9uc1xuaW50ZXJmYWNlIFdvcmtlck9wdGlvbnMge1xuICB0eXBlPzogXCJjbGFzc2ljXCIgfCBcIm1vZHVsZVwiO1xuICBuYW1lPzogc3RyaW5nO1xuICBkZW5vPzoge1xuICAgIHBlcm1pc3Npb25zPzogSURlbm9QZXJtaXNzaW9ucztcbiAgfTtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgcG9vbCBjb25maWd1cmF0aW9uXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxQb29sQ29uZmlnIHtcbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgcG9vbFNpemU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGtlcm5lbHMgdG8ga2VlcCByZWFkeSBwZXIgY29uZmlndXJhdGlvblxuICBhdXRvUmVmaWxsOiBib29sZWFuOyAvLyBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgcmVmaWxsIHRoZSBwb29sIHdoZW4ga2VybmVscyBhcmUgdGFrZW5cbiAgcHJlbG9hZENvbmZpZ3M6IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT47IC8vIENvbmZpZ3VyYXRpb25zIHRvIHByZWxvYWQgaW4gdGhlIHBvb2xcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgbWFuYWdlciBvcHRpb25zXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxNYW5hZ2VyT3B0aW9ucyB7XG4gIHBvb2w/OiBJS2VybmVsUG9vbENvbmZpZztcbiAgYWxsb3dlZEtlcm5lbFR5cGVzPzogQXJyYXk8e1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PjsgLy8gUmVzdHJpY3Qgd2hpY2gga2VybmVsIHR5cGVzIGNhbiBiZSBjcmVhdGVkXG4gIGludGVycnVwdGlvbk1vZGU/OiAnc2hhcmVkLWFycmF5LWJ1ZmZlcicgfCAna2VybmVsLWludGVycnVwdCcgfCAnYXV0byc7IC8vIERlZmF1bHQ6ICdhdXRvJ1xuICB3b3JrZXJVcmw/OiBzdHJpbmc7IC8vIE9wdGlvbmFsIGN1c3RvbSBVUkwgZm9yIHRoZSB3b3JrZXIgc2NyaXB0XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIGluc3RhbmNlXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxJbnN0YW5jZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGtlcm5lbDogSUtlcm5lbDtcbiAgbW9kZTogS2VybmVsTW9kZTtcbiAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB3b3JrZXI/OiBXb3JrZXI7XG4gIGNyZWF0ZWQ6IHN0cmluZztcbiAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zO1xuICBpc0Zyb21Qb29sPzogYm9vbGVhbjsgLy8gVHJhY2sgaWYgdGhpcyBrZXJuZWwgY2FtZSBmcm9tIHRoZSBwb29sXG4gIGRlc3Ryb3koKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBEZW5vIHdvcmtlciBwZXJtaXNzaW9uc1xuZXhwb3J0IGludGVyZmFjZSBJRGVub1Blcm1pc3Npb25zIHtcbiAgcmVhZD86IChzdHJpbmcgfCBVUkwpW107XG4gIHdyaXRlPzogKHN0cmluZyB8IFVSTClbXTtcbiAgbmV0Pzogc3RyaW5nW107XG4gIGVudj86IHN0cmluZ1tdO1xuICBydW4/OiBzdHJpbmdbXTtcbiAgZmZpPzogc3RyaW5nW107XG4gIGhydGltZT86IGJvb2xlYW47XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIGNyZWF0aW9uIG9wdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgSU1hbmFnZXJLZXJuZWxPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG1vZGU/OiBLZXJuZWxNb2RlO1xuICBsYW5nPzogS2VybmVsTGFuZ3VhZ2U7XG4gIG5hbWVzcGFjZT86IHN0cmluZztcbiAgZGVubz86IHtcbiAgICBwZXJtaXNzaW9ucz86IElEZW5vUGVybWlzc2lvbnM7XG4gIH07XG4gIGZpbGVzeXN0ZW0/OiBJRmlsZVN5c3RlbU1vdW50T3B0aW9ucztcbiAgZW52PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjsgLy8gRW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIHNldCBpbiB0aGUga2VybmVsXG4gIGxvY2tGaWxlVVJMPzogc3RyaW5nOyAvLyBVUkwgdG8gcHlvZGlkZS1sb2NrLmpzb24gZmlsZSBmb3IgZmFzdGVyIGxvYWRpbmdcbiAgYXV0b1N5bmNGcz86IGJvb2xlYW47IC8vIEF1dG9tYXRpY2FsbHkgc3luYyBuYXRpdmUgZmlsZXN5c3RlbSBhZnRlciBjb2RlIGV4ZWN1dGlvbiAoZGVmYXVsdDogZmFsc2UpXG4gIGluYWN0aXZpdHlUaW1lb3V0PzogbnVtYmVyOyAvLyBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCBhbiBpbmFjdGl2ZSBrZXJuZWwgd2lsbCBiZSBzaHV0IGRvd25cbiAgbWF4RXhlY3V0aW9uVGltZT86IG51bWJlcjsgLy8gTWF4aW11bSB0aW1lIGluIG1pbGxpc2Vjb25kcyBhIHNpbmdsZSBleGVjdXRpb24gY2FuIHJ1biBiZWZvcmUgY29uc2lkZXJlZCBzdHVjay9kZWFkXG59XG5cbi8vIEhlbHBlciB0eXBlIGZvciBsaXN0ZW5lciBtYW5hZ2VtZW50XG50eXBlIExpc3RlbmVyV3JhcHBlciA9IHtcbiAgb3JpZ2luYWw6IChkYXRhOiBhbnkpID0+IHZvaWQ7XG4gIHdyYXBwZWQ6IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4gdm9pZDtcbn07XG5cbi8qKlxuICogS2VybmVsTWFuYWdlciBjbGFzcyBtYW5hZ2VzIG11bHRpcGxlIGtlcm5lbCBpbnN0YW5jZXMgXG4gKiBpbiBlaXRoZXIgbWFpbiB0aHJlYWQgb3Igd29ya2VyIG1vZGVcbiAqL1xuZXhwb3J0IGNsYXNzIEtlcm5lbE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGtlcm5lbHM6IE1hcDxzdHJpbmcsIElLZXJuZWxJbnN0YW5jZT4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxpc3RlbmVycyBmb3IgZWFjaCBrZXJuZWwgdG8gZW5hYmxlIGluZGl2aWR1YWwgcmVtb3ZhbFxuICBwcml2YXRlIGxpc3RlbmVyV3JhcHBlcnM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIE1hcDxGdW5jdGlvbiwgTGlzdGVuZXJXcmFwcGVyPj4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBsYXN0IGFjdGl2aXR5IHRpbWUgZm9yIGVhY2gga2VybmVsXG4gIHByaXZhdGUgbGFzdEFjdGl2aXR5VGltZTogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgLy8gU3RvcmUgaW5hY3Rpdml0eSB0aW1lcnMgZm9yIGVhY2gga2VybmVsXG4gIHByaXZhdGUgaW5hY3Rpdml0eVRpbWVyczogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgb25nb2luZyBleGVjdXRpb25zIGZvciBlYWNoIGtlcm5lbFxuICBwcml2YXRlIG9uZ29pbmdFeGVjdXRpb25zOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGV4ZWN1dGlvbiB0aW1lb3V0cyBmb3IgZGV0ZWN0aW5nIHN0dWNrL2RlYWQga2VybmVsc1xuICBwcml2YXRlIGV4ZWN1dGlvblRpbWVvdXRzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBhbnk+PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzIGZvciBhY2N1cmF0ZSBkdXJhdGlvbiBjYWxjdWxhdGlvblxuICBwcml2YXRlIGV4ZWN1dGlvblN0YXJ0VGltZXM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIG51bWJlcj4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBleGVjdXRpb24gbWV0YWRhdGEgZm9yIGJldHRlciBtb25pdG9yaW5nXG4gIHByaXZhdGUgZXhlY3V0aW9uTWV0YWRhdGE6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIHsgc3RhcnRUaW1lOiBudW1iZXI7IGNvZGU/OiBzdHJpbmc7IHRpbWVvdXRJZD86IGFueSB9Pj4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBUcmFjayBBYm9ydENvbnRyb2xsZXJzIGZvciBlYWNoIGtlcm5lbCdzIG9uZ29pbmcgb3BlcmF0aW9uc1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcnM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj4+ID0gbmV3IE1hcCgpO1xuICBcbiAgLy8gUG9vbCBtYW5hZ2VtZW50IC0gbm93IHVzaW5nIHByb21pc2VzIGZvciBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgcHJpdmF0ZSBwb29sOiBNYXA8c3RyaW5nLCBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT5bXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcG9vbENvbmZpZzogSUtlcm5lbFBvb2xDb25maWc7XG4gIHByaXZhdGUgaXNQcmVsb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIC8vIFRyYWNrIHdoaWNoIHBvb2wga2V5cyBhcmUgY3VycmVudGx5IGJlaW5nIHByZWZpbGxlZCB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgcHJpdmF0ZSBwcmVmaWxsaW5nSW5Qcm9ncmVzczogTWFwPHN0cmluZywgYm9vbGVhbj4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBBbGxvd2VkIGtlcm5lbCB0eXBlcyBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgYWxsb3dlZEtlcm5lbFR5cGVzOiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+O1xuICBcbiAgLy8gSW50ZXJydXB0IGJ1ZmZlcnMgZm9yIHdvcmtlciBrZXJuZWxzICh1c2luZyBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgcHJpdmF0ZSBpbnRlcnJ1cHRCdWZmZXJzOiBNYXA8c3RyaW5nLCBVaW50OEFycmF5PiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIEludGVycnVwdGlvbiBtb2RlIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBpbnRlcnJ1cHRpb25Nb2RlOiAnc2hhcmVkLWFycmF5LWJ1ZmZlcicgfCAna2VybmVsLWludGVycnVwdCcgfCAnYXV0byc7XG4gIFxuICAvLyBXb3JrZXIgVVJMIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSB3b3JrZXJVcmw6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSB3b3JrZXIgVVJMIGJhc2VkIG9uIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIFRoZSByZXNvbHZlZCB3b3JrZXIgVVJMXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVXb3JrZXJVcmwoKTogc3RyaW5nIHtcbiAgICAvLyBJZiBhIGN1c3RvbSB3b3JrZXIgVVJMIGlzIHByb3ZpZGVkLCB1c2UgaXRcbiAgICBpZiAodGhpcy53b3JrZXJVcmwpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtlclVybDtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgY3VycmVudCBzY3JpcHQgbG9jYXRpb24gYW5kIGRlcml2ZSB0aGUgd29ya2VyIFVSTFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIC8vIEJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgIGNvbnN0IGN1cnJlbnRTY3JpcHQgPSAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSkucG9wKCk7XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50U2NyaXB0ICYmIGN1cnJlbnRTY3JpcHQuc3JjKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYmFzZSBVUkwgZnJvbSB0aGUgY3VycmVudCBzY3JpcHRcbiAgICAgICAgY29uc3Qgc2NyaXB0VXJsID0gbmV3IFVSTChjdXJyZW50U2NyaXB0LnNyYyk7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBzY3JpcHRVcmwuaHJlZi5zdWJzdHJpbmcoMCwgc2NyaXB0VXJsLmhyZWYubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBsb2FkaW5nIGZyb20gYSBDRE4gKGpzZGVsaXZyLCB1bnBrZywgZXRjLilcbiAgICAgICAgaWYgKHNjcmlwdFVybC5ob3N0bmFtZS5pbmNsdWRlcygnanNkZWxpdnIubmV0JykgfHwgXG4gICAgICAgICAgICBzY3JpcHRVcmwuaG9zdG5hbWUuaW5jbHVkZXMoJ3VucGtnLmNvbScpIHx8XG4gICAgICAgICAgICBzY3JpcHRVcmwuaG9zdG5hbWUuaW5jbHVkZXMoJ2NkbmpzLmNsb3VkZmxhcmUuY29tJykpIHtcbiAgICAgICAgICAvLyBGb3IgQ0ROLCB0aGUgd29ya2VyIHNob3VsZCBiZSBhdCB0aGUgc2FtZSBwYXRoXG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2tlcm5lbC53b3JrZXIuanNgO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGb3IgbG9jYWwgZGV2ZWxvcG1lbnQgb3IgY3VzdG9tIGRlcGxveW1lbnRzXG4gICAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9rZXJuZWwud29ya2VyLmpzYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8gcmVsYXRpdmUgcGF0aCBmcm9tIGN1cnJlbnQgbG9jYXRpb25cbiAgICAgIGNvbnN0IGJhc2VVcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZygwLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZGlzdC9rZXJuZWwud29ya2VyLmpzYDtcbiAgICB9XG4gICAgXG4gICAgLy8gTm9kZS5qcyBvciB1bmtub3duIGVudmlyb25tZW50IC0gdXNlIHJlbGF0aXZlIHBhdGhcbiAgICAvLyBUaGlzIG1heSBub3Qgd29yayBpbiBOb2RlLmpzIGJ1dCBpcyBwcm92aWRlZCBhcyBhIGZhbGxiYWNrXG4gICAgcmV0dXJuICcuL2tlcm5lbC53b3JrZXIuanMnO1xuICB9XG4gIFxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgS2V5Ym9hcmRJbnRlcnJ1cHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaXNLZXlib2FyZEludGVycnVwdChlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVycm9yICYmIFxuICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIFxuICAgICAgICAgICAoKCd0eXBlJyBpbiBlcnJvciAmJiBlcnJvci50eXBlID09PSBcIktleWJvYXJkSW50ZXJydXB0XCIpIHx8XG4gICAgICAgICAgICAoJ21lc3NhZ2UnIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiS2V5Ym9hcmRJbnRlcnJ1cHRcIikpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdGFuZGFyZGl6ZWQgS2V5Ym9hcmRJbnRlcnJ1cHQgZXJyb3IgcmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUtleWJvYXJkSW50ZXJydXB0UmVzdWx0KCk6IHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I6IEVycm9yOyByZXN1bHQ6IGFueSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IEVycm9yKFwiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIpLFxuICAgICAgcmVzdWx0OiB7XG4gICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICBlbmFtZTogXCJLZXlib2FyZEludGVycnVwdFwiLFxuICAgICAgICBldmFsdWU6IFwiRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIixcbiAgICAgICAgdHJhY2ViYWNrOiBbXCJLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIl1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFxuICAvKipcbiAgICogU3RvcmUgYW4gQWJvcnRDb250cm9sbGVyIGZvciBhIHNwZWNpZmljIGtlcm5lbCBleGVjdXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RvcmVBYm9ydENvbnRyb2xsZXIoa2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZywgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmFib3J0Q29udHJvbGxlcnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwgY29udHJvbGxlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gYW4gQWJvcnRDb250cm9sbGVyIGZvciBhIHNwZWNpZmljIGtlcm5lbCBleGVjdXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcpOiBBYm9ydENvbnRyb2xsZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGtlcm5lbENvbnRyb2xsZXJzID0gdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxDb250cm9sbGVycykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBjb250cm9sbGVyID0ga2VybmVsQ29udHJvbGxlcnMuZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAga2VybmVsQ29udHJvbGxlcnMuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIGlmIChrZXJuZWxDb250cm9sbGVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydCBhbGwgb25nb2luZyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhYm9ydEFsbEtlcm5lbE9wZXJhdGlvbnMoa2VybmVsSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbENvbnRyb2xsZXJzID0gdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxDb250cm9sbGVycykgcmV0dXJuO1xuXG4gICAgZm9yIChjb25zdCBbZXhlY3V0aW9uSWQsIGNvbnRyb2xsZXJdIG9mIGtlcm5lbENvbnRyb2xsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEFib3J0ZWQgZXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IGZvciBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEVycm9yIGFib3J0aW5nIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfTpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIGFsbCBjb250cm9sbGVycyBmb3IgdGhpcyBrZXJuZWxcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgfVxuICBcbiAgY29uc3RydWN0b3Iob3B0aW9uczogSUtlcm5lbE1hbmFnZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnNldE1heExpc3RlbmVycygxMDApOyAvLyBBbGxvdyBtYW55IGxpc3RlbmVycyBmb3Iga2VybmVsIGV2ZW50c1xuICAgIFxuICAgIC8vIFNldCBpbnRlcnJ1cHRpb24gbW9kZSAoZGVmYXVsdCB0byAnYXV0bycpXG4gICAgdGhpcy5pbnRlcnJ1cHRpb25Nb2RlID0gb3B0aW9ucy5pbnRlcnJ1cHRpb25Nb2RlIHx8ICdhdXRvJztcbiAgICBcbiAgICAvLyBTZXQgd29ya2VyIFVSTCBpZiBwcm92aWRlZFxuICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucy53b3JrZXJVcmw7XG4gICAgXG4gICAgLy8gU2V0IGRlZmF1bHQgYWxsb3dlZCBrZXJuZWwgdHlwZXMgKHdvcmtlciBtb2RlIG9ubHkgZm9yIHNlY3VyaXR5KVxuICAgIHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzID0gb3B0aW9ucy5hbGxvd2VkS2VybmVsVHlwZXMgfHwgW1xuICAgICAgeyBtb2RlOiBLZXJuZWxNb2RlLldPUktFUiwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlLlBZVEhPTiB9XG4gICAgXTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHBvb2wgY29uZmlndXJhdGlvbiB3aXRoIGRlZmF1bHRzIGJhc2VkIG9uIGFsbG93ZWQgdHlwZXNcbiAgICBjb25zdCBkZWZhdWx0UHJlbG9hZENvbmZpZ3MgPSB0aGlzLmFsbG93ZWRLZXJuZWxUeXBlcy5maWx0ZXIodHlwZSA9PiBcbiAgICAgIHR5cGUubGFuZ3VhZ2UgPT09IEtlcm5lbExhbmd1YWdlLlBZVEhPTiAvLyBPbmx5IHByZWxvYWQgUHl0aG9uIGtlcm5lbHMgYnkgZGVmYXVsdFxuICAgICk7XG4gICAgXG4gICAgdGhpcy5wb29sQ29uZmlnID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBwb29sU2l6ZTogMixcbiAgICAgIGF1dG9SZWZpbGw6IHRydWUsXG4gICAgICBwcmVsb2FkQ29uZmlnczogZGVmYXVsdFByZWxvYWRDb25maWdzLFxuICAgICAgLi4ub3B0aW9ucy5wb29sXG4gICAgfTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHBvb2wgcHJlbG9hZCBjb25maWdzIGFyZSB3aXRoaW4gYWxsb3dlZCB0eXBlc1xuICAgIGlmICh0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3MpIHtcbiAgICAgIHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncyA9IHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncy5maWx0ZXIoY29uZmlnID0+IHtcbiAgICAgICAgY29uc3QgaXNBbGxvd2VkID0gdGhpcy5pc0tlcm5lbFR5cGVBbGxvd2VkKGNvbmZpZy5tb2RlLCBjb25maWcubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgUG9vbCBwcmVsb2FkIGNvbmZpZyAke2NvbmZpZy5tb2RlfS0ke2NvbmZpZy5sYW5ndWFnZX0gaXMgbm90IGluIGFsbG93ZWRLZXJuZWxUeXBlcywgc2tpcHBpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBbGxvd2VkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0YXJ0IHByZWxvYWRpbmcgaWYgcG9vbCBpcyBlbmFibGVkXG4gICAgaWYgKHRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnByZWxvYWRQb29sKCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJlbG9hZGluZyBrZXJuZWwgcG9vbDpcIiwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcG9vbCBrZXkgZm9yIGEgZ2l2ZW4gbW9kZSBhbmQgbGFuZ3VhZ2UgY29tYmluYXRpb25cbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBQb29sIGtleSBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZ2V0UG9vbEtleShtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHttb2RlfS0ke2xhbmd1YWdlfWA7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBrZXJuZWwgcHJvbWlzZSBmcm9tIHRoZSBwb29sIGlmIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIEtlcm5lbCBwcm9taXNlIG9yIG51bGwgaWYgbm9uZSBhdmFpbGFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZ2V0RnJvbVBvb2wobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHwgbnVsbCB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSk7XG4gICAgXG4gICAgaWYgKCFwb29sUHJvbWlzZXMgfHwgcG9vbFByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBmaXJzdCBwcm9taXNlIGZyb20gdGhlIHBvb2wgKEZJRk8pXG4gICAgY29uc3Qga2VybmVsUHJvbWlzZSA9IHBvb2xQcm9taXNlcy5zaGlmdCgpITtcbiAgICBcbiAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIGJhY2tncm91bmQgcmVmaWxsIHRvIGFkZCBvbmUgcHJvbWlzZSBiYWNrXG4gICAgaWYgKHRoaXMucG9vbENvbmZpZy5hdXRvUmVmaWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWZpbGxQb29sU2luZ2xlKG1vZGUsIGxhbmd1YWdlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVmaWxsaW5nIHNpbmdsZSBrZXJuZWwgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ga2VybmVsUHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEFkZCBhIGtlcm5lbCBwcm9taXNlIHRvIHRoZSBwb29sXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHBhcmFtIGtlcm5lbFByb21pc2UgS2VybmVsIHByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYWRkVG9Qb29sKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSwga2VybmVsUHJvbWlzZTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBcbiAgICBpZiAoIXRoaXMucG9vbC5oYXMocG9vbEtleSkpIHtcbiAgICAgIHRoaXMucG9vbC5zZXQocG9vbEtleSwgW10pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpITtcbiAgICBcbiAgICAvLyBPbmx5IGFkZCBpZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIHBvb2wgc2l6ZSBsaW1pdFxuICAgIGlmIChwb29sUHJvbWlzZXMubGVuZ3RoIDwgdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplKSB7XG4gICAgICBwb29sUHJvbWlzZXMucHVzaChrZXJuZWxQcm9taXNlKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHByb21pc2UgcmVqZWN0aW9uIHRvIHByZXZlbnQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgIGtlcm5lbFByb21pc2UuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBQb29sIGtlcm5lbCBwcm9taXNlIHJlamVjdGVkIGZvciAke3Bvb2xLZXl9OmAsIGVycm9yKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmYWlsZWQgcHJvbWlzZSBmcm9tIHRoZSBwb29sXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcG9vbFByb21pc2VzLmluZGV4T2Yoa2VybmVsUHJvbWlzZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwb29sUHJvbWlzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBvb2wgaXMgZnVsbCwgbGV0IHRoZSBleGNlc3MgcHJvbWlzZSByZXNvbHZlIGFuZCB0aGVuIGRlc3Ryb3kgdGhlIGtlcm5lbFxuICAgICAga2VybmVsUHJvbWlzZS50aGVuKGtlcm5lbCA9PiB7XG4gICAgICAgIGtlcm5lbC5kZXN0cm95KCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXN0cm95aW5nIGV4Y2VzcyBwb29sIGtlcm5lbDpcIiwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkV4Y2VzcyBwb29sIGtlcm5lbCBwcm9taXNlIHJlamVjdGVkOlwiLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZWZpbGwgdGhlIHBvb2wgd2l0aCBhIHNpbmdsZSBrZXJuZWwgcHJvbWlzZVxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlZmlsbFBvb2xTaW5nbGUobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpIHx8IFtdO1xuICAgIFxuICAgIC8vIE9ubHkgYWRkIG9uZSBpZiB3ZSdyZSBiZWxvdyB0aGUgcG9vbCBzaXplXG4gICAgaWYgKHBvb2xQcm9taXNlcy5sZW5ndGggPCB0aGlzLnBvb2xDb25maWcucG9vbFNpemUpIHtcbiAgICAgIGNvbnN0IGtlcm5lbFByb21pc2UgPSB0aGlzLmNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgIHRoaXMuYWRkVG9Qb29sKG1vZGUsIGxhbmd1YWdlLCBrZXJuZWxQcm9taXNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVmaWxsIHRoZSBwb29sIGZvciBhIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gd2l0aCBwYXJhbGxlbCBjcmVhdGlvblxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlZmlsbFBvb2wobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByZWZpbGxpbmcgdGhpcyBwb29sIGtleSB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICBpZiAodGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5nZXQocG9vbEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHByZWZpbGxpbmcgZmxhZ1xuICAgIHRoaXMucHJlZmlsbGluZ0luUHJvZ3Jlc3Muc2V0KHBvb2xLZXksIHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpIHx8IFtdO1xuICAgICAgY29uc3QgbmVlZGVkID0gdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplIC0gcG9vbFByb21pc2VzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgaWYgKG5lZWRlZCA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGFsbCBuZWVkZWQga2VybmVsIHByb21pc2VzIGluIHBhcmFsbGVsXG4gICAgICBjb25zdCBuZXdQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG5lZWRlZCB9LCAoKSA9PiBcbiAgICAgICAgdGhpcy5jcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlLCBsYW5ndWFnZSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhbGwgcHJvbWlzZXMgdG8gdGhlIHBvb2xcbiAgICAgIGZvciAoY29uc3Qga2VybmVsUHJvbWlzZSBvZiBuZXdQcm9taXNlcykge1xuICAgICAgICB0aGlzLmFkZFRvUG9vbChtb2RlLCBsYW5ndWFnZSwga2VybmVsUHJvbWlzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVmaWxsaW5nIHBvb2wgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBBbHdheXMgY2xlYXIgdGhlIHByZWZpbGxpbmcgZmxhZ1xuICAgICAgdGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5zZXQocG9vbEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBwcm9taXNlIGZvciB0aGUgcG9vbFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXJuZWwgPSBhd2FpdCB0aGlzLmNyZWF0ZVBvb2xLZXJuZWwobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICAvLyBNYXJrIGFzIHRha2VuIGZyb20gcG9vbFxuICAgICAgICBrZXJuZWwuaXNGcm9tUG9vbCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoa2VybmVsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nIHBvb2wga2VybmVsIGZvciAke21vZGV9LSR7bGFuZ3VhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgc3BlY2lmaWNhbGx5IGZvciB0aGUgcG9vbFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVQb29sS2VybmVsKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgLy8gR2VuZXJhdGUgYSB0ZW1wb3JhcnkgSUQgZm9yIHRoZSBwb29sIGtlcm5lbFxuICAgIGNvbnN0IHRlbXBJZCA9IGBwb29sLSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgIFxuICAgIC8vIENyZWF0ZSBrZXJuZWwgd2l0aCBtaW5pbWFsIGNvbmZpZ3VyYXRpb25cbiAgICBjb25zdCBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMgPSB7XG4gICAgICBtb2RlLFxuICAgICAgbGFuZzogbGFuZ3VhZ2VcbiAgICB9O1xuICAgIFxuICAgIC8vIFN0b3JlIG9wdGlvbnMgdGVtcG9yYXJpbHkgLSBidXQgZG9uJ3Qgc3RvcmUgaW5jb21wbGV0ZSBpbnN0YW5jZSBpbiBrZXJuZWxzIG1hcFxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIHBhc3MgdGhlIG9wdGlvbnMgZGlyZWN0bHkgdG8gdGhlIGNyZWF0aW9uIG1ldGhvZHNcbiAgICBsZXQgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgaWYgKG1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgICAgLy8gRm9yIG1haW4gdGhyZWFkLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHN0b3JlIHRoZSBpbnN0YW5jZSBmb3IgY3JlYXRlTWFpblRocmVhZEtlcm5lbFxuICAgICAgICBjb25zdCB0ZW1wSW5zdGFuY2UgPSB7XG4gICAgICAgICAgaWQ6IHRlbXBJZCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgbGFuZ3VhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXJuZWxzLnNldCh0ZW1wSWQsIHRlbXBJbnN0YW5jZSBhcyB1bmtub3duIGFzIElLZXJuZWxJbnN0YW5jZSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVNYWluVGhyZWFkS2VybmVsKHRlbXBJZCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQWx3YXlzIGNsZWFuIHVwIHRoZSB0ZW1wb3JhcnkgaW5zdGFuY2VcbiAgICAgICAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKHRlbXBJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciB3b3JrZXIgbW9kZSwgd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBzdG9yZSB0aGUgaW5zdGFuY2UgZm9yIGNyZWF0ZVdvcmtlcktlcm5lbFxuICAgICAgICBjb25zdCB0ZW1wSW5zdGFuY2UgPSB7XG4gICAgICAgICAgaWQ6IHRlbXBJZCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgbGFuZ3VhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXJuZWxzLnNldCh0ZW1wSWQsIHRlbXBJbnN0YW5jZSBhcyB1bmtub3duIGFzIElLZXJuZWxJbnN0YW5jZSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVXb3JrZXJLZXJuZWwodGVtcElkKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBBbHdheXMgY2xlYW4gdXAgdGhlIHRlbXBvcmFyeSBpbnN0YW5jZVxuICAgICAgICAgIHRoaXMua2VybmVscy5kZWxldGUodGVtcElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBFbnN1cmUgY2xlYW51cCBvbiBhbnkgZXJyb3JcbiAgICAgIHRoaXMua2VybmVscy5kZWxldGUodGVtcElkKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBQcmVsb2FkIHRoZSBrZXJuZWwgcG9vbCB3aXRoIGNvbmZpZ3VyZWQga2VybmVsIHR5cGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByZWxvYWRQb29sKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQgfHwgdGhpcy5pc1ByZWxvYWRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5pc1ByZWxvYWRpbmcgPSB0cnVlO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBQcmVsb2FkIGtlcm5lbHMgZm9yIGVhY2ggY29uZmlndXJlZCB0eXBlXG4gICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiB0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlZmlsbFBvb2woY29uZmlnLm1vZGUsIGNvbmZpZy5sYW5ndWFnZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJlbG9hZGluZyAke2NvbmZpZy5tb2RlfS0ke2NvbmZpZy5sYW5ndWFnZX06YCwgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgY29uZmlndXJhdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGtlcm5lbCBwb29sIHByZWxvYWRpbmc6XCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc1ByZWxvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtlcm5lbCByZXF1ZXN0IGNhbiB1c2UgdGhlIHBvb2xcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcmVxdWVzdCBjYW4gdXNlIHBvb2xcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY2FuVXNlUG9vbChvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMpOiBib29sZWFuIHtcbiAgICAvLyBEb24ndCB1c2UgcG9vbCBpZiBpdCdzIGRpc2FibGVkXG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBEb24ndCB1c2UgcG9vbCBpZiBjdXN0b20gZmlsZXN5c3RlbSBvciBwZXJtaXNzaW9ucyBhcmUgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMuZmlsZXN5c3RlbSB8fCBvcHRpb25zLmRlbm8/LnBlcm1pc3Npb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHVzZSBwb29sIGlmIGN1c3RvbSB0aW1lb3V0cyBhcmUgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlYXNzaWduIGEgcG9vbCBrZXJuZWwgd2l0aCBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHBvb2xLZXJuZWwgS2VybmVsIGZyb20gcG9vbFxuICAgKiBAcGFyYW0gbmV3SWQgTmV3IGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBVcGRhdGVkIGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZWFzc2lnblBvb2xLZXJuZWwoXG4gICAgcG9vbEtlcm5lbDogSUtlcm5lbEluc3RhbmNlLCBcbiAgICBuZXdJZDogc3RyaW5nLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogSUtlcm5lbEluc3RhbmNlIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2JqZWN0IGV4cGxpY2l0bHkgdG8gYXZvaWQgc3ByZWFkIG9wZXJhdG9yIGlzc3Vlc1xuICAgIGNvbnN0IHVwZGF0ZWRJbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlID0ge1xuICAgICAgaWQ6IG5ld0lkLFxuICAgICAga2VybmVsOiBwb29sS2VybmVsLmtlcm5lbCxcbiAgICAgIG1vZGU6IHBvb2xLZXJuZWwubW9kZSxcbiAgICAgIGxhbmd1YWdlOiBwb29sS2VybmVsLmxhbmd1YWdlLFxuICAgICAgd29ya2VyOiBwb29sS2VybmVsLndvcmtlcixcbiAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgLy8gVXBkYXRlIGNyZWF0aW9uIHRpbWVcbiAgICAgIG9wdGlvbnM6IHsgLi4ucG9vbEtlcm5lbC5vcHRpb25zLCAuLi5vcHRpb25zIH0sXG4gICAgICBpc0Zyb21Qb29sOiB0cnVlLFxuICAgICAgZGVzdHJveTogcG9vbEtlcm5lbC5kZXN0cm95IC8vIFByZXNlcnZlIHRoZSBvcmlnaW5hbCBkZXN0cm95IGZ1bmN0aW9uXG4gICAgfTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gaXMgcHJvcGVybHkgc2V0XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHByZXNlcnZlIGRlc3Ryb3kgZnVuY3Rpb24gZHVyaW5nIHBvb2wga2VybmVsIHJlYXNzaWdubWVudCcpO1xuICAgICAgY29uc29sZS5lcnJvcigncG9vbEtlcm5lbC5kZXN0cm95IHR5cGU6JywgdHlwZW9mIHBvb2xLZXJuZWwuZGVzdHJveSk7XG4gICAgICBjb25zb2xlLmVycm9yKCd1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSB0eXBlOicsIHR5cGVvZiB1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcmVzZXJ2ZSBkZXN0cm95IGZ1bmN0aW9uIGR1cmluZyBwb29sIGtlcm5lbCByZWFzc2lnbm1lbnRgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHVwZGF0ZWRJbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZy9tb25pdG9yaW5nXG4gICAqIEByZXR1cm5zIFBvb2wgc3RhdGlzdGljc1xuICAgKi9cbiAgcHVibGljIGdldFBvb2xTdGF0cygpOiBSZWNvcmQ8c3RyaW5nLCB7IGF2YWlsYWJsZTogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBzdGF0czogUmVjb3JkPHN0cmluZywgeyBhdmFpbGFibGU6IG51bWJlcjsgdG90YWw6IG51bWJlciB9PiA9IHt9O1xuICAgIFxuICAgIGZvciAoY29uc3QgW3Bvb2xLZXksIHByb21pc2VzXSBvZiB0aGlzLnBvb2wuZW50cmllcygpKSB7XG4gICAgICBzdGF0c1twb29sS2V5XSA9IHtcbiAgICAgICAgYXZhaWxhYmxlOiBwcm9taXNlcy5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiB0aGlzLnBvb2xDb25maWcucG9vbFNpemVcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMgUG9vbCBjb25maWd1cmF0aW9uIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBnZXRQb29sQ29uZmlnKCk6IHtcbiAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIHBvb2xTaXplOiBudW1iZXI7XG4gICAgYXV0b1JlZmlsbDogYm9vbGVhbjtcbiAgICBwcmVsb2FkQ29uZmlnczogQXJyYXk8e1xuICAgICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgICB9PjtcbiAgICBpc1ByZWxvYWRpbmc6IGJvb2xlYW47XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkOiB0aGlzLnBvb2xDb25maWcuZW5hYmxlZCxcbiAgICAgIHBvb2xTaXplOiB0aGlzLnBvb2xDb25maWcucG9vbFNpemUsXG4gICAgICBhdXRvUmVmaWxsOiB0aGlzLnBvb2xDb25maWcuYXV0b1JlZmlsbCxcbiAgICAgIHByZWxvYWRDb25maWdzOiBbLi4udGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzXSwgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IG1vZGlmaWNhdGlvblxuICAgICAgaXNQcmVsb2FkaW5nOiB0aGlzLmlzUHJlbG9hZGluZ1xuICAgIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgd29ya2VyIFVSTCBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm5zIFRoZSB3b3JrZXIgVVJMIG9yIHVuZGVmaW5lZCBpZiB1c2luZyBhdXRvLWRldGVjdGlvblxuICAgKi9cbiAgcHVibGljIGdldFdvcmtlclVybCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLndvcmtlclVybDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldCBhIGN1c3RvbSB3b3JrZXIgVVJMIGZvciBrZXJuZWwgd29ya2Vyc1xuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gdGhlIGtlcm5lbC53b3JrZXIuanMgZmlsZVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGb3IgQ0ROIHVzYWdlOlxuICAgKiBtYW5hZ2VyLnNldFdvcmtlclVybCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS93ZWItcHl0aG9uLWtlcm5lbEBsYXRlc3QvZGlzdC9rZXJuZWwud29ya2VyLmpzJyk7XG4gICAqIC8vIEZvciBsb2NhbCBkZXZlbG9wbWVudDpcbiAgICogbWFuYWdlci5zZXRXb3JrZXJVcmwoJy9kaXN0L2tlcm5lbC53b3JrZXIuanMnKTtcbiAgICovXG4gIHB1YmxpYyBzZXRXb3JrZXJVcmwodXJsOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICB0aGlzLndvcmtlclVybCA9IHVybDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBrZXJuZWwgaW5zdGFuY2VcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGtlcm5lbFxuICAgKiBAcGFyYW0gb3B0aW9ucy5pZCBPcHRpb25hbCBjdXN0b20gSUQgZm9yIHRoZSBrZXJuZWxcbiAgICogQHBhcmFtIG9wdGlvbnMubW9kZSBPcHRpb25hbCBrZXJuZWwgbW9kZSAobWFpbl90aHJlYWQgb3Igd29ya2VyKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5sYW5nIE9wdGlvbmFsIGtlcm5lbCBsYW5ndWFnZSAocHl0aG9uIG9yIHR5cGVzY3JpcHQpXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgcHJlZml4IGZvciB0aGUga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlbm8ucGVybWlzc2lvbnMgT3B0aW9uYWwgRGVubyBwZXJtaXNzaW9ucyBmb3Igd29ya2VyIG1vZGVcbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsZXN5c3RlbSBPcHRpb25hbCBmaWxlc3lzdGVtIG1vdW50aW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgT3B0aW9uYWwgdGltZW91dCBpbiBtcyBhZnRlciB3aGljaCBhbiBpbmFjdGl2ZSBrZXJuZWwgd2lsbCBiZSBzaHV0IGRvd25cbiAgICogQHBhcmFtIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSBPcHRpb25hbCBtYXhpbXVtIHRpbWUgaW4gbXMgYW4gZXhlY3V0aW9uIGNhbiBydW4gYmVmb3JlIGNvbnNpZGVyZWQgc3R1Y2tcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGtlcm5lbCBpbnN0YW5jZSBJRFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUtlcm5lbChvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMgPSB7fSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBvcHRpb25zLmlkIGRvZXMgbm90IGNvbnRhaW4gY29sb25zIGJlY2F1c2UgaXQgd2lsbCBiZSB1c2VkIGFzIGEgbmFtZXNwYWNlIHByZWZpeFxuICAgIGlmIChvcHRpb25zLmlkICYmIG9wdGlvbnMuaWQuaW5jbHVkZXMoJzonKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXJuZWwgSUQgY2Fubm90IGNvbnRhaW4gY29sb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VJZCA9IG9wdGlvbnMuaWQgfHwgY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlIHx8IEtlcm5lbE1vZGUuV09SS0VSO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gb3B0aW9ucy5sYW5nIHx8IEtlcm5lbExhbmd1YWdlLlBZVEhPTjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVxdWVzdGVkIGtlcm5lbCB0eXBlIGlzIGFsbG93ZWRcbiAgICBpZiAoIXRoaXMuaXNLZXJuZWxUeXBlQWxsb3dlZChtb2RlLCBsYW5ndWFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHR5cGUgJHttb2RlfS0ke2xhbmd1YWdlfSBpcyBub3QgYWxsb3dlZC4gQWxsb3dlZCB0eXBlczogJHtcbiAgICAgICAgdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMubWFwKHQgPT4gYCR7dC5tb2RlfS0ke3QubGFuZ3VhZ2V9YCkuam9pbignLCAnKVxuICAgICAgfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBcHBseSBuYW1lc3BhY2UgcHJlZml4IGlmIHByb3ZpZGVkXG4gICAgY29uc3QgaWQgPSBvcHRpb25zLm5hbWVzcGFjZSA/IGAke29wdGlvbnMubmFtZXNwYWNlfToke2Jhc2VJZH1gIDogYmFzZUlkO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGtlcm5lbCB3aXRoIHRoaXMgSUQgYWxyZWFkeSBleGlzdHNcbiAgICBpZiAodGhpcy5rZXJuZWxzLmhhcyhpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtpZH0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGdldCBmcm9tIHBvb2wgaWYgcG9zc2libGVcbiAgICBpZiAodGhpcy5jYW5Vc2VQb29sKG9wdGlvbnMpKSB7XG4gICAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBrZXJuZWwgdHlwZSBpcyBjb25maWd1cmVkIGZvciBwb29saW5nXG4gICAgICBjb25zdCBpc1Bvb2xlZFR5cGUgPSB0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3Muc29tZShjb25maWcgPT4gXG4gICAgICAgIGNvbmZpZy5tb2RlID09PSBtb2RlICYmIGNvbmZpZy5sYW5ndWFnZSA9PT0gbGFuZ3VhZ2VcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChpc1Bvb2xlZFR5cGUpIHtcbiAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCBmcm9tIGV4aXN0aW5nIHBvb2xcbiAgICAgICAgbGV0IHBvb2xLZXJuZWxQcm9taXNlID0gdGhpcy5nZXRGcm9tUG9vbChtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9vbEtlcm5lbFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShwb29sS2VybmVsUHJvbWlzZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQb29sIGlzIGVtcHR5LCBidXQgdGhpcyB0eXBlIHNob3VsZCBiZSBwb29sZWRcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHByb21pc2UgaW1tZWRpYXRlbHkgYW5kIHRyaWdnZXIgYmFja2dyb3VuZCByZWZpbGxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcga2VybmVsIHByb21pc2Ugc3BlY2lmaWNhbGx5IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICBjb25zdCBuZXdLZXJuZWxQcm9taXNlID0gdGhpcy5jcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJpZ2dlciBiYWNrZ3JvdW5kIHJlZmlsbCB0byByZXBsZW5pc2ggdGhlIHBvb2wgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgIGlmICh0aGlzLnBvb2xDb25maWcuYXV0b1JlZmlsbCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVmaWxsUG9vbChtb2RlLCBsYW5ndWFnZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlZmlsbGluZyBleGhhdXN0ZWQgcG9vbCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHVwUG9vbEtlcm5lbEZyb21Qcm9taXNlKG5ld0tlcm5lbFByb21pc2UsIGlkLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGtlcm5lbCBwcm9taXNlIGZvciBleGhhdXN0ZWQgcG9vbDogJHtlcnJvcn1gKTtcbiAgICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gb24tZGVtYW5kIGNyZWF0aW9uIGFzIGxhc3QgcmVzb3J0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMga2VybmVsIHR5cGUgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIHBvb2xpbmcsIHRyeSB0byBnZXQgZnJvbSBwb29sIGFueXdheVxuICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGFyZSBrZXJuZWxzIGF2YWlsYWJsZSBmcm9tIHByZXZpb3VzIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIGNvbnN0IHBvb2xLZXJuZWxQcm9taXNlID0gdGhpcy5nZXRGcm9tUG9vbChtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgIGlmIChwb29sS2VybmVsUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHVwUG9vbEtlcm5lbEZyb21Qcm9taXNlKHBvb2xLZXJuZWxQcm9taXNlLCBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbCBiYWNrIHRvIGNyZWF0aW5nIGEgbmV3IGtlcm5lbCBvbi1kZW1hbmRcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVPbkRlbWFuZEtlcm5lbChpZCwgbW9kZSwgbGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0dXAgYSBwb29sIGtlcm5lbCBmcm9tIGEgcHJvbWlzZSB3aXRoIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0gcG9vbEtlcm5lbFByb21pc2UgS2VybmVsIHByb21pc2UgZnJvbSBwb29sXG4gICAqIEBwYXJhbSBpZCBOZXcga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIEtlcm5lbCBJRCAocmV0dXJuZWQgYWZ0ZXIga2VybmVsIGlzIHJlYWR5KVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShcbiAgICBwb29sS2VybmVsUHJvbWlzZTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+LCBcbiAgICBpZDogc3RyaW5nLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvb2wga2VybmVsIHRvIGJlIHJlYWR5XG4gICAgICBjb25zdCBwb29sS2VybmVsID0gYXdhaXQgcG9vbEtlcm5lbFByb21pc2U7XG4gICAgICBcbiAgICAgIC8vIFJlYXNzaWduIHRoZSBwb29sIGtlcm5lbCB3aXRoIHRoZSBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5yZWFzc2lnblBvb2xLZXJuZWwocG9vbEtlcm5lbCwgaWQsIG9wdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBGb3Igd29ya2VyIGtlcm5lbHMsIHdlIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgbmV3IElEXG4gICAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgaW5zdGFuY2Uud29ya2VyKSB7XG4gICAgICAgIC8vIEdldCB0aGUgd29ya2VyIGFuZCBjcmVhdGUgbmV3IG1lc3NhZ2UgY2hhbm5lbFxuICAgICAgICBjb25zdCB3b3JrZXIgPSBpbnN0YW5jZS53b3JrZXI7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbWVzc2FnZSBjaGFubmVsIGZvciB0aGUgcmVhc3NpZ25lZCBrZXJuZWxcbiAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2VuZCB0aGUgbmV3IGV2ZW50IHBvcnQgdG8gdGhlIHdvcmtlclxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFwiU0VUX0VWRU5UX1BPUlRcIixcbiAgICAgICAgICBwb3J0OiBwb3J0MlxuICAgICAgICB9LCBbcG9ydDJdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBldmVudCBoYW5kbGVyIHdpdGggdGhlIGNvcnJlY3Qga2VybmVsIElEXG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBldmVudCBmcm9tIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICAgICAgICAvLyBUaGlzIHN0cnVjdHVyZSBtYXRjaGVzIHRoZSBzZXR1cEV2ZW50Rm9yd2FyZGluZyBtZXRob2QgZm9yIG1haW4gdGhyZWFkIGtlcm5lbHNcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoZXZlbnQuZGF0YS50eXBlLCB7XG4gICAgICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyBmcm9tIHRoZSB3b3JrZXIgd2l0aCB0aGUgbmV3IGhhbmRsZXJcbiAgICAgICAgcG9ydDEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIHBvcnQxLnN0YXJ0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gdG8gY2xlYW4gdXAgdGhlIG5ldyBldmVudCBoYW5kbGVyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICAgIHRoaXMua2VybmVscy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICAgIFxuICAgICAgLy8gRm9yd2FyZCBrZXJuZWwgZXZlbnRzIHRvIG1hbmFnZXIgKGZvciBtYWluIHRocmVhZCBrZXJuZWxzKVxuICAgICAgdGhpcy5zZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZSk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgYWN0aXZpdHkgdHJhY2tpbmdcbiAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgICAgXG4gICAgICAvLyBTZXQgdXAgaW5hY3Rpdml0eSB0aW1lb3V0IGlmIHNwZWNpZmllZCBhbmQgZ3JlYXRlciB0aGFuIDBcbiAgICAgIGlmIChvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ICYmIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldHVwIGhhbmRsZXJzIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnMgaWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzcGVjaWZpZWRcbiAgICAgIGlmIChvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgJiYgb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lID4gMCkge1xuICAgICAgICB0aGlzLnNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNldHRpbmcgdXAgcG9vbCBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgLy8gRW1pdCBhbiBlcnJvciBldmVudCBmb3IgdGhpcyBrZXJuZWxcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiS2VybmVsU2V0dXBFcnJvclwiLFxuICAgICAgICAgIGV2YWx1ZTogYEZhaWxlZCB0byBzZXR1cCBrZXJuZWw6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IChlcnJvci5zdGFjayB8fCBlcnJvci5tZXNzYWdlKSA6IFN0cmluZyhlcnJvcildXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhIHBvb2wga2VybmVsIHdpdGggbmV3IElEIGFuZCBvcHRpb25zIChmb3IgYWxyZWFkeSByZXNvbHZlZCBrZXJuZWxzKVxuICAgKiBAcGFyYW0gcG9vbEtlcm5lbCBLZXJuZWwgZnJvbSBwb29sXG4gICAqIEBwYXJhbSBpZCBOZXcga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFBvb2xLZXJuZWwoXG4gICAgcG9vbEtlcm5lbDogSUtlcm5lbEluc3RhbmNlLCBcbiAgICBpZDogc3RyaW5nLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogc3RyaW5nIHtcbiAgICAvLyBSZWFzc2lnbiB0aGUgcG9vbCBrZXJuZWwgd2l0aCB0aGUgbmV3IElEIGFuZCBvcHRpb25zXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnJlYXNzaWduUG9vbEtlcm5lbChwb29sS2VybmVsLCBpZCwgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gRm9yIHdvcmtlciBrZXJuZWxzLCB3ZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIG5ldyBJRFxuICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiBpbnN0YW5jZS53b3JrZXIpIHtcbiAgICAgIC8vIEdldCB0aGUgd29ya2VyIGFuZCBjcmVhdGUgbmV3IG1lc3NhZ2UgY2hhbm5lbFxuICAgICAgY29uc3Qgd29ya2VyID0gaW5zdGFuY2Uud29ya2VyO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbWVzc2FnZSBjaGFubmVsIGZvciB0aGUgcmVhc3NpZ25lZCBrZXJuZWxcbiAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgbmV3IGV2ZW50IHBvcnQgdG8gdGhlIHdvcmtlclxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJTRVRfRVZFTlRfUE9SVFwiLFxuICAgICAgICBwb3J0OiBwb3J0MlxuICAgICAgfSwgW3BvcnQyXSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBldmVudCBoYW5kbGVyIHdpdGggdGhlIGNvcnJlY3Qga2VybmVsIElEXG4gICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUpIHtcbiAgICAgICAgICAvLyBFbWl0IHRoZSBldmVudCBmcm9tIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICAgICAgLy8gVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGUgc2V0dXBFdmVudEZvcndhcmRpbmcgbWV0aG9kIGZvciBtYWluIHRocmVhZCBrZXJuZWxzXG4gICAgICAgICAgc3VwZXIuZW1pdChldmVudC5kYXRhLnR5cGUsIHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyBmcm9tIHRoZSB3b3JrZXIgd2l0aCB0aGUgbmV3IGhhbmRsZXJcbiAgICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgcG9ydDEuc3RhcnQoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBkZXN0cm95IGZ1bmN0aW9uIHRvIGNsZWFuIHVwIHRoZSBuZXcgZXZlbnQgaGFuZGxlclxuICAgICAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcbiAgICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBTdG9yZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgdGhpcy5rZXJuZWxzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIEZvcndhcmQga2VybmVsIGV2ZW50cyB0byBtYW5hZ2VyIChmb3IgbWFpbiB0aHJlYWQga2VybmVscylcbiAgICB0aGlzLnNldHVwRXZlbnRGb3J3YXJkaW5nKGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGluYWN0aXZpdHkgdGltZW91dCBpZiBzcGVjaWZpZWQgYW5kIGdyZWF0ZXIgdGhhbiAwXG4gICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgJiYgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldHVwIGhhbmRsZXJzIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnMgaWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBTdGFsbGVkRXhlY3V0aW9uSGFuZGxlcihpZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBvbi1kZW1hbmQgKG5vdCBmcm9tIHBvb2wpXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlT25EZW1hbmRLZXJuZWwoXG4gICAgaWQ6IHN0cmluZywgXG4gICAgbW9kZTogS2VybmVsTW9kZSwgXG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBTdG9yZSBvcHRpb25zIHRlbXBvcmFyaWx5IHRvIGJlIHVzZWQgaW4gY3JlYXRlV29ya2VyS2VybmVsXG4gICAgY29uc3QgdGVtcEluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvcHRpb25zOiB7IC4uLm9wdGlvbnMsIGxhbmc6IGxhbmd1YWdlIH0sXG4gICAgICBtb2RlLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuICAgIHRoaXMua2VybmVscy5zZXQoaWQsIHRlbXBJbnN0YW5jZSBhcyB1bmtub3duIGFzIElLZXJuZWxJbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBhcHByb3ByaWF0ZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBsZXQgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZTtcbiAgICBcbiAgICBpZiAobW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZU1haW5UaHJlYWRLZXJuZWwoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuY3JlYXRlV29ya2VyS2VybmVsKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIHRoaXMua2VybmVscy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBGb3J3YXJkIGtlcm5lbCBldmVudHMgdG8gbWFuYWdlclxuICAgIHRoaXMuc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYWN0aXZpdHkgdHJhY2tpbmdcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkKTtcbiAgICBcbiAgICAvLyBTZXQgdXAgaW5hY3Rpdml0eSB0aW1lb3V0IGlmIHNwZWNpZmllZCBhbmQgZ3JlYXRlciB0aGFuIDBcbiAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAmJiBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0dXAgaGFuZGxlcnMgZm9yIHN0YWxsZWQgZXhlY3V0aW9ucyBpZiBtYXhFeGVjdXRpb25UaW1lIGlzIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgJiYgb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lID4gMCkge1xuICAgICAgdGhpcy5zZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIGluc3RhbmNlIHJ1bm5pbmcgaW4gdGhlIG1haW4gdGhyZWFkXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZU1haW5UaHJlYWRLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgLy8gR2V0IG9wdGlvbnMgZnJvbSB0aGUgdGVtcG9yYXJ5IGluc3RhbmNlXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMua2VybmVscy5nZXQoaWQpPy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxhbmd1YWdlID0gb3B0aW9ucy5sYW5nIHx8IEtlcm5lbExhbmd1YWdlLlBZVEhPTjtcbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIFB5dGhvbiBrZXJuZWxcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgS2VybmVsKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBjb25zdCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBrZXJuZWwsXG4gICAgICBtb2RlOiBLZXJuZWxNb2RlLk1BSU5fVEhSRUFELFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBjcmVhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVzdHJveTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBOb3RoaW5nIHNwZWNpYWwgdG8gZG8gZm9yIG1haW4gdGhyZWFkIGtlcm5lbFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBmaWxlc3lzdGVtIG9wdGlvbnNcbiAgICBjb25zdCBrZXJuZWxPcHRpb25zOiBJS2VybmVsT3B0aW9ucyA9IHt9O1xuXG4gICAgLy8gQWRkIGZpbGVzeXN0ZW0gb3B0aW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmZpbGVzeXN0ZW0pIHtcbiAgICAgIGtlcm5lbE9wdGlvbnMuZmlsZXN5c3RlbSA9IG9wdGlvbnMuZmlsZXN5c3RlbTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnMuZW52KSB7XG4gICAgICBrZXJuZWxPcHRpb25zLmVudiA9IG9wdGlvbnMuZW52O1xuICAgIH1cblxuICAgIC8vIEFkZCBsb2NrRmlsZVVSTCBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmxvY2tGaWxlVVJMKSB7XG4gICAgICBrZXJuZWxPcHRpb25zLmxvY2tGaWxlVVJMID0gb3B0aW9ucy5sb2NrRmlsZVVSTDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYXV0b1N5bmNGcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmF1dG9TeW5jRnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2VybmVsT3B0aW9ucy5hdXRvU3luY0ZzID0gb3B0aW9ucy5hdXRvU3luY0ZzO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbFxuICAgIGF3YWl0IGtlcm5lbC5pbml0aWFsaXplKGtlcm5lbE9wdGlvbnMpO1xuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBpbnN0YW5jZSBydW5uaW5nIGluIGEgd29ya2VyXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVdvcmtlcktlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHtcbiAgICAvLyBHZXQgcGVybWlzc2lvbnMgZnJvbSBvcHRpb25zIHdoZW4gY3JlYXRpbmcgdGhlIGtlcm5lbFxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKT8ub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZyB8fCBLZXJuZWxMYW5ndWFnZS5QWVRIT047XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHdvcmtlciB3aXRoIG9wdGlvbmFsIHBlcm1pc3Npb25zXG4gICAgY29uc3Qgd29ya2VyT3B0aW9uczogV29ya2VyT3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgfTtcbiAgICBcbiAgICAvLyBJZiBEZW5vIHBlcm1pc3Npb25zIGFyZSBwcm92aWRlZCwgdXNlIHRoZW0uXG4gICAgLy8gT3RoZXJ3aXNlIGRvbid0IHNwZWNpZnkgRGVubyBwZXJtaXNzaW9ucyBhdCBhbGwgdG8gaW5oZXJpdCBmcm9tIGhvc3Qgc2NyaXB0XG4gICAgaWYgKG9wdGlvbnMuZGVubz8ucGVybWlzc2lvbnMpIHtcbiAgICAgIHdvcmtlck9wdGlvbnMuZGVubyA9IHtcbiAgICAgICAgcGVybWlzc2lvbnM6IG9wdGlvbnMuZGVuby5wZXJtaXNzaW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB3b3JrZXIgVVJMIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudFxuICAgIGNvbnN0IHdvcmtlclVybCA9IHRoaXMucmVzb2x2ZVdvcmtlclVybCgpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsLCB7IHR5cGU6ICdjbGFzc2ljJyB9KTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBtZXNzYWdlIGNoYW5uZWwgZm9yIGV2ZW50c1xuICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIGtlcm5lbCBpcyBpbml0aWFsaXplZFxuICAgIGNvbnN0IGluaXRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW5pdEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJLRVJORUxfSU5JVElBTElaRURcIikge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhLmRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJLZXJuZWwgaW5pdGlhbGl6YXRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdEhhbmRsZXIpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNlbmQgdGhlIHBvcnQgdG8gdGhlIHdvcmtlclxuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiU0VUX0VWRU5UX1BPUlRcIiwgcG9ydDogcG9ydDIgfSwgW3BvcnQyXSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcHJveHkgdG8gdGhlIHdvcmtlciB1c2luZyBDb21saW5rXG4gICAgY29uc3Qga2VybmVsUHJveHkgPSBDb21saW5rLndyYXA8SUtlcm5lbD4od29ya2VyKTtcbiAgICBcbiAgICAvLyBBZGQgYSBsb2NhbCBldmVudCBoYW5kbGVyIHRvIGJyaWRnZSB0aGUgd29ya2VyIGV2ZW50c1xuICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIHRoZSBsaW1pdGF0aW9uIHRoYXQgQ29tbGluayBkb2Vzbid0IHByb3h5IGV2ZW50IGVtaXR0ZXJzXG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICAvLyBFbWl0IHRoZSBldmVudCBmcm9tIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICAgIC8vIFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhlIHNldHVwRXZlbnRGb3J3YXJkaW5nIG1ldGhvZCBmb3IgbWFpbiB0aHJlYWQga2VybmVsc1xuICAgICAgICBzdXBlci5lbWl0KGV2ZW50LmRhdGEudHlwZSwge1xuICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyBmcm9tIHRoZSB3b3JrZXJcbiAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICBwb3J0MS5zdGFydCgpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIGZpbGVzeXN0ZW0gb3B0aW9uc1xuICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRvIHRoZSB3b3JrZXJcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJJTklUSUFMSVpFX0tFUk5FTFwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBmaWxlc3lzdGVtOiBvcHRpb25zLmZpbGVzeXN0ZW0sXG4gICAgICAgIGVudjogb3B0aW9ucy5lbnYsXG4gICAgICAgIGxvY2tGaWxlVVJMOiBvcHRpb25zLmxvY2tGaWxlVVJMLFxuICAgICAgICBhdXRvU3luY0ZzOiBvcHRpb25zLmF1dG9TeW5jRnMsXG4gICAgICAgIGxhbmc6IGxhbmd1YWdlXG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gV2FpdCBmb3Iga2VybmVsIGluaXRpYWxpemF0aW9uXG4gICAgYXdhaXQgaW5pdFByb21pc2U7XG4gICAgXG4gICAgLy8gU2V0IHVwIGludGVycnVwdCBidWZmZXIgYXV0b21hdGljYWxseSBmb3Igd29ya2VyIGtlcm5lbHNcbiAgICBhd2FpdCB0aGlzLnNldHVwV29ya2VySW50ZXJydXB0QnVmZmVyKGlkLCB3b3JrZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAga2VybmVsOiB7XG4gICAgICAgIC8vIE1hcCBtZXRob2RzIGZyb20gdGhlIENvbWxpbmsgcHJveHkgdG8gdGhlIElLZXJuZWwgaW50ZXJmYWNlXG4gICAgICAgIGluaXRpYWxpemU6IGFzeW5jIChvcHRpb25zPzogSUtlcm5lbE9wdGlvbnMpID0+IHtcbiAgICAgICAgICByZXR1cm4ga2VybmVsUHJveHkuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhlY3V0ZTogYXN5bmMgKGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsUHJveHkuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSBQeXRob24gd29ya2VyIHJlc3VsdHMgKG5vIHNwZWNpYWwgZGlzcGxheSByZWNvbnN0cnVjdGlvbiBuZWVkZWQpXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNJbml0aWFsaXplZDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWxQcm94eS5pc0luaXRpYWxpemVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0UmVwbHk6IGFzeW5jIChjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWxQcm94eS5pbnB1dFJlcGx5KGNvbnRlbnQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgYXN5bmMgZ2V0U3RhdHVzIG1ldGhvZFxuICAgICAgICBnZXRTdGF0dXM6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5nZXRTdGF0dXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmdldFN0YXR1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgY29tcGxldGlvbiBtZXRob2RzXG4gICAgICAgIGNvbXBsZXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogJ0NvbXBsZXRpb24gbm90IHN1cHBvcnRlZCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5zcGVjdDogYXN5bmMgKGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCwgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6ICdJbnNwZWN0aW9uIG5vdCBzdXBwb3J0ZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzQ29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmlzQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmlzQ29tcGxldGUoY29kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ3Vua25vd24nIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBpbnRlcnJ1cHQgbWV0aG9kc1xuICAgICAgICBpbnRlcnJ1cHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5pbnRlcnJ1cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmludGVycnVwdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRJbnRlcnJ1cHRCdWZmZXI6IChidWZmZXI6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5zZXRJbnRlcnJ1cHRCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAga2VybmVsUHJveHkuc2V0SW50ZXJydXB0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNldCBpbnRlcnJ1cHQgYnVmZmVyOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBtb3VudEZTIG1ldGhvZFxuICAgICAgICBtb3VudEZTOiBhc3luYyAobW91bnRQYXRoOiBzdHJpbmcsIGRpckhhbmRsZT86IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfCBudWxsLCBwZXJtaXNzaW9uPzogJ3JlYWQnIHwgJ3JlYWR3cml0ZScpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5tb3VudEZTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5tb3VudEZTKG1vdW50UGF0aCwgZGlySGFuZGxlLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW91bnRGUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMga2VybmVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGZpbGVzeXN0ZW0gc3luYyBtZXRob2RzXG4gICAgICAgIGdldE1vdW50ZWRGaWxlU3lzdGVtczogKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmdldE1vdW50ZWRGaWxlU3lzdGVtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4ga2VybmVsUHJveHkuZ2V0TW91bnRlZEZpbGVTeXN0ZW1zKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBtb3VudGVkIGZpbGVzeXN0ZW1zOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN5bmNGaWxlU3lzdGVtOiBhc3luYyAobW91bnRQYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5zeW5jRmlsZVN5c3RlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuc3luY0ZpbGVTeXN0ZW0obW91bnRQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ3N5bmNGaWxlU3lzdGVtIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWwnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb246IGFzeW5jIChtb3VudFBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LnVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkudXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uKG1vdW50UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICd1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGtlcm5lbCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBjb21tIG1ldGhvZHNcbiAgICAgICAgY29tbUluZm86IGFzeW5jICh0YXJnZXRfbmFtZTogc3RyaW5nIHwgbnVsbCwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tbUluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbW1JbmZvKHRhcmdldF9uYW1lLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgY29tbXM6IHt9LCBzdGF0dXM6ICdvaycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tbXM6IHt9LCBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21tT3BlbjogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tbU9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbW1PcGVuKGNvbnRlbnQsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIG9wZW4gY29tbTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21tTXNnOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tTXNnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21tTXNnKGNvbnRlbnQsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNlbmQgY29tbSBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1DbG9zZTogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tbUNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21tQ2xvc2UoY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY2xvc2UgY29tbTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgSUtlcm5lbCxcbiAgICAgIG1vZGU6IEtlcm5lbE1vZGUuV09SS0VSLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICB3b3JrZXIsXG4gICAgICBjcmVhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBvcHRpb25zLCAvLyBTdG9yZSB0aGUgb3B0aW9ucyBmb3IgcmVmZXJlbmNlXG4gICAgICBkZXN0cm95OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSB3b3JrZXIgYW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXR1cCBldmVudCBmb3J3YXJkaW5nIGZyb20ga2VybmVsIHRvIG1hbmFnZXJcbiAgICogQHBhcmFtIGluc3RhbmNlIEtlcm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlKTogdm9pZCB7XG4gICAgLy8gT25seSBuZWVkZWQgZm9yIG1haW4gdGhyZWFkIGtlcm5lbHMgYXMgd29ya2VyIGV2ZW50cyBhcmUgaGFuZGxlZCBkaXJlY3RseVxuICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLk1BSU5fVEhSRUFEKSB7XG4gICAgICAvLyBGb3J3YXJkIGFsbCBrZXJuZWwgZXZlbnRzIHRvIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICBPYmplY3QudmFsdWVzKEtlcm5lbEV2ZW50cykuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgICAgIC8vIEFjY2VzcyB0aGUga2VybmVsIGFzIGEgS2VybmVsIGluc3RhbmNlIHdoaWNoIGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gICAgICAgIGNvbnN0IGtlcm5lbEVtaXR0ZXIgPSBpbnN0YW5jZS5rZXJuZWwgYXMgdW5rbm93biBhcyBFdmVudEVtaXR0ZXI7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gZm9yd2FyZCBldmVudHNcbiAgICAgICAga2VybmVsRW1pdHRlci5vbihldmVudFR5cGUsIChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICBzdXBlci5lbWl0KGV2ZW50VHlwZSwge1xuICAgICAgICAgICAga2VybmVsSWQ6IGluc3RhbmNlLmlkLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGtlcm5lbCBpbnN0YW5jZSBieSBJRFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgZ2V0S2VybmVsKGlkOiBzdHJpbmcpOiBJS2VybmVsSW5zdGFuY2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgYWxsIGtlcm5lbCBJRHNcbiAgICogQHJldHVybnMgQXJyYXkgb2Yga2VybmVsIElEc1xuICAgKi9cbiAgcHVibGljIGdldEtlcm5lbElkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXJuZWxzLmtleXMoKSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBrZXJuZWxzIHdpdGggdGhlaXIgZGV0YWlsc1xuICAgKiBAcGFyYW0gbmFtZXNwYWNlIE9wdGlvbmFsIG5hbWVzcGFjZSB0byBmaWx0ZXIga2VybmVscyBieVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXJuZWwgaW5mb3JtYXRpb24gb2JqZWN0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RLZXJuZWxzKG5hbWVzcGFjZT86IHN0cmluZyk6IFByb21pc2U8QXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gICAgc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIjtcbiAgICBjcmVhdGVkOiBzdHJpbmc7XG4gICAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICAgIGRlbm8/OiB7XG4gICAgICBwZXJtaXNzaW9ucz86IElEZW5vUGVybWlzc2lvbnM7XG4gICAgfTtcbiAgfT4+IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZEtlcm5lbHMgPSBBcnJheS5mcm9tKHRoaXMua2VybmVscy5lbnRyaWVzKCkpXG4gICAgICAgIC5maWx0ZXIoKFtpZF0pID0+IHtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBvb2wga2VybmVscyAodGVtcG9yYXJ5IGtlcm5lbHMgd2l0aCBJRHMgc3RhcnRpbmcgd2l0aCBcInBvb2wtXCIpXG4gICAgICAgICAgaWYgKGlkLnN0YXJ0c1dpdGgoXCJwb29sLVwiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghbmFtZXNwYWNlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgJHtuYW1lc3BhY2V9OmApO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gVXNlIFByb21pc2UuYWxsIHRvIGdldCBhbGwgc3RhdHVzZXMgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBrZXJuZWxJbmZvcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBmaWx0ZXJlZEtlcm5lbHMubWFwKGFzeW5jIChbaWQsIGluc3RhbmNlXSkgPT4ge1xuICAgICAgICAgIC8vIEV4dHJhY3QgbmFtZXNwYWNlIGZyb20gaWQgaWYgcHJlc2VudFxuICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZU1hdGNoID0gaWQubWF0Y2goL14oW146XSspOi8pO1xuICAgICAgICAgIGNvbnN0IGV4dHJhY3RlZE5hbWVzcGFjZSA9IG5hbWVzcGFjZU1hdGNoID8gbmFtZXNwYWNlTWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHN0YXR1cyB1c2luZyBhc3luYyBnZXRTdGF0dXMgbWV0aG9kXG4gICAgICAgICAgbGV0IHN0YXR1czogXCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCIgPSBcInVua25vd25cIjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmtlcm5lbCAmJiB0eXBlb2YgaW5zdGFuY2Uua2VybmVsLmdldFN0YXR1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzdGF0dXMgPSBhd2FpdCBpbnN0YW5jZS5rZXJuZWwuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgZ2V0dGluZyBzdGF0dXMgZm9yIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICBzdGF0dXMgPSBcInVua25vd25cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbW9kZTogaW5zdGFuY2UubW9kZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBpbnN0YW5jZS5sYW5ndWFnZSxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIGNyZWF0ZWQ6IGluc3RhbmNlLmNyZWF0ZWQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBleHRyYWN0ZWROYW1lc3BhY2UsXG4gICAgICAgICAgICBkZW5vOiBpbnN0YW5jZS5vcHRpb25zPy5kZW5vXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBrZXJuZWxJbmZvcztcbiAgfVxuICBcbiAgLyoqXG4gICAqIERlc3Ryb3kgYSBrZXJuZWwgaW5zdGFuY2VcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIGtlcm5lbCBpcyBkZXN0cm95ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95S2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIC8vIEhhbmRsZSBncmFjZWZ1bGx5IC0ga2VybmVsIG1heSBhbHJlYWR5IGJlIGRlc3Ryb3llZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gZXhpc3RzXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCAke2lkfSBpcyBtaXNzaW5nIGRlc3Ryb3kgZnVuY3Rpb24gKHR5cGU6ICR7dHlwZW9mIGluc3RhbmNlLmRlc3Ryb3l9KWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBYm9ydCBhbGwgb25nb2luZyBvcGVyYXRpb25zIGZvciB0aGlzIGtlcm5lbCBmaXJzdFxuICAgIHRoaXMuYWJvcnRBbGxLZXJuZWxPcGVyYXRpb25zKGlkKTtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgaW5hY3Rpdml0eSB0aW1lclxuICAgIHRoaXMuY2xlYXJJbmFjdGl2aXR5VGltZW91dChpZCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIHRpbWVvdXRzXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZW91dHMuaGFzKGlkKSkge1xuICAgICAgY29uc3QgdGltZW91dHMgPSB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmdldChpZCkhO1xuICAgICAgZm9yIChjb25zdCB0aW1lb3V0SWQgb2YgdGltZW91dHMudmFsdWVzKCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiBzdGFydCB0aW1lc1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiBtZXRhZGF0YVxuICAgIGlmICh0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgaW50ZXJydXB0IGJ1ZmZlcnNcbiAgICBpZiAodGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuaW50ZXJydXB0QnVmZmVycy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBvbmdvaW5nIGV4ZWN1dGlvbnMgdHJhY2tpbmdcbiAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmRlbGV0ZShpZCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgYWN0aXZpdHkgdHJhY2tpbmdcbiAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuZGVsZXRlKGlkKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhpcyBrZXJuZWxcbiAgICB0aGlzLnJlbW92ZUFsbEtlcm5lbExpc3RlbmVycyhpZCk7XG4gICAgXG4gICAgLy8gRGVzdHJveSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgYXdhaXQgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSB0aGUga2VybmVsIGZyb20gdGhlIG1hcFxuICAgIHRoaXMua2VybmVscy5kZWxldGUoaWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogRGVzdHJveSBhbGwga2VybmVsIGluc3RhbmNlc1xuICAgKiBAcGFyYW0gbmFtZXNwYWNlIE9wdGlvbmFsIG5hbWVzcGFjZSB0byBmaWx0ZXIga2VybmVscyB0byBkZXN0cm95XG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWxsIGtlcm5lbHMgYXJlIGRlc3Ryb3llZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3lBbGwobmFtZXNwYWNlPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaWRzID0gQXJyYXkuZnJvbSh0aGlzLmtlcm5lbHMua2V5cygpKVxuICAgICAgLmZpbHRlcihpZCA9PiB7XG4gICAgICAgIGlmICghbmFtZXNwYWNlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYCR7bmFtZXNwYWNlfTpgKTtcbiAgICAgIH0pO1xuICAgIFxuICAgIC8vIERlc3Ryb3kgYWxsIGtlcm5lbHMsIGJ1dCBza2lwIGluY29tcGxldGUgaW5zdGFuY2VzXG4gICAgY29uc3QgZGVzdHJveVByb21pc2VzID0gaWRzLm1hcChhc3luYyAoaWQpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgICBpZiAoIWluc3RhbmNlIHx8IHR5cGVvZiBpbnN0YW5jZS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgaW5jb21wbGV0ZSBrZXJuZWwgaW5zdGFuY2UgJHtpZH0gZHVyaW5nIGRlc3Ryb3lBbGxgKTtcbiAgICAgICAgLy8gSnVzdCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwXG4gICAgICAgIHRoaXMua2VybmVscy5kZWxldGUoaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95S2VybmVsKGlkKTtcbiAgICB9KTtcbiAgICBcbiAgICBhd2FpdCBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpO1xuICAgIFxuICAgIC8vIElmIG5vIG5hbWVzcGFjZSBzcGVjaWZpZWQsIGFsc28gY2xlYW4gdXAgdGhlIHBvb2xcbiAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgYXdhaXQgdGhpcy5kZXN0cm95UG9vbCgpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIERlc3Ryb3kgYWxsIGtlcm5lbHMgaW4gdGhlIHBvb2xcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZGVzdHJveVBvb2woKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgXG4gICAgY29uc3QgZGVzdHJveVByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtwb29sS2V5LCBwcm9taXNlc10gb2YgdGhpcy5wb29sLmVudHJpZXMoKSkge1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGtlcm5lbFByb21pc2Ugb2YgcHJvbWlzZXMpIHtcbiAgICAgICAgLy8gSGFuZGxlIGVhY2ggcHJvbWlzZSAtIGlmIGl0IHJlc29sdmVzLCBkZXN0cm95IHRoZSBrZXJuZWxcbiAgICAgICAgY29uc3QgZGVzdHJveVByb21pc2UgPSBrZXJuZWxQcm9taXNlLnRoZW4oa2VybmVsID0+IHtcbiAgICAgICAgICByZXR1cm4ga2VybmVsLmRlc3Ryb3koKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgcG9vbCBrZXJuZWwgZnJvbSBwcm9taXNlOmAsIGVycm9yKTtcbiAgICAgICAgICAvLyBEb24ndCByZS10aHJvdyB0byBhdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGRlc3Ryb3lQcm9taXNlcy5wdXNoKGRlc3Ryb3lQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gV2FpdCBmb3IgYWxsIHBvb2wga2VybmVscyB0byBiZSBkZXN0cm95ZWRcbiAgICBhd2FpdCBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpO1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBwb29sIGFuZCBwcmVmaWxsaW5nIGZsYWdzXG4gICAgdGhpcy5wb29sLmNsZWFyKCk7XG4gICAgdGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5jbGVhcigpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWMga2VybmVsJ3MgZXZlbnRzXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV2ZW50VHlwZSBFdmVudCB0eXBlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBFdmVudCBsaXN0ZW5lclxuICAgKi9cbiAgcHVibGljIG9uS2VybmVsRXZlbnQoa2VybmVsSWQ6IHN0cmluZywgZXZlbnRUeXBlOiBLZXJuZWxFdmVudHMsIGxpc3RlbmVyOiAoZGF0YTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYga2VybmVsIGV4aXN0c1xuICAgIGlmICghdGhpcy5rZXJuZWxzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtrZXJuZWxJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSB3cmFwcGVyIHRoYXQgZmlsdGVycyBldmVudHMgZm9yIHRoaXMgc3BlY2lmaWMga2VybmVsXG4gICAgY29uc3Qgd3JhcHBlcjogTGlzdGVuZXJXcmFwcGVyID0ge1xuICAgICAgb3JpZ2luYWw6IGxpc3RlbmVyLFxuICAgICAgd3JhcHBlZDogKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0ga2VybmVsSWQpIHtcbiAgICAgICAgICAvLyBQYXNzIGp1c3QgdGhlIGRhdGEgdG8gdGhlIGxpc3RlbmVyXG4gICAgICAgICAgLy8gVGhlIGRhdGEgc3RydWN0dXJlIGlzIGNvbnNpc3RlbnQgYWNyb3NzIG1haW4gdGhyZWFkIGFuZCB3b3JrZXIgbW9kZXNcbiAgICAgICAgICBsaXN0ZW5lcihldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIHdyYXBwZXIgZm9yIGxhdGVyIHJlbW92YWxcbiAgICB0aGlzLnN0b3JlTGlzdGVuZXIoa2VybmVsSWQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHdyYXBwZXIpO1xuICAgIFxuICAgIC8vIEFkZCB0aGUgd3JhcHBlZCBsaXN0ZW5lciB0byB0aGUgbWFuYWdlclxuICAgIHN1cGVyLm9uKGV2ZW50VHlwZSwgd3JhcHBlci53cmFwcGVkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpYyBrZXJuZWxcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIEV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGxpc3RlbmVyIEV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICBwdWJsaWMgb2ZmS2VybmVsRXZlbnQoa2VybmVsSWQ6IHN0cmluZywgZXZlbnRUeXBlOiBLZXJuZWxFdmVudHMsIGxpc3RlbmVyOiAoZGF0YTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuZ2V0TGlzdGVuZXIoa2VybmVsSWQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIFxuICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHdyYXBwZWQgbGlzdGVuZXIgZnJvbSB0aGUgbWFuYWdlclxuICAgICAgc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwcGVyLndyYXBwZWQpO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgdGhlIHdyYXBwZXIgZnJvbSBvdXIgdHJhY2tpbmcgbWFwXG4gICAgICB0aGlzLnJlbW92ZVN0b3JlZExpc3RlbmVyKGtlcm5lbElkLCBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTdG9yZSBhIGxpc3RlbmVyIHdyYXBwZXIgZm9yIGxhdGVyIHJlbW92YWxcbiAgICovXG4gIHByaXZhdGUgc3RvcmVMaXN0ZW5lcihcbiAgICBrZXJuZWxJZDogc3RyaW5nLCBcbiAgICBldmVudFR5cGU6IHN0cmluZywgXG4gICAgb3JpZ2luYWw6IEZ1bmN0aW9uLCBcbiAgICB3cmFwcGVyOiBMaXN0ZW5lcldyYXBwZXJcbiAgKTogdm9pZCB7XG4gICAgLy8gR2V0IG9yIGNyZWF0ZSBrZXJuZWwgbWFwXG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyV3JhcHBlcnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5saXN0ZW5lcldyYXBwZXJzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsTWFwID0gdGhpcy5saXN0ZW5lcldyYXBwZXJzLmdldChrZXJuZWxJZCkhO1xuICAgIFxuICAgIC8vIEdldCBvciBjcmVhdGUgZXZlbnQgdHlwZSBtYXBcbiAgICBpZiAoIWtlcm5lbE1hcC5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAga2VybmVsTWFwLnNldChldmVudFR5cGUsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TWFwID0ga2VybmVsTWFwLmdldChldmVudFR5cGUpITtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgd3JhcHBlclxuICAgIGV2ZW50TWFwLnNldChvcmlnaW5hbCwgd3JhcHBlcik7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzdG9yZWQgbGlzdGVuZXIgd3JhcHBlclxuICAgKi9cbiAgcHJpdmF0ZSBnZXRMaXN0ZW5lcihcbiAgICBrZXJuZWxJZDogc3RyaW5nLCBcbiAgICBldmVudFR5cGU6IHN0cmluZywgXG4gICAgb3JpZ2luYWw6IEZ1bmN0aW9uXG4gICk6IExpc3RlbmVyV3JhcHBlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qga2VybmVsTWFwID0gdGhpcy5saXN0ZW5lcldyYXBwZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxNYXApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgZXZlbnRNYXAgPSBrZXJuZWxNYXAuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKCFldmVudE1hcCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICByZXR1cm4gZXZlbnRNYXAuZ2V0KG9yaWdpbmFsKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlbW92ZSBhIHN0b3JlZCBsaXN0ZW5lciB3cmFwcGVyXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVN0b3JlZExpc3RlbmVyKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLCBcbiAgICBvcmlnaW5hbDogRnVuY3Rpb25cbiAgKTogdm9pZCB7XG4gICAgY29uc3Qga2VybmVsTWFwID0gdGhpcy5saXN0ZW5lcldyYXBwZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxNYXApIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBldmVudE1hcCA9IGtlcm5lbE1hcC5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV2ZW50TWFwKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgIGV2ZW50TWFwLmRlbGV0ZShvcmlnaW5hbCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZW1wdHkgbWFwc1xuICAgIGlmIChldmVudE1hcC5zaXplID09PSAwKSB7XG4gICAgICBrZXJuZWxNYXAuZGVsZXRlKGV2ZW50VHlwZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChrZXJuZWxNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5saXN0ZW5lcldyYXBwZXJzLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMga2VybmVsXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZUFsbEtlcm5lbExpc3RlbmVycyhrZXJuZWxJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qga2VybmVsTWFwID0gdGhpcy5saXN0ZW5lcldyYXBwZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxNYXApIHJldHVybjtcbiAgICBcbiAgICAvLyBGb3IgZWFjaCBldmVudCB0eXBlXG4gICAgZm9yIChjb25zdCBbZXZlbnRUeXBlLCBldmVudE1hcF0gb2Yga2VybmVsTWFwLmVudHJpZXMoKSkge1xuICAgICAgLy8gRm9yIGVhY2ggb3JpZ2luYWwgbGlzdGVuZXJcbiAgICAgIGZvciAoY29uc3Qgd3JhcHBlciBvZiBldmVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHdyYXBwZWQgbGlzdGVuZXIgZnJvbSB0aGUgbWFuYWdlclxuICAgICAgICBzdXBlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIHdyYXBwZXIud3JhcHBlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIHRoZSBrZXJuZWwncyBsaXN0ZW5lciBtYXBcbiAgICB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGtlcm5lbCBhbmQgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBldmVudFR5cGUgRXZlbnQgdHlwZVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBsaXN0ZW5lcnNcbiAgICovXG4gIHB1YmxpYyBnZXRMaXN0ZW5lcnMoa2VybmVsSWQ6IHN0cmluZywgZXZlbnRUeXBlOiBLZXJuZWxFdmVudHMpOiAoKGRhdGE6IGFueSkgPT4gdm9pZClbXSB7XG4gICAgY29uc3Qga2VybmVsTGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcldyYXBwZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBrZXJuZWxMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKCFldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudExpc3RlbmVycy5rZXlzKCkpIGFzICgoZGF0YTogYW55KSA9PiB2b2lkKVtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgUHl0aG9uIGNvZGUgd2l0aCBzdHJlYW1pbmcgb3V0cHV0XG4gICAqIFRoaXMgbWV0aG9kIHdvcmtzIGluIGJvdGggbWFpbiB0aHJlYWQgYW5kIHdvcmtlciBtb2Rlc1xuICAgKiBAcGFyYW0ga2VybmVsSWQgSUQgb2YgdGhlIGtlcm5lbCB0byB1c2VcbiAgICogQHBhcmFtIGNvZGUgVGhlIFB5dGhvbiBjb2RlIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHBhcmVudCBPcHRpb25hbCBwYXJlbnQgbWVzc2FnZSBoZWFkZXJcbiAgICogQHJldHVybnMgQXN5bmNHZW5lcmF0b3IgeWllbGRpbmcgaW50ZXJtZWRpYXRlIG91dHB1dHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyogZXhlY3V0ZVN0cmVhbShcbiAgICBrZXJuZWxJZDogc3RyaW5nLCBcbiAgICBjb2RlOiBzdHJpbmcsIFxuICAgIHBhcmVudDogYW55ID0ge31cbiAgKTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEtlcm5lbChrZXJuZWxJZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgd2l0aCBJRCAke2tlcm5lbElkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGtlcm5lbCBhY3Rpdml0eVxuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgIFxuICAgIC8vIFRyYWNrIHRoaXMgZXhlY3V0aW9uIHdpdGggdGhlIGNvZGUgZm9yIGJldHRlciBtb25pdG9yaW5nXG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSB0aGlzLnRyYWNrRXhlY3V0aW9uKGtlcm5lbElkLCBjb2RlKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgQWJvcnRDb250cm9sbGVyIGZvciB0aGlzIGV4ZWN1dGlvbiB0byBlbmFibGUgY2FuY2VsbGF0aW9uXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuc3RvcmVBYm9ydENvbnRyb2xsZXIoa2VybmVsSWQsIGV4ZWN1dGlvbklkLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGb3IgbWFpbiB0aHJlYWQga2VybmVscywgd2UgY2FuIHVzZSB0aGUgZXhlY3V0ZVN0cmVhbSBtZXRob2QgZGlyZWN0bHlcbiAgICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLk1BSU5fVEhSRUFEKSB7XG4gICAgICAgIGNvbnN0IGtlcm5lbCA9IGluc3RhbmNlLmtlcm5lbCBhcyB1bmtub3duIGFzIHsgXG4gICAgICAgICAgZXhlY3V0ZVN0cmVhbTogKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkpID0+IEFzeW5jR2VuZXJhdG9yPGFueSwgYW55LCB2b2lkPiBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvcndhcmQgdG8gdGhlIGtlcm5lbCdzIGV4ZWN1dGVTdHJlYW0gbWV0aG9kXG4gICAgICAgIGlmICh0eXBlb2Yga2VybmVsLmV4ZWN1dGVTdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQqIGtlcm5lbC5leGVjdXRlU3RyZWFtKGNvZGUsIHBhcmVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSBhZnRlciBleGVjdXRpb24gY29tcGxldGVzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gbWFpbiB0aHJlYWQgZXhlY3V0ZVN0cmVhbTpgLCBlcnJvcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSBldmVuIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmcgZXZlbiBvbiBlcnJvclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3Igd29ya2VyIG1vZGUsIHdlIG5lZWQgdG8gaW1wbGVtZW50IHN0cmVhbWluZyB2aWEgZXZlbnRzIHdpdGggcHJvcGVyIGlzb2xhdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRXZlbnQtYmFzZWQgYXBwcm9hY2ggZm9yIHdvcmtlciBrZXJuZWxzIG9yIG1haW4gdGhyZWFkIGtlcm5lbHMgd2l0aG91dCBleGVjdXRlU3RyZWFtXG4gICAgICAgIGNvbnN0IHN0cmVhbVF1ZXVlOiBhbnlbXSA9IFtdO1xuICAgICAgICBsZXQgZXhlY3V0aW9uQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV4ZWN1dGlvblJlc3VsdDogeyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfSA9IHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgaGFuZGxlciByZWZlcmVuY2VzIGZvciBndWFyYW50ZWVkIGNsZWFudXBcbiAgICAgICAgY29uc3QgZXZlbnRIYW5kbGVycyA9IG5ldyBNYXA8c3RyaW5nLCAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHZvaWQ+KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2xlYW4gdXAgYWxsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGNvbnN0IGNsZWFudXBIYW5kbGVycyA9ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtldmVudFR5cGUsIGhhbmRsZXJdIG9mIGV2ZW50SGFuZGxlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzdXBlci5vZmYoZXZlbnRUeXBlIGFzIGFueSwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50SGFuZGxlcnMuY2xlYXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBleGVjdXRpb24tc3BlY2lmaWMgZXZlbnQgaGFuZGxlcnMgdGhhdCBpbmNsdWRlIGV4ZWN1dGlvbklkIGNoZWNrXG4gICAgICAgIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSAoZXZlbnRUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZXZlbnRzIGZvciB0aGlzIHNwZWNpZmljIGtlcm5lbCBhbmQgd2hpbGUgdGhpcyBleGVjdXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAoZXZlbnQua2VybmVsSWQgPT09IGtlcm5lbElkICYmICFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBzdHJlYW1RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25JZCAvLyBJbmNsdWRlIGV4ZWN1dGlvbiBJRCBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRXZlbnRzIGFsc28gY291bnQgYXMgYWN0aXZpdHlcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBldmVudEhhbmRsZXJzLnNldChldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCByZWdpc3RlciBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgY29uc3QgaGFuZGxlU3RyZWFtRXZlbnQgPSBjcmVhdGVIYW5kbGVyKCdzdHJlYW0nKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRGlzcGxheUV2ZW50ID0gY3JlYXRlSGFuZGxlcignZGlzcGxheV9kYXRhJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZURpc3BsYXlFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ3VwZGF0ZV9kaXNwbGF5X2RhdGEnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzdWx0RXZlbnQgPSBjcmVhdGVIYW5kbGVyKCdleGVjdXRlX3Jlc3VsdCcpO1xuICAgICAgICBjb25zdCBoYW5kbGVFcnJvckV2ZW50ID0gY3JlYXRlSGFuZGxlcignZXhlY3V0ZV9lcnJvcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVnaXN0ZXIgaGFuZGxlcnNcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLlNUUkVBTSwgaGFuZGxlU3RyZWFtRXZlbnQpO1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRElTUExBWV9EQVRBLCBoYW5kbGVEaXNwbGF5RXZlbnQpO1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuVVBEQVRFX0RJU1BMQVlfREFUQSwgaGFuZGxlVXBkYXRlRGlzcGxheUV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkVYRUNVVEVfUkVTVUxULCBoYW5kbGVSZXN1bHRFdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBoYW5kbGVFcnJvckV2ZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAvLyBTZXQgdXAgYSBoYW5kbGVyIGZvciBleGVjdXRpb24gZXJyb3JzIHNwZWNpZmljYWxseVxuICAgICAgICAgIGNvbnN0IGhhbmRsZUV4ZWN1dGlvbkVycm9yID0gKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2VybmVsSWQgPT09IGtlcm5lbElkICYmICFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAvLyBNYXJrIGV4ZWN1dGlvbiBhcyBjb21wbGV0ZSB0byBzdG9wIHByb2Nlc3NpbmcgbW9yZSBldmVudHNcbiAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGVycm9yIGZvciB0aGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke2V2ZW50LmRhdGEuZW5hbWV9OiAke2V2ZW50LmRhdGEuZXZhbHVlfWApLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogZXZlbnQuZGF0YVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmVzb2x2ZShleGVjdXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIGVycm9yIGhhbmRsZXIgdG8gb3VyIGNsZWFudXAgbGlzdFxuICAgICAgICAgIGV2ZW50SGFuZGxlcnMuc2V0KCdleGVjdXRlX2Vycm9yX2NvbXBsZXRpb24nLCBoYW5kbGVFeGVjdXRpb25FcnJvcik7XG4gICAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIGhhbmRsZUV4ZWN1dGlvbkVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGFib3J0ZWRcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0V4ZWN1dGlvbiB3YXMgYWJvcnRlZCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IHVwIGFib3J0IGhhbmRsZXJcbiAgICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBhYm9ydGVkYCk7XG4gICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0V4ZWN1dGlvbiB3YXMgYWJvcnRlZCcpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY29kZVxuICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGV4ZWN1dGUgbWV0aG9kIGlzIGF2YWlsYWJsZSBkaXJlY3RseSBvbiB0aGUga2VybmVsIG9iamVjdFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUHJvbWlzZSA9IGluc3RhbmNlLmtlcm5lbC5leGVjdXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4ZWN1dGVQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgaWYgZXhlY3V0aW9uIGhhc24ndCBiZWVuIG1hcmtlZCBjb21wbGV0ZSBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXhlY3V0aW9uIHJlc3VsdCBpbmRpY2F0ZXMgYW4gZXJyb3IgKGZvciBQeXRob24ga2VybmVscylcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LnJlc3VsdCAmJiByZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXN1bHQucmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgZW5hbWU6IHJlc3VsdC5yZXN1bHQuZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2YWx1ZTogcmVzdWx0LnJlc3VsdC5ldmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlYmFjazogcmVzdWx0LnJlc3VsdC50cmFjZWJhY2tcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFB1c2ggZXJyb3IgdG8gc3RyZWFtIHF1ZXVlIGRpcmVjdGx5IFxuICAgICAgICAgICAgICAgICAgc3RyZWFtUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uSWRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhlY3V0aW9uIHJlc3VsdCB0byByZWZsZWN0IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgJHtyZXN1bHQucmVzdWx0LmVuYW1lfTogJHtyZXN1bHQucmVzdWx0LmV2YWx1ZX1gKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQucmVzdWx0XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgd2hlbiBleGVjdXRpb24gY29tcGxldGVzXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShleGVjdXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGlmIGV4ZWN1dGlvbiBoYXNuJ3QgYmVlbiBtYXJrZWQgY29tcGxldGUgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gZXhlY3V0ZSBmb3Iga2VybmVsICR7a2VybmVsSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgS2V5Ym9hcmRJbnRlcnJ1cHQgYW5kIGhhbmRsZSBpdCBzcGVjaWFsbHlcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNLZXlib2FyZEludGVycnVwdChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBLZXlib2FyZEludGVycnVwdCBjYXVnaHQgaW4gZXhlY3V0ZVN0cmVhbSBmb3Iga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IHRoaXMuY3JlYXRlS2V5Ym9hcmRJbnRlcnJ1cHRSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQWxzbyBwdXNoIHRvIHN0cmVhbSBxdWV1ZSBmb3IgaW1tZWRpYXRlIGZlZWRiYWNrXG4gICAgICAgICAgICAgICAgICBzdHJlYW1RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyb3JSZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25JZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBvdGhlciBlcnJvcnMgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICAgIGVycm9yUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSBldmVuIG9uIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlcnJvclJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgaWYgZXhlY3V0aW9uIGhhc24ndCBiZWVuIG1hcmtlZCBjb21wbGV0ZSBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhbGxpbmcgZXhlY3V0ZSBmb3Iga2VybmVsICR7a2VybmVsSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgICAgICBjb25zdCBlcnJvclJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGV2ZW4gb24gZGlyZWN0IGVycm9yXG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmVzb2x2ZShlcnJvclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSB0cnkvZmluYWxseSB0byBndWFyYW50ZWUgY2xlYW51cFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE1vbml0b3IgdGhlIHN0cmVhbSBxdWV1ZSBhbmQgeWllbGQgcmVzdWx0c1xuICAgICAgICAgIC8vIENvbnRpbnVlIHVudGlsIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZSBBTkQgYWxsIHF1ZXVlZCBldmVudHMgaGF2ZSBiZWVuIHlpZWxkZWRcbiAgICAgICAgICB3aGlsZSAoKCFleGVjdXRpb25Db21wbGV0ZSB8fCBzdHJlYW1RdWV1ZS5sZW5ndGggPiAwKSAmJiAhYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgaXRlbXMgaW4gdGhlIHF1ZXVlLCB5aWVsZCB0aGVtXG4gICAgICAgICAgICBpZiAoc3RyZWFtUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHN0cmVhbVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgbm8gbW9yZSBldmVudHMgYnV0IGV4ZWN1dGlvbiBpcyBub3QgY29tcGxldGUsIHdhaXQgYSBsaXR0bGVcbiAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHdhaXRcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKTtcbiAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWJvcnRlZCwgYnJlYWsgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZXhlY3V0aW9uIHdhcyBhYm9ydGVkIGR1cmluZyBzdHJlYW0gbW9uaXRvcmluZ1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiYgIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4ZWN1dGlvbiB3YXMgYWJvcnRlZCBkdXJpbmcgc3RyZWFtIG1vbml0b3JpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGlvblByb21pc2U7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBBTFdBWVMgY2xlYW4gdXAgZXZlbnQgaGFuZGxlcnMgcmVnYXJkbGVzcyBvZiBob3cgZXhlY3V0aW9uIGVuZHNcbiAgICAgICAgICBjbGVhbnVwSGFuZGxlcnMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgQWJvcnRDb250cm9sbGVyIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgdGhpcy5yZW1vdmVBYm9ydENvbnRyb2xsZXIoa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmdcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZyBvbiBhbnkgb3V0ZXIgZXJyb3JcbiAgICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5leHBlY3RlZCBlcnJvciBpbiBleGVjdXRlU3RyZWFtOmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmcgb24gYW55IG91dGVyIGVycm9yXG4gICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3IgaW4gZXhlY3V0ZVN0cmVhbTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrIGEgbmV3IGV4ZWN1dGlvbiB0YXNrIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBjb2RlIE9wdGlvbmFsIGNvZGUgYmVpbmcgZXhlY3V0ZWQgZm9yIG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIFVuaXF1ZSBleGVjdXRpb24gSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgdHJhY2tFeGVjdXRpb24oa2VybmVsSWQ6IHN0cmluZywgY29kZT86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGV4ZWN1dGlvbiBJRFxuICAgIGNvbnN0IGV4ZWN1dGlvbklkID0gYGV4ZWMtJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWA7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICAvLyBSZXNldCBpbnRlcnJ1cHQgYnVmZmVyIGZvciB3b3JrZXIga2VybmVscyBiZWZvcmUgZWFjaCBuZXcgZXhlY3V0aW9uXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBrZXJuZWwgY2FuIGJlIGludGVycnVwdGVkIG11bHRpcGxlIHRpbWVzXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IGludGVycnVwdEJ1ZmZlciA9IHRoaXMuaW50ZXJydXB0QnVmZmVycy5nZXQoa2VybmVsSWQpITtcbiAgICAgIC8vIFJlc2V0IGJ1ZmZlciB0byAwIChubyBpbnRlcnJ1cHQgc2lnbmFsKSB0byBlbnN1cmUgY2xlYW4gc3RhdGVcbiAgICAgIGludGVycnVwdEJ1ZmZlclswXSA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBvciBjcmVhdGUgdGhlIHNldCBvZiBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIHRoaXMga2VybmVsXG4gICAgaWYgKCF0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuc2V0KGtlcm5lbElkLCBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgdGhpcyBleGVjdXRpb24gdG8gdGhlIHNldFxuICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGtlcm5lbElkKSEuYWRkKGV4ZWN1dGlvbklkKTtcbiAgICBcbiAgICAvLyBUcmFjayBleGVjdXRpb24gc3RhcnQgdGltZVxuICAgIGlmICghdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHN0YXJ0VGltZSk7XG4gICAgXG4gICAgLy8gVHJhY2sgZXhlY3V0aW9uIG1ldGFkYXRhXG4gICAgaWYgKCF0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgYWN0aXZpdHkgdGltZXN0YW1wXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgXG4gICAgLy8gSWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzZXQsIGNyZWF0ZSBhIHRpbWVvdXQgdG8gZGV0ZWN0IHN0dWNrL2RlYWQga2VybmVsc1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgJiYgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lID4gMCkge1xuICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgbWFwIG9mIGV4ZWN1dGlvbiB0aW1lb3V0cyBmb3IgdGhpcyBrZXJuZWxcbiAgICAgIGlmICghdGhpcy5leGVjdXRpb25UaW1lb3V0cy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXQgYSB0aW1lb3V0IGZvciB0aGlzIGV4ZWN1dGlvbiB3aXRoIGVuaGFuY2VkIGhhbmRsaW5nXG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKGBFeGVjdXRpb24gJHtleGVjdXRpb25JZH0gb24ga2VybmVsICR7a2VybmVsSWR9IGhhcyBiZWVuIHJ1bm5pbmcgZm9yICR7aW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lfW1zIGFuZCBtYXkgYmUgc3R1Y2svZGVhZC5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBleGVjdXRpb24gbWV0YWRhdGEgZm9yIGJldHRlciBlcnJvciByZXBvcnRpbmdcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCk/LmdldChleGVjdXRpb25JZCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFJ1bnRpbWUgPSBEYXRlLm5vdygpIC0gKG1ldGFkYXRhPy5zdGFydFRpbWUgfHwgc3RhcnRUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVtaXQgYSBzdGFsbGVkIGV4ZWN1dGlvbiBldmVudCB3aXRoIGVuaGFuY2VkIGluZm9ybWF0aW9uXG4gICAgICAgIHN1cGVyLmVtaXQoJ2V4ZWN1dGlvbl9zdGFsbGVkJywge1xuICAgICAgICAgIGtlcm5lbElkLFxuICAgICAgICAgIGV4ZWN1dGlvbklkLFxuICAgICAgICAgIG1heEV4ZWN1dGlvblRpbWU6IGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSxcbiAgICAgICAgICBhY3R1YWxSdW50aW1lLFxuICAgICAgICAgIGNvZGU6IG1ldGFkYXRhPy5jb2RlIHx8IGNvZGUsXG4gICAgICAgICAgc3RhcnRUaW1lOiBtZXRhZGF0YT8uc3RhcnRUaW1lIHx8IHN0YXJ0VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF1dG8taGFuZGxlIHN0dWNrIGV4ZWN1dGlvbiBpZiBjb25maWd1cmVkXG4gICAgICAgIHRoaXMuaGFuZGxlU3R1Y2tFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkLCBhY3R1YWxSdW50aW1lLCBtZXRhZGF0YT8uY29kZSB8fCBjb2RlKTtcbiAgICAgIH0sIGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSB0aW1lb3V0IElEXG4gICAgICB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwgdGltZW91dElkKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgbWV0YWRhdGEgaW5jbHVkaW5nIHRpbWVvdXQgSURcbiAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgY29kZSxcbiAgICAgICAgdGltZW91dElkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RvcmUgbWV0YWRhdGEgd2l0aG91dCB0aW1lb3V0IElEXG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwge1xuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGNvZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZXhlY3V0aW9uSWQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0cmFja2luZyBmb3IgYW4gZXhlY3V0aW9uXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV4ZWN1dGlvbklkIEV4ZWN1dGlvbiBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gQ2xlYXIgYW55IGV4ZWN1dGlvbiB0aW1lb3V0XG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZW91dHMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3QgdGltZW91dHMgPSB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmdldChrZXJuZWxJZCkhO1xuICAgICAgaWYgKHRpbWVvdXRzLmhhcyhleGVjdXRpb25JZCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRzLmdldChleGVjdXRpb25JZCkpO1xuICAgICAgICB0aW1lb3V0cy5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgICBpZiAodGltZW91dHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiBzdGFydCB0aW1lc1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lcyA9IHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5nZXQoa2VybmVsSWQpITtcbiAgICAgIHN0YXJ0VGltZXMuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgbWFwc1xuICAgICAgaWYgKHN0YXJ0VGltZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIG1ldGFkYXRhXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCkhO1xuICAgICAgbWV0YWRhdGEuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgbWFwc1xuICAgICAgaWYgKG1ldGFkYXRhLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgZnJvbSBvbmdvaW5nIGV4ZWN1dGlvbnNcbiAgICBpZiAodGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBleGVjdXRpb25zID0gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoa2VybmVsSWQpITtcbiAgICAgIGV4ZWN1dGlvbnMuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgc2V0c1xuICAgICAgaWYgKGV4ZWN1dGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgdGltZXN0YW1wIGZvciBjb21wbGV0ZWQgZXhlY3V0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2VybmVsIGhhcyBhbnkgb25nb2luZyBleGVjdXRpb25zXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2VybmVsIGhhcyBvbmdvaW5nIGV4ZWN1dGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaGFzT25nb2luZ0V4ZWN1dGlvbnMoa2VybmVsSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmhhcyhrZXJuZWxJZCkgJiYgXG4gICAgICAgICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGtlcm5lbElkKSEuc2l6ZSA+IDA7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvdW50IG9mIG9uZ29pbmcgZXhlY3V0aW9ucyBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2Ygb25nb2luZyBleGVjdXRpb25zXG4gICAqL1xuICBwdWJsaWMgZ2V0T25nb2luZ0V4ZWN1dGlvbkNvdW50KGlkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmICghdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5oYXMoaWQpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGlkKSEuc2l6ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldCB1cCBhbiBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHRpbWVvdXQgVGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nLCB0aW1lb3V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBEb24ndCBzZXQgdXAgYSB0aW1lciBpZiB0aW1lb3V0IGlzIDAgb3IgbmVnYXRpdmVcbiAgICBpZiAodGltZW91dCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIEFsd2F5cyBjbGVhciBhbnkgZXhpc3RpbmcgdGltZXIgZmlyc3RcbiAgICB0aGlzLmNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSByZW1haW5pbmcgdGltZSBiYXNlZCBvbiBsYXN0IGFjdGl2aXR5XG4gICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmdldChpZCkgfHwgRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eTtcbiAgICBjb25zdCByZW1haW5pbmdUaW1lID0gTWF0aC5tYXgoMCwgdGltZW91dCAtIGVsYXBzZWQpO1xuICAgIFxuICAgIC8vIElmIG5vIHRpbWUgcmVtYWluaW5nLCBkZXN0cm95IGltbWVkaWF0ZWx5XG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IDApIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIG9uZ29pbmcgZXhlY3V0aW9ucyBiZWZvcmUgc2h1dHRpbmcgZG93blxuICAgICAgaWYgKHRoaXMuaGFzT25nb2luZ0V4ZWN1dGlvbnMoaWQpKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lciB0byBjaGVjayBhZ2FpbiBsYXRlclxuICAgICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlc3Ryb3kgaW1tZWRpYXRlbHlcbiAgICAgIHRoaXMuZGVzdHJveUtlcm5lbChpZCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIGluYWN0aXZlIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgdGltZXIgdG8gZGVzdHJveSB0aGUga2VybmVsIGFmdGVyIHRoZSByZW1haW5pbmcgdGltZW91dFxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUga2VybmVsIGhhcyBvbmdvaW5nIGV4ZWN1dGlvbnMgYmVmb3JlIHNodXR0aW5nIGRvd25cbiAgICAgIGlmICh0aGlzLmhhc09uZ29pbmdFeGVjdXRpb25zKGlkKSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXIgdG8gY2hlY2sgYWdhaW4gbGF0ZXJcbiAgICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVzdHJveWluZyBpbmFjdGl2ZSBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSwgcmVtYWluaW5nVGltZSk7XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIHRpbWVyIElEXG4gICAgdGhpcy5pbmFjdGl2aXR5VGltZXJzLnNldChpZCwgdGltZXIpO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xlYXIgYW55IGV4aXN0aW5nIGluYWN0aXZpdHkgdGltZW91dCBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pbmFjdGl2aXR5VGltZXJzLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLmluYWN0aXZpdHlUaW1lcnMuZ2V0KGlkKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgIHRoaXMuaW5hY3Rpdml0eVRpbWVycy5kZWxldGUoaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYWN0aXZpdHkgdGltZXN0YW1wIGZvciBhIGtlcm5lbCBhbmQgcmVzZXQgaW5hY3Rpdml0eSB0aW1lciBpZiBwcmVzZW50XG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlS2VybmVsQWN0aXZpdHkoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBhY3Rpdml0eSB0aW1lXG4gICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lLnNldChpZCwgRGF0ZS5ub3coKSk7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBrZXJuZWwgb3B0aW9uc1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHRpbWVvdXQgPSBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0O1xuICAgIFxuICAgIC8vIFJlc2V0IHRoZSBpbmFjdGl2aXR5IHRpbWVyIGlmIHRpbWVvdXQgaXMgZW5hYmxlZCAoZ3JlYXRlciB0aGFuIDApXG4gICAgaWYgKHRpbWVvdXQgJiYgdGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBhY3Rpdml0eSB0aW1lIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIExhc3QgYWN0aXZpdHkgdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2gsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBnZXRMYXN0QWN0aXZpdHlUaW1lKGlkOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuZ2V0KGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluYWN0aXZpdHkgdGltZW91dCBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBJbmFjdGl2aXR5IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLCBvciB1bmRlZmluZWQgaWYgbm90IHNldFxuICAgKi9cbiAgcHVibGljIGdldEluYWN0aXZpdHlUaW1lb3V0KGlkOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICByZXR1cm4gaW5zdGFuY2Uub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3IgdXBkYXRlIHRoZSBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHRpbWVvdXQgVGltZW91dCBpbiBtaWxsaXNlY29uZHMsIG9yIDAgdG8gZGlzYWJsZVxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0aW1lb3V0IHdhcyBzZXQsIGZhbHNlIGlmIHRoZSBrZXJuZWwgd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIHNldEluYWN0aXZpdHlUaW1lb3V0KGlkOiBzdHJpbmcsIHRpbWVvdXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgdGltZW91dCBpbiB0aGUgb3B0aW9uc1xuICAgIGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lclxuICAgIHRoaXMuY2xlYXJJbmFjdGl2aXR5VGltZW91dChpZCk7XG4gICAgXG4gICAgLy8gSWYgdGltZW91dCBpcyBncmVhdGVyIHRoYW4gMCwgc2V0IHVwIGEgbmV3IHRpbWVyXG4gICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIHRpbWVvdXQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGltZSB1bnRpbCBhdXRvLXNodXRkb3duIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHVudGlsIGF1dG8tc2h1dGRvd24sIG9yIHVuZGVmaW5lZCBpZiBubyB0aW1lb3V0IGlzIHNldFxuICAgKi9cbiAgcHVibGljIGdldFRpbWVVbnRpbFNodXRkb3duKGlkOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCB0aW1lb3V0ID0gaW5zdGFuY2Uub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dDtcbiAgICBpZiAoIXRpbWVvdXQgfHwgdGltZW91dCA8PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IGxhc3RBY3Rpdml0eSA9IHRoaXMubGFzdEFjdGl2aXR5VGltZS5nZXQoaWQpO1xuICAgIGlmICghbGFzdEFjdGl2aXR5KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eTtcbiAgICBjb25zdCByZW1haW5pbmdUaW1lID0gdGltZW91dCAtIGVsYXBzZWRUaW1lO1xuICAgIFxuICAgIHJldHVybiBNYXRoLm1heCgwLCByZW1haW5pbmdUaW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBvZiBpbmFjdGl2aXR5IHRpbWVycyAoZm9yIGRlYnVnZ2luZy90ZXN0aW5nIG9ubHkpXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGtlcm5lbCBJRHMgYXMga2V5cyBhbmQgdGltZXIgSURzIGFzIHZhbHVlc1xuICAgKi9cbiAgcHVibGljIGdldEluYWN0aXZpdHlUaW1lcnMoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG4gICAgLy8gQ29udmVydCBNYXAgdG8gT2JqZWN0IGZvciBlYXNpZXIgaW5zcGVjdGlvblxuICAgIGNvbnN0IHRpbWVyczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIHRoaXMuaW5hY3Rpdml0eVRpbWVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aW1lcnNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aW1lcnM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGEgaGFuZGxlciBmb3Igc3RhbGxlZCBleGVjdXRpb25zXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2V0dXBTdGFsbGVkRXhlY3V0aW9uSGFuZGxlcihpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gTGlzdGVuIGZvciBzdGFsbGVkIGV4ZWN1dGlvbiBldmVudHNcbiAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VUSU9OX1NUQUxMRUQsIChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nLCBtYXhFeGVjdXRpb25UaW1lOiBudW1iZXIgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBpZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEhhbmRsaW5nIHN0YWxsZWQgZXhlY3V0aW9uICR7ZXZlbnQuZXhlY3V0aW9uSWR9IG9uIGtlcm5lbCAke2lkfSAocnVubmluZyBsb25nZXIgdGhhbiAke2V2ZW50Lm1heEV4ZWN1dGlvblRpbWV9bXMpYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbWl0IGFuIGV2ZW50IGZvciBjbGllbnRzIHRvIGhhbmRsZVxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGVuYW1lOiBcIkV4ZWN1dGlvblN0YWxsZWRFcnJvclwiLFxuICAgICAgICAgICAgICBldmFsdWU6IGBFeGVjdXRpb24gc3RhbGxlZCBvciBwb3RlbnRpYWxseSBkZWFkbG9ja2VkIChydW5uaW5nID4gJHtldmVudC5tYXhFeGVjdXRpb25UaW1lfW1zKWAsXG4gICAgICAgICAgICAgIHRyYWNlYmFjazogW1wiRXhlY3V0aW9uIG1heSBiZSBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wIG9yIGRlYWRsb2NrZWQuXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSB0ZXJtaW5hdGUgYSBwb3RlbnRpYWxseSBzdHVjayBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gcmVhc29uIE9wdGlvbmFsIHJlYXNvbiBmb3IgdGVybWluYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUga2VybmVsIHdhcyB0ZXJtaW5hdGVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZm9yY2VUZXJtaW5hdGVLZXJuZWwoaWQ6IHN0cmluZywgcmVhc29uID0gXCJGb3JjZSB0ZXJtaW5hdGVkIGR1ZSB0byBzdGFsbGVkIGV4ZWN1dGlvblwiKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBMb2cgdGhlIGZvcmNlZCB0ZXJtaW5hdGlvblxuICAgICAgY29uc29sZS53YXJuKGBGb3JjZSB0ZXJtaW5hdGluZyBrZXJuZWwgJHtpZH06ICR7cmVhc29ufWApO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGFuIGVycm9yIGV2ZW50IHRvIG5vdGlmeSBjbGllbnRzXG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktlcm5lbEZvcmNlZFRlcm1pbmF0aW9uXCIsXG4gICAgICAgICAgZXZhbHVlOiByZWFzb24sXG4gICAgICAgICAgdHJhY2ViYWNrOiBbXCJLZXJuZWwgd2FzIGZvcmNlZnVsbHkgdGVybWluYXRlZCBieSB0aGUgc3lzdGVtLlwiXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRGVzdHJveSB0aGUga2VybmVsXG4gICAgICBhd2FpdCB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBmb3JjZWQgdGVybWluYXRpb24gb2Yga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IG9uZ29pbmcgZXhlY3V0aW9ucyBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCBvbmdvaW5nIGV4ZWN1dGlvbnMgd2l0aCBhY2N1cmF0ZSB0aW1pbmdcbiAgICovXG4gIHB1YmxpYyBnZXRFeGVjdXRpb25JbmZvKGlkOiBzdHJpbmcpOiB7IFxuICAgIGNvdW50OiBudW1iZXI7IFxuICAgIGlzU3R1Y2s6IGJvb2xlYW47IFxuICAgIGV4ZWN1dGlvbklkczogc3RyaW5nW107XG4gICAgbG9uZ2VzdFJ1bm5pbmdUaW1lPzogbnVtYmVyO1xuICAgIGV4ZWN1dGlvbnM6IEFycmF5PHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICAgIHJ1bnRpbWU6IG51bWJlcjtcbiAgICAgIGNvZGU/OiBzdHJpbmc7XG4gICAgICBpc1N0dWNrOiBib29sZWFuO1xuICAgIH0+O1xuICB9IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiB7IGNvdW50OiAwLCBpc1N0dWNrOiBmYWxzZSwgZXhlY3V0aW9uSWRzOiBbXSwgZXhlY3V0aW9uczogW10gfTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIHBhcnRpYWxseSBpbml0aWFsaXplZCBrZXJuZWxzIHdoZXJlIG9wdGlvbnMgbWF5IG5vdCBiZSBmdWxseSBzZXRcbiAgICBpZiAoIWluc3RhbmNlLm9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB7IGNvdW50OiAwLCBpc1N0dWNrOiBmYWxzZSwgZXhlY3V0aW9uSWRzOiBbXSwgZXhlY3V0aW9uczogW10gfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZXhlY3V0aW9uSWRzID0gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoaWQpIFxuICAgICAgPyBBcnJheS5mcm9tKHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGlkKSEpXG4gICAgICA6IFtdO1xuICAgIFxuICAgIGNvbnN0IGNvdW50ID0gZXhlY3V0aW9uSWRzLmxlbmd0aDtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbWF4RXhlY3V0aW9uVGltZSA9IGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZTtcbiAgICBcbiAgICAvLyBCdWlsZCBkZXRhaWxlZCBleGVjdXRpb24gaW5mb3JtYXRpb25cbiAgICBjb25zdCBleGVjdXRpb25zOiBBcnJheTx7XG4gICAgICBpZDogc3RyaW5nO1xuICAgICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgICBydW50aW1lOiBudW1iZXI7XG4gICAgICBjb2RlPzogc3RyaW5nO1xuICAgICAgaXNTdHVjazogYm9vbGVhbjtcbiAgICB9PiA9IFtdO1xuICAgIFxuICAgIGxldCBsb25nZXN0UnVubmluZ1RpbWU6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgYW55U3R1Y2sgPSBmYWxzZTtcbiAgICBcbiAgICAvLyBHZXQgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzIGFuZCBtZXRhZGF0YVxuICAgIGNvbnN0IHN0YXJ0VGltZXMgPSB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZ2V0KGlkKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGlkKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGV4ZWN1dGlvbklkIG9mIGV4ZWN1dGlvbklkcykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc3RhcnRUaW1lcz8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgIGNvbnN0IGV4ZWNNZXRhZGF0YSA9IG1ldGFkYXRhPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICBpZiAoc3RhcnRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcnVudGltZSA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBjb25zdCBpc1N0dWNrID0gbWF4RXhlY3V0aW9uVGltZSAhPT0gdW5kZWZpbmVkICYmIHJ1bnRpbWUgPiBtYXhFeGVjdXRpb25UaW1lO1xuICAgICAgICBcbiAgICAgICAgZXhlY3V0aW9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogZXhlY3V0aW9uSWQsXG4gICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgIHJ1bnRpbWUsXG4gICAgICAgICAgY29kZTogZXhlY01ldGFkYXRhPy5jb2RlLFxuICAgICAgICAgIGlzU3R1Y2tcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmFjayBsb25nZXN0IHJ1bm5pbmcgdGltZVxuICAgICAgICBpZiAobG9uZ2VzdFJ1bm5pbmdUaW1lID09PSB1bmRlZmluZWQgfHwgcnVudGltZSA+IGxvbmdlc3RSdW5uaW5nVGltZSkge1xuICAgICAgICAgIGxvbmdlc3RSdW5uaW5nVGltZSA9IHJ1bnRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRyYWNrIGlmIGFueSBleGVjdXRpb24gaXMgc3R1Y2tcbiAgICAgICAgaWYgKGlzU3R1Y2spIHtcbiAgICAgICAgICBhbnlTdHVjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBleGVjdXRpb25zIHdpdGhvdXQgc3RhcnQgdGltZSB0cmFja2luZ1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIHN0YXJ0IHRpbWUgZm91bmQgZm9yIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgZXhlY3V0aW9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogZXhlY3V0aW9uSWQsXG4gICAgICAgICAgc3RhcnRUaW1lOiAwLFxuICAgICAgICAgIHJ1bnRpbWU6IDAsXG4gICAgICAgICAgY29kZTogZXhlY01ldGFkYXRhPy5jb2RlLFxuICAgICAgICAgIGlzU3R1Y2s6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTb3J0IGV4ZWN1dGlvbnMgYnkgc3RhcnQgdGltZSAob2xkZXN0IGZpcnN0KVxuICAgIGV4ZWN1dGlvbnMuc29ydCgoYSwgYikgPT4gYS5zdGFydFRpbWUgLSBiLnN0YXJ0VGltZSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50LFxuICAgICAgaXNTdHVjazogYW55U3R1Y2ssXG4gICAgICBleGVjdXRpb25JZHMsXG4gICAgICBsb25nZXN0UnVubmluZ1RpbWUsXG4gICAgICBleGVjdXRpb25zXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIFB5dGhvbiBjb2RlIGluIGEga2VybmVsXG4gICAqIFVzZXMgZXhlY3V0ZVN0cmVhbSB0byBjb2xsZWN0IGFsbCBvdXRwdXRzIGFuZCByZXR1cm4gdGhlbVxuICAgKiBAcGFyYW0ga2VybmVsSWQgSUQgb2YgdGhlIGtlcm5lbCB0byB1c2VcbiAgICogQHBhcmFtIGNvZGUgUHl0aG9uIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IE9wdGlvbmFsIHBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBleGVjdXRpb24gcmVzdWx0IHdpdGggY29sbGVjdGVkIG91dHB1dHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsXG4gICAgY29kZTogc3RyaW5nLFxuICAgIHBhcmVudDogYW55ID0ge31cbiAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIG91dHB1dHM/OiBhbnksIGVycm9yPzogRXJyb3IsIGVuYW1lPzogc3RyaW5nLCBldmFsdWU/OiBzdHJpbmcsIHRyYWNlYmFjaz86IGFueSB9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEtlcm5lbChrZXJuZWxJZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgd2l0aCBJRCAke2tlcm5lbElkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGluc3RhbmNlLmtlcm5lbC5leGVjdXRlKGNvZGUsIHBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXJuZWwgdHlwZSBpcyBhbGxvd2VkXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2VybmVsIHR5cGUgaXMgYWxsb3dlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBpc0tlcm5lbFR5cGVBbGxvd2VkKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFsbG93ZWRLZXJuZWxUeXBlcy5zb21lKHR5cGUgPT4gXG4gICAgICB0eXBlLm1vZGUgPT09IG1vZGUgJiYgdHlwZS5sYW5ndWFnZSA9PT0gbGFuZ3VhZ2VcbiAgICApO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIGFsbG93ZWQga2VybmVsIHR5cGVzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbG93ZWQga2VybmVsIHR5cGUgY29uZmlndXJhdGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRBbGxvd2VkS2VybmVsVHlwZXMoKTogQXJyYXk8e1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PiB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmFsbG93ZWRLZXJuZWxUeXBlc107IC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBtb2RpZmljYXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBQaW5nIGEga2VybmVsIHRvIHJlc2V0IGl0cyBhY3Rpdml0eSB0aW1lciBhbmQgZXh0ZW5kIHRoZSBkZWFkbGluZVxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtlcm5lbCB3YXMgcGluZ2VkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgcGluZ0tlcm5lbChpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBrZXJuZWwgYWN0aXZpdHkgKHRoaXMgd2lsbCByZXNldCB0aGUgaW5hY3Rpdml0eSB0aW1lcilcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0IGEga2VybmVsIGJ5IGRlc3Ryb3lpbmcgaXQgYW5kIGNyZWF0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBzYW1lIElEIGFuZCBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUga2VybmVsIHdhcyByZXN0YXJ0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBhc3luYyByZXN0YXJ0S2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IHJlc3RhcnQga2VybmVsICR7aWR9OiBrZXJuZWwgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAgICBjb25zdCBjdXJyZW50Q29uZmlnID0ge1xuICAgICAgICBtb2RlOiBpbnN0YW5jZS5tb2RlLFxuICAgICAgICBsYW5ndWFnZTogaW5zdGFuY2UubGFuZ3VhZ2UsXG4gICAgICAgIG9wdGlvbnM6IHsgLi4uaW5zdGFuY2Uub3B0aW9ucyB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IG5hbWVzcGFjZSBmcm9tIElEIGlmIHByZXNlbnRcbiAgICAgIGxldCBuYW1lc3BhY2U6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgIGxldCBiYXNlSWQ6IHN0cmluZztcbiAgICAgIFxuICAgICAgaWYgKGlkLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBpZC5zcGxpdCgnOicpO1xuICAgICAgICBuYW1lc3BhY2UgPSBwYXJ0c1swXTtcbiAgICAgICAgYmFzZUlkID0gcGFydHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlSWQgPSBpZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVzdHJveSB0aGUgZXhpc3Rpbmcga2VybmVsXG4gICAgICBhd2FpdCB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBuZXcga2VybmVsIHdpdGggdGhlIHNhbWUgY29uZmlndXJhdGlvblxuICAgICAgY29uc3QgcmVzdGFydE9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucyA9IHtcbiAgICAgICAgaWQ6IGJhc2VJZCxcbiAgICAgICAgbW9kZTogY3VycmVudENvbmZpZy5tb2RlLFxuICAgICAgICBsYW5nOiBjdXJyZW50Q29uZmlnLmxhbmd1YWdlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIGRlbm86IGN1cnJlbnRDb25maWcub3B0aW9ucy5kZW5vLFxuICAgICAgICBmaWxlc3lzdGVtOiBjdXJyZW50Q29uZmlnLm9wdGlvbnMuZmlsZXN5c3RlbSxcbiAgICAgICAgaW5hY3Rpdml0eVRpbWVvdXQ6IGN1cnJlbnRDb25maWcub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCxcbiAgICAgICAgbWF4RXhlY3V0aW9uVGltZTogY3VycmVudENvbmZpZy5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IGtlcm5lbFxuICAgICAgY29uc3QgbmV3S2VybmVsSWQgPSBhd2FpdCB0aGlzLmNyZWF0ZUtlcm5lbChyZXN0YXJ0T3B0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgbmV3IGtlcm5lbCBoYXMgdGhlIHNhbWUgSURcbiAgICAgIGlmIChuZXdLZXJuZWxJZCAhPT0gaWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgS2VybmVsIHJlc3RhcnQgZmFpbGVkOiBleHBlY3RlZCBJRCAke2lkfSwgZ290ICR7bmV3S2VybmVsSWR9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVzdGFydGluZyBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnJ1cHQgYSBydW5uaW5nIGtlcm5lbCBleGVjdXRpb25cbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBpbnRlcnJ1cHQgd2FzIHN1Y2Nlc3NmdWwsIGZhbHNlIGlmIG5vdCBmb3VuZCBvciBmYWlsZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbnRlcnJ1cHRLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgaW50ZXJydXB0IGtlcm5lbCAke2lkfToga2VybmVsIG5vdCBmb3VuZGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuV09SS0VSICYmIGluc3RhbmNlLndvcmtlcikge1xuICAgICAgICAvLyBGb3Igd29ya2VyIGtlcm5lbHMsIHVzZSBTaGFyZWRBcnJheUJ1ZmZlciBpbnRlcnJ1cHQgbWV0aG9kXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdFdvcmtlcktlcm5lbChpZCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG1haW4gdGhyZWFkIGtlcm5lbHMsIHRyeSB0byBpbnRlcnJ1cHQgKHdpbGwgdGhyb3cgZXJyb3IgaWYgbm90IHN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW50ZXJydXB0TWFpblRocmVhZEtlcm5lbChpZCwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbnRlcnJ1cHRpbmcga2VybmVsICR7aWR9OmAsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSW50ZXJydXB0IGEgbWFpbiB0aHJlYWQga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGluc3RhbmNlIEtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbnRlcnJ1cHQgc3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnRlcnJ1cHRNYWluVGhyZWFkS2VybmVsKGlkOiBzdHJpbmcsIGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBNYWluIHRocmVhZCBrZXJuZWxzIGRvbid0IHN1cHBvcnQgcHJvcGVyIGludGVycnVwdGlvbiBsaWtlIHdvcmtlciBrZXJuZWxzIGRvXG4gICAgLy8gRXZlbiBpZiB0aGV5IGhhdmUgYW4gaW50ZXJydXB0IG1ldGhvZCwgaXQncyBsaW1pdGVkIGFuZCB1bnJlbGlhYmxlXG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYWluIHRocmVhZCBrZXJuZWwgJHtpZH0gZG9lcyBub3Qgc3VwcG9ydCByZWxpYWJsZSBpbnRlcnJ1cHRpb24uIFVzZSB3b3JrZXIga2VybmVscyBmb3IgaW50ZXJydXB0aWJsZSBleGVjdXRpb24uYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnRlcnJ1cHQgYSB3b3JrZXIga2VybmVsIHVzaW5nIFNoYXJlZEFycmF5QnVmZmVyIGFjY29yZGluZyB0byBQeW9kaWRlIGRvY3VtZW50YXRpb25cbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gaW5zdGFuY2UgS2VybmVsIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGludGVycnVwdCBzdWNjZXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludGVycnVwdFdvcmtlcktlcm5lbChpZDogc3RyaW5nLCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdvcmtlciA9IGluc3RhbmNlLndvcmtlcjtcbiAgICAgIGlmICghd29ya2VyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdvcmtlciBub3QgZm91bmQgZm9yIGtlcm5lbCAke2lkfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIGludGVycnVwdGlvbiBtb2RlIGlzICdrZXJuZWwtaW50ZXJydXB0JywgdXNlIGZhbGxiYWNrIGRpcmVjdGx5XG4gICAgICBpZiAodGhpcy5pbnRlcnJ1cHRpb25Nb2RlID09PSAna2VybmVsLWludGVycnVwdCcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW50ZXJydXB0V29ya2VyS2VybmVsRmFsbGJhY2soaWQsIHdvcmtlcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhbiBpbnRlcnJ1cHQgYnVmZmVyIGZvciB0aGlzIGtlcm5lbFxuICAgICAgbGV0IGludGVycnVwdEJ1ZmZlciA9IHRoaXMuaW50ZXJydXB0QnVmZmVycy5nZXQoaWQpO1xuICAgICAgXG4gICAgICBpZiAoIWludGVycnVwdEJ1ZmZlcikge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIgZm9yIGludGVycnVwdCBjb250cm9sXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBTaGFyZWRBcnJheUJ1ZmZlciAocmVxdWlyZXMgc3BlY2lmaWMgc2VjdXJpdHkgaGVhZGVycylcbiAgICAgICAgICBjb25zdCBzaGFyZWRCdWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSk7XG4gICAgICAgICAgaW50ZXJydXB0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2hhcmVkQnVmZmVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJbml0aWFsaXplIGJ1ZmZlciB0byAwIChubyBpbnRlcnJ1cHQgc2lnbmFsKVxuICAgICAgICAgIGludGVycnVwdEJ1ZmZlclswXSA9IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RvcmUgdGhlIGJ1ZmZlciBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgIHRoaXMuaW50ZXJydXB0QnVmZmVycy5zZXQoaWQsIGludGVycnVwdEJ1ZmZlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2VuZCB0aGUgYnVmZmVyIHRvIHRoZSB3b3JrZXIgdG8gc2V0IHVwIHB5b2RpZGUuc2V0SW50ZXJydXB0QnVmZmVyKClcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJTRVRfSU5URVJSVVBUX0JVRkZFUlwiLFxuICAgICAgICAgICAgYnVmZmVyOiBpbnRlcnJ1cHRCdWZmZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgd29ya2VyIHRvIGNvbmZpcm0gYnVmZmVyIHNldHVwXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciBpbnRlcnJ1cHQgYnVmZmVyIHNldHVwXCIpKTtcbiAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiSU5URVJSVVBUX0JVRkZFUl9TRVRcIikge1xuICAgICAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYEludGVycnVwdCBidWZmZXIgc2V0IHVwIGZvciBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgYmFzZWQgb24gaW50ZXJydXB0aW9uIG1vZGVcbiAgICAgICAgICBpZiAodGhpcy5pbnRlcnJ1cHRpb25Nb2RlID09PSAnc2hhcmVkLWFycmF5LWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIC8vIElmIGV4cGxpY2l0bHkgc2V0IHRvIHNoYXJlZC1hcnJheS1idWZmZXIsIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBDYW5ub3QgY3JlYXRlIFNoYXJlZEFycmF5QnVmZmVyIGZvciBpbnRlcnJ1cHQgaGFuZGxpbmcgaW4ga2VybmVsICR7aWR9YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNoYXJlZEFycmF5QnVmZmVyIGlzIHJlcXVpcmVkIGZvciBpbnRlcnJ1cHRpb24gbW9kZSAnc2hhcmVkLWFycmF5LWJ1ZmZlcicgYnV0IGlzIG5vdCBhdmFpbGFibGUuXG5cblRvIGZpeCB0aGlzIGlzc3VlLCBlaXRoZXI6XG4xLiBDb25maWd1cmUgeW91ciB3ZWIgc2VydmVyIHdpdGggdGhlc2UgaGVhZGVyczpcbiAgIC0gQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3k6IHNhbWUtb3JpZ2luXG4gICAtIENyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3k6IHJlcXVpcmUtY29ycFxuXG4yLiBPciBjaGFuZ2UgdGhlIGludGVycnVwdGlvbiBtb2RlIHdoZW4gY3JlYXRpbmcgS2VybmVsTWFuYWdlcjpcbiAgIG5ldyBLZXJuZWxNYW5hZ2VyKHsgaW50ZXJydXB0aW9uTW9kZTogJ2F1dG8nIH0pYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF1dG8gbW9kZTogZmFsbCBiYWNrIHRvIGtlcm5lbC5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgY29uc29sZS5pbmZvKGDihLnvuI8gVXNpbmcgbWVzc2FnZS1iYXNlZCBpbnRlcnJ1cHQgZm9yIGtlcm5lbCAke2lkfSAoU2hhcmVkQXJyYXlCdWZmZXIgbm90IGF2YWlsYWJsZSlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBtZXNzYWdlLWJhc2VkIGludGVycnVwdFxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW50ZXJydXB0V29ya2VyS2VybmVsRmFsbGJhY2soaWQsIHdvcmtlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFjY29yZGluZyB0byBQeW9kaWRlIGRvY3M6IFNldCBpbnRlcnJ1cHQgc2lnbmFsICgyID0gU0lHSU5UKVxuICAgICAgY29uc29sZS5sb2coYFNldHRpbmcgaW50ZXJydXB0IHNpZ25hbCBmb3Iga2VybmVsICR7aWR9Li4uYCk7XG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAyO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBQeW9kaWRlIHRvIHByb2Nlc3MgdGhlIGludGVycnVwdFxuICAgICAgLy8gUHlvZGlkZSB3aWxsIHJlc2V0IHRoZSBidWZmZXIgdG8gMCB3aGVuIGl0IHByb2Nlc3NlcyB0aGUgaW50ZXJydXB0XG4gICAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1MDsgLy8gQ2hlY2sgZm9yIHVwIHRvIDUgc2Vjb25kcyAoNTAgKiAxMDBtcylcbiAgICAgIFxuICAgICAgd2hpbGUgKGF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMgJiYgaW50ZXJydXB0QnVmZmVyWzBdICE9PSAwKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGludGVycnVwdEJ1ZmZlclswXSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgSW50ZXJydXB0IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkgZm9yIGtlcm5lbCAke2lkfSBhZnRlciAke2F0dGVtcHRzICogMTAwfW1zYCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbnRlcnJ1cHQgc2lnbmFsIG5vdCBwcm9jZXNzZWQgZm9yIGtlcm5lbCAke2lkfSBhZnRlciAke21heEF0dGVtcHRzICogMTAwfW1zYCk7XG4gICAgICAgIC8vIFN0aWxsIHJldHVybiB0cnVlIGFzIHdlIHNldCB0aGUgc2lnbmFsIC0gdGhlIGludGVycnVwdCBtYXkgYmUgcHJvY2Vzc2VkIGxhdGVyXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGludGVycnVwdGluZyB3b3JrZXIga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBGYWxsYmFjayBpbnRlcnJ1cHQgbWV0aG9kIGZvciB3b3JrZXIga2VybmVscyB3aGVuIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGVcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gd29ya2VyIFdvcmtlciBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbnRlcnJ1cHQgc3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnRlcnJ1cHRXb3JrZXJLZXJuZWxGYWxsYmFjayhpZDogc3RyaW5nLCB3b3JrZXI6IFdvcmtlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gU2V0IHVwIGEgbGlzdGVuZXIgZm9yIHRoZSBpbnRlcnJ1cHQgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9UUklHR0VSRURcIikge1xuICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBldmVudC5kYXRhLmRhdGE/LnN1Y2Nlc3MgfHwgZmFsc2U7XG4gICAgICAgICAgcmVzb2x2ZShzdWNjZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTGlzdGVuIGZvciB0aGUgcmVzcG9uc2VcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIHRoZSBpbnRlcnJ1cHQgbWVzc2FnZVxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJJTlRFUlJVUFRfS0VSTkVMXCJcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTZXQgYSB0aW1lb3V0IGluIGNhc2Ugd2UgZG9uJ3QgZ2V0IGEgcmVzcG9uc2VcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgICAgY29uc29sZS53YXJuKGDij7HvuI8gSW50ZXJydXB0IHJlcXVlc3QgdGltZWQgb3V0IGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgNSBzZWNvbmRzLlxuVGhpcyBtYXkgaGFwcGVuIGlmOlxuLSBUaGUga2VybmVsIGlzIHJ1bm5pbmcgY29kZSB0aGF0IGNhbm5vdCBiZSBpbnRlcnJ1cHRlZFxuLSBUaGUga2VybmVsIGlzIGluIGFuIHVucmVzcG9uc2l2ZSBzdGF0ZVxuWW91IG1heSBuZWVkIHRvIHJlc3RhcnQgdGhlIGtlcm5lbCBpZiBpdCByZW1haW5zIHVucmVzcG9uc2l2ZS5gKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9LCA1MDAwKTsgLy8gNSBzZWNvbmQgdGltZW91dFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHN0dWNrIGV4ZWN1dGlvbiB3aXRoIGNvbmZpZ3VyYWJsZSBzdHJhdGVnaWVzXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV4ZWN1dGlvbklkIEV4ZWN1dGlvbiBJRCB0aGF0J3Mgc3R1Y2tcbiAgICogQHBhcmFtIGFjdHVhbFJ1bnRpbWUgSG93IGxvbmcgdGhlIGV4ZWN1dGlvbiBoYXMgYmVlbiBydW5uaW5nXG4gICAqIEBwYXJhbSBjb2RlIFRoZSBjb2RlIHRoYXQgd2FzIGJlaW5nIGV4ZWN1dGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVN0dWNrRXhlY3V0aW9uKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcsIGFjdHVhbFJ1bnRpbWU6IG51bWJlciwgY29kZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLndhcm4oYEhhbmRsaW5nIHN0dWNrIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtrZXJuZWxJZH0gKHJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tcylgKTtcbiAgICBcbiAgICAvLyBTdHJhdGVneSAxOiBUcnkgdG8gaW50ZXJydXB0IHRoZSBrZXJuZWwgZmlyc3RcbiAgICBjb25zdCBpbnRlcnJ1cHRTdWNjZXNzID0gYXdhaXQgdGhpcy5pbnRlcnJ1cHRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmIChpbnRlcnJ1cHRTdWNjZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGludGVycnVwdGVkIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGFuIGV4ZWN1dGlvbiBlcnJvciB0byBub3RpZnkgY2xpZW50c1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDoga2VybmVsSWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJFeGVjdXRpb25JbnRlcnJ1cHRlZFwiLFxuICAgICAgICAgIGV2YWx1ZTogYEV4ZWN1dGlvbiBhdXRvbWF0aWNhbGx5IGludGVycnVwdGVkIGFmdGVyICR7YWN0dWFsUnVudGltZX1tcyAoZXhjZWVkZWQgbWF4RXhlY3V0aW9uVGltZSlgLFxuICAgICAgICAgIHRyYWNlYmFjazogW1xuICAgICAgICAgICAgYEV4ZWN1dGlvbiB3YXMgYXV0b21hdGljYWxseSBpbnRlcnJ1cHRlZCBkdWUgdG8gdGltZW91dC5gLFxuICAgICAgICAgICAgYFJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tc2AsXG4gICAgICAgICAgICBgTWF4IGFsbG93ZWQ6ICR7aW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lfW1zYCxcbiAgICAgICAgICAgIGNvZGUgPyBgQ29kZTogJHtjb2RlLnN1YnN0cmluZygwLCAyMDApfSR7Y29kZS5sZW5ndGggPiAyMDAgPyAnLi4uJyA6ICcnfWAgOiAnQ29kZTogPHVua25vd24+J1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RyYXRlZ3kgMjogSWYgaW50ZXJydXB0IGZhaWxlZCwgdHJ5IHJlc3RhcnRpbmcgdGhlIGtlcm5lbFxuICAgIGNvbnNvbGUud2FybihgSW50ZXJydXB0IGZhaWxlZCBmb3Iga2VybmVsICR7a2VybmVsSWR9LCBhdHRlbXB0aW5nIHJlc3RhcnQuLi5gKTtcbiAgICBjb25zdCByZXN0YXJ0U3VjY2VzcyA9IGF3YWl0IHRoaXMucmVzdGFydEtlcm5lbChrZXJuZWxJZCk7XG4gICAgXG4gICAgaWYgKHJlc3RhcnRTdWNjZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHJlc3RhcnRlZCBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhIHJlc3RhcnQgbm90aWZpY2F0aW9uXG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgIGtlcm5lbElkOiBrZXJuZWxJZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktlcm5lbFJlc3RhcnRlZFwiLFxuICAgICAgICAgIGV2YWx1ZTogYEtlcm5lbCBhdXRvbWF0aWNhbGx5IHJlc3RhcnRlZCBkdWUgdG8gc3R1Y2sgZXhlY3V0aW9uIChydW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXMpYCxcbiAgICAgICAgICB0cmFjZWJhY2s6IFtcbiAgICAgICAgICAgIGBLZXJuZWwgd2FzIGF1dG9tYXRpY2FsbHkgcmVzdGFydGVkIGR1ZSB0byBzdHVjayBleGVjdXRpb24uYCxcbiAgICAgICAgICAgIGBSdW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXNgLFxuICAgICAgICAgICAgYE1heCBhbGxvd2VkOiAke2luc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZX1tc2AsXG4gICAgICAgICAgICBgSW50ZXJydXB0IGF0dGVtcHQgZmFpbGVkLCBrZXJuZWwgd2FzIHJlc3RhcnRlZCBpbnN0ZWFkLmAsXG4gICAgICAgICAgICBjb2RlID8gYENvZGU6ICR7Y29kZS5zdWJzdHJpbmcoMCwgMjAwKX0ke2NvZGUubGVuZ3RoID4gMjAwID8gJy4uLicgOiAnJ31gIDogJ0NvZGU6IDx1bmtub3duPidcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFN0cmF0ZWd5IDM6IElmIHJlc3RhcnQgZmFpbGVkLCBmb3JjZSB0ZXJtaW5hdGUgdGhlIGtlcm5lbFxuICAgIGNvbnNvbGUuZXJyb3IoYFJlc3RhcnQgZmFpbGVkIGZvciBrZXJuZWwgJHtrZXJuZWxJZH0sIGZvcmNlIHRlcm1pbmF0aW5nLi4uYCk7XG4gICAgY29uc3QgdGVybWluYXRlU3VjY2VzcyA9IGF3YWl0IHRoaXMuZm9yY2VUZXJtaW5hdGVLZXJuZWwoXG4gICAgICBrZXJuZWxJZCwgXG4gICAgICBgU3R1Y2sgZXhlY3V0aW9uIGNvdWxkIG5vdCBiZSBpbnRlcnJ1cHRlZCBvciByZXN0YXJ0ZWQgKHJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tcylgXG4gICAgKTtcbiAgICBcbiAgICBpZiAodGVybWluYXRlU3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSB0ZXJtaW5hdGVkIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdGVybWluYXRlIGtlcm5lbCAke2tlcm5lbElkfSAtIG1hbnVhbCBpbnRlcnZlbnRpb24gbWF5IGJlIHJlcXVpcmVkYCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYSBjcml0aWNhbCBlcnJvclxuICAgICAgc3VwZXIuZW1pdCgna2VybmVsX3VucmVjb3ZlcmFibGUnLCB7XG4gICAgICAgIGtlcm5lbElkOiBrZXJuZWxJZCxcbiAgICAgICAgZXhlY3V0aW9uSWQ6IGV4ZWN1dGlvbklkLFxuICAgICAgICBhY3R1YWxSdW50aW1lOiBhY3R1YWxSdW50aW1lLFxuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBtZXNzYWdlOiAnS2VybmVsIGlzIHN0dWNrIGFuZCBjb3VsZCBub3QgYmUgcmVjb3ZlcmVkIHRocm91Z2ggaW50ZXJydXB0LCByZXN0YXJ0LCBvciB0ZXJtaW5hdGlvbidcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgc3R1Y2sgZXhlY3V0aW9ucyBhY3Jvc3MgYWxsIGtlcm5lbHNcbiAgICogQHJldHVybnMgQXJyYXkgb2Ygc3R1Y2sgZXhlY3V0aW9uIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBnZXRTdHVja0V4ZWN1dGlvbnMoKTogQXJyYXk8e1xuICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBydW50aW1lOiBudW1iZXI7XG4gICAgbWF4QWxsb3dlZDogbnVtYmVyO1xuICAgIGNvZGU/OiBzdHJpbmc7XG4gICAga2VybmVsTW9kZTogS2VybmVsTW9kZTtcbiAgICBrZXJuZWxMYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+IHtcbiAgICBjb25zdCBzdHVja0V4ZWN1dGlvbnM6IEFycmF5PHtcbiAgICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgICBleGVjdXRpb25JZDogc3RyaW5nO1xuICAgICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgICBydW50aW1lOiBudW1iZXI7XG4gICAgICBtYXhBbGxvd2VkOiBudW1iZXI7XG4gICAgICBjb2RlPzogc3RyaW5nO1xuICAgICAga2VybmVsTW9kZTogS2VybmVsTW9kZTtcbiAgICAgIGtlcm5lbExhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgICB9PiA9IFtdO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtrZXJuZWxJZCwgaW5zdGFuY2VdIG9mIHRoaXMua2VybmVscy5lbnRyaWVzKCkpIHtcbiAgICAgIC8vIFNraXAgcG9vbCBrZXJuZWxzXG4gICAgICBpZiAoa2VybmVsSWQuc3RhcnRzV2l0aChcInBvb2wtXCIpKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBrZXJuZWxzIHdpdGhvdXQgbWF4RXhlY3V0aW9uVGltZSBjb25maWd1cmVkXG4gICAgICBpZiAoIWluc3RhbmNlLm9wdGlvbnM/Lm1heEV4ZWN1dGlvblRpbWUgfHwgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lIDw9IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1heEV4ZWN1dGlvblRpbWUgPSBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWU7XG4gICAgICBjb25zdCBzdGFydFRpbWVzID0gdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChrZXJuZWxJZCk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKTtcbiAgICAgIGNvbnN0IG9uZ29pbmdFeGVjcyA9IHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGtlcm5lbElkKTtcbiAgICAgIFxuICAgICAgaWYgKCFvbmdvaW5nRXhlY3MgfHwgb25nb2luZ0V4ZWNzLnNpemUgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZXhlY3V0aW9uSWQgb2Ygb25nb2luZ0V4ZWNzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0VGltZXM/LmdldChleGVjdXRpb25JZCk7XG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBydW50aW1lID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGV4ZWN1dGlvbiBpcyBzdHVja1xuICAgICAgICBpZiAocnVudGltZSA+IG1heEV4ZWN1dGlvblRpbWUpIHtcbiAgICAgICAgICBjb25zdCBleGVjTWV0YWRhdGEgPSBtZXRhZGF0YT8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdHVja0V4ZWN1dGlvbnMucHVzaCh7XG4gICAgICAgICAgICBrZXJuZWxJZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbklkLFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICAgIG1heEFsbG93ZWQ6IG1heEV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICBjb2RlOiBleGVjTWV0YWRhdGE/LmNvZGUsXG4gICAgICAgICAgICBrZXJuZWxNb2RlOiBpbnN0YW5jZS5tb2RlLFxuICAgICAgICAgICAga2VybmVsTGFuZ3VhZ2U6IGluc3RhbmNlLmxhbmd1YWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBieSBydW50aW1lIChsb25nZXN0IHJ1bm5pbmcgZmlyc3QpXG4gICAgc3R1Y2tFeGVjdXRpb25zLnNvcnQoKGEsIGIpID0+IGIucnVudGltZSAtIGEucnVudGltZSk7XG4gICAgXG4gICAgcmV0dXJuIHN0dWNrRXhlY3V0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSBpbnRlcnJ1cHQgYWxsIHN0dWNrIGV4ZWN1dGlvbnMgYWNyb3NzIGFsbCBrZXJuZWxzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIGludGVydmVudGlvbiByZXN1bHRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaGFuZGxlQWxsU3R1Y2tFeGVjdXRpb25zKCk6IFByb21pc2U8QXJyYXk8e1xuICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICBhY3Rpb246ICdpbnRlcnJ1cHRlZCcgfCAncmVzdGFydGVkJyB8ICd0ZXJtaW5hdGVkJyB8ICdmYWlsZWQnO1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gIH0+PiB7XG4gICAgY29uc3Qgc3R1Y2tFeGVjdXRpb25zID0gdGhpcy5nZXRTdHVja0V4ZWN1dGlvbnMoKTtcbiAgICBjb25zdCByZXN1bHRzOiBBcnJheTx7XG4gICAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICAgIGFjdGlvbjogJ2ludGVycnVwdGVkJyB8ICdyZXN0YXJ0ZWQnIHwgJ3Rlcm1pbmF0ZWQnIHwgJ2ZhaWxlZCc7XG4gICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtzdHVja0V4ZWN1dGlvbnMubGVuZ3RofSBzdHVjayBleGVjdXRpb25zIHRvIGhhbmRsZWApO1xuICAgIFxuICAgIC8vIEdyb3VwIGJ5IGtlcm5lbCB0byBhdm9pZCBtdWx0aXBsZSBpbnRlcnZlbnRpb25zIG9uIHRoZSBzYW1lIGtlcm5lbFxuICAgIGNvbnN0IGtlcm5lbEdyb3VwcyA9IG5ldyBNYXA8c3RyaW5nLCB0eXBlb2Ygc3R1Y2tFeGVjdXRpb25zPigpO1xuICAgIGZvciAoY29uc3QgZXhlYyBvZiBzdHVja0V4ZWN1dGlvbnMpIHtcbiAgICAgIGlmICgha2VybmVsR3JvdXBzLmhhcyhleGVjLmtlcm5lbElkKSkge1xuICAgICAgICBrZXJuZWxHcm91cHMuc2V0KGV4ZWMua2VybmVsSWQsIFtdKTtcbiAgICAgIH1cbiAgICAgIGtlcm5lbEdyb3Vwcy5nZXQoZXhlYy5rZXJuZWxJZCkhLnB1c2goZXhlYyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBlYWNoIGtlcm5lbCdzIHN0dWNrIGV4ZWN1dGlvbnNcbiAgICBmb3IgKGNvbnN0IFtrZXJuZWxJZCwgZXhlY3V0aW9uc10gb2Yga2VybmVsR3JvdXBzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBQaWNrIHRoZSBsb25nZXN0IHJ1bm5pbmcgZXhlY3V0aW9uIGFzIHRoZSBwcmltYXJ5IG9uZVxuICAgICAgICBjb25zdCBwcmltYXJ5RXhlYyA9IGV4ZWN1dGlvbnNbMF07IC8vIEFscmVhZHkgc29ydGVkIGJ5IHJ1bnRpbWUgZGVzY1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEhhbmRsaW5nIHN0dWNrIGtlcm5lbCAke2tlcm5lbElkfSB3aXRoICR7ZXhlY3V0aW9ucy5sZW5ndGh9IHN0dWNrIGV4ZWN1dGlvbnMgKHByaW1hcnk6ICR7cHJpbWFyeUV4ZWMucnVudGltZX1tcylgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSB0aGUgYXV0b21hdGVkIGhhbmRsaW5nIHN5c3RlbVxuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVN0dWNrRXhlY3V0aW9uKFxuICAgICAgICAgIGtlcm5lbElkLCBcbiAgICAgICAgICBwcmltYXJ5RXhlYy5leGVjdXRpb25JZCwgXG4gICAgICAgICAgcHJpbWFyeUV4ZWMucnVudGltZSwgXG4gICAgICAgICAgcHJpbWFyeUV4ZWMuY29kZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyayBhbGwgZXhlY3V0aW9ucyBmb3IgdGhpcyBrZXJuZWwgYXMgaGFuZGxlZFxuICAgICAgICBmb3IgKGNvbnN0IGV4ZWMgb2YgZXhlY3V0aW9ucykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBrZXJuZWxJZDogZXhlYy5rZXJuZWxJZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbklkOiBleGVjLmV4ZWN1dGlvbklkLFxuICAgICAgICAgICAgYWN0aW9uOiAnaW50ZXJydXB0ZWQnLCAvLyBXZSBkb24ndCBrbm93IHRoZSBleGFjdCBhY3Rpb24sIGJ1dCBpdCB3YXMgaGFuZGxlZFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaGFuZGxpbmcgc3R1Y2sgZXhlY3V0aW9ucyBmb3Iga2VybmVsICR7a2VybmVsSWR9OmAsIGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmsgYWxsIGV4ZWN1dGlvbnMgZm9yIHRoaXMga2VybmVsIGFzIGZhaWxlZFxuICAgICAgICBmb3IgKGNvbnN0IGV4ZWMgb2YgZXhlY3V0aW9ucykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBrZXJuZWxJZDogZXhlYy5rZXJuZWxJZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbklkOiBleGVjLmV4ZWN1dGlvbklkLFxuICAgICAgICAgICAgYWN0aW9uOiAnZmFpbGVkJyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBpbnRlcnJ1cHQgYnVmZmVyIGZvciBhIHdvcmtlciBrZXJuZWwgZHVyaW5nIGNyZWF0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHdvcmtlciBXb3JrZXIgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2V0dXBXb3JrZXJJbnRlcnJ1cHRCdWZmZXIoaWQ6IHN0cmluZywgd29ya2VyOiBXb3JrZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBTa2lwIFNoYXJlZEFycmF5QnVmZmVyIHNldHVwIGlmIG1vZGUgaXMgJ2tlcm5lbC1pbnRlcnJ1cHQnXG4gICAgaWYgKHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9PT0gJ2tlcm5lbC1pbnRlcnJ1cHQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU2tpcHBpbmcgU2hhcmVkQXJyYXlCdWZmZXIgc2V0dXAgZm9yIGtlcm5lbCAke2lkfSAtIHVzaW5nIGtlcm5lbC5pbnRlcnJ1cHQoKSBtb2RlYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBQeXRob24ga2VybmVscyBzdXBwb3J0IGludGVycnVwdCBidWZmZXJzXG4gICAgICBcbiAgICAgIC8vIEZvciBQeXRob24ga2VybmVscywgY3JlYXRlIGFjdHVhbCBTaGFyZWRBcnJheUJ1ZmZlclxuICAgICAgY29uc3Qgc2hhcmVkQnVmZmVyID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpO1xuICAgICAgY29uc3QgaW50ZXJydXB0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2hhcmVkQnVmZmVyKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBidWZmZXIgdG8gMCAobm8gaW50ZXJydXB0IHNpZ25hbClcbiAgICAgIGludGVycnVwdEJ1ZmZlclswXSA9IDA7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSBidWZmZXIgZm9yIGZ1dHVyZSB1c2VcbiAgICAgIHRoaXMuaW50ZXJydXB0QnVmZmVycy5zZXQoaWQsIGludGVycnVwdEJ1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgdGhlIGJ1ZmZlciB0byB0aGUgd29ya2VyIHRvIHNldCB1cCBweW9kaWRlLnNldEludGVycnVwdEJ1ZmZlcigpXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIlNFVF9JTlRFUlJVUFRfQlVGRkVSXCIsXG4gICAgICAgIGJ1ZmZlcjogaW50ZXJydXB0QnVmZmVyXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHdvcmtlciB0byBjb25maXJtIGJ1ZmZlciBzZXR1cFxuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXQgd2FpdGluZyBmb3IgaW50ZXJydXB0IGJ1ZmZlciBzZXR1cFwiKSk7XG4gICAgICAgIH0sIDUwMDApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiSU5URVJSVVBUX0JVRkZFUl9TRVRcIikge1xuICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEhhbmRsZSBiYXNlZCBvbiBpbnRlcnJ1cHRpb24gbW9kZVxuICAgICAgaWYgKHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9PT0gJ3NoYXJlZC1hcnJheS1idWZmZXInKSB7XG4gICAgICAgIC8vIElmIGV4cGxpY2l0bHkgc2V0IHRvIHNoYXJlZC1hcnJheS1idWZmZXIsIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIFNoYXJlZEFycmF5QnVmZmVyIHJlcXVpcmVkIGJ1dCBub3QgYXZhaWxhYmxlIGZvciBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFyZWRBcnJheUJ1ZmZlciBpcyByZXF1aXJlZCBidXQgbm90IGF2YWlsYWJsZS4gVG8gZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyLCB5b3VyIHNlcnZlciBtdXN0IHNldCB0aGVzZSBoZWFkZXJzOlxuLSBDcm9zcy1PcmlnaW4tT3BlbmVyLVBvbGljeTogc2FtZS1vcmlnaW5cbi0gQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeTogcmVxdWlyZS1jb3JwXG5cbkFsdGVybmF0aXZlbHksIHVzZSBpbnRlcnJ1cHRpb25Nb2RlOiAna2VybmVsLWludGVycnVwdCcgb3IgJ2F1dG8nIGluIEtlcm5lbE1hbmFnZXIgb3B0aW9ucy5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF1dG8gbW9kZTogZmFsbCBiYWNrIHRvIGtlcm5lbC5pbnRlcnJ1cHQoKVxuICAgICAgICBjb25zb2xlLmluZm8oYOKEue+4jyBTaGFyZWRBcnJheUJ1ZmZlciBub3QgYXZhaWxhYmxlIGZvciBrZXJuZWwgJHtpZH0uIFVzaW5nIGFsdGVybmF0aXZlIGludGVycnVwdCBtZXRob2QuXG5cblRvIGVuYWJsZSBmYXN0ZXIgaW50ZXJydXB0cywgY29uZmlndXJlIHlvdXIgc2VydmVyIHdpdGggdGhlc2UgaGVhZGVyczpcbi0gQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3k6IHNhbWUtb3JpZ2luXG4tIENyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3k6IHJlcXVpcmUtY29ycFxuXG5Ob3RlOiBTb21lIGRldmVsb3BtZW50IHNlcnZlcnMgKGUuZy4sIFZpdGUsIHdlYnBhY2stZGV2LXNlcnZlcikgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYWRkIHRoZXNlIGhlYWRlcnMuXG5UaGUgYWx0ZXJuYXRpdmUgaW50ZXJydXB0IG1ldGhvZCB3aWxsIHN0aWxsIHdvcmsgYnV0IG1heSBiZSBsZXNzIHJlc3BvbnNpdmUgZm9yIGxvbmctcnVubmluZyBjb2RlLmApO1xuICAgICAgICAvLyBEb24ndCB0aHJvdyAtIGtlcm5lbCBjYW4gc3RpbGwgd29yayB3aXRob3V0IGludGVycnVwdCBidWZmZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IG1vdW50ZWQgZmlsZXN5c3RlbXMgZm9yIGEgc3BlY2lmaWMga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgbW91bnRlZCBmaWxlc3lzdGVtIGluZm9cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRNb3VudGVkRmlsZVN5c3RlbXMoaWQ6IHN0cmluZyk6IFByb21pc2U8QXJyYXk8e1xuICAgIG1vdW50UGF0aDogc3RyaW5nO1xuICAgIHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnO1xuICAgIGNhblN5bmM6IGJvb2xlYW47XG4gIH0+PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5rZXJuZWwuZ2V0TW91bnRlZEZpbGVTeXN0ZW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5rZXJuZWwuZ2V0TW91bnRlZEZpbGVTeXN0ZW1zKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYEtlcm5lbCAke2lkfSBkb2VzIG5vdCBzdXBwb3J0IGdldE1vdW50ZWRGaWxlU3lzdGVtcyBtZXRob2RgKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nIG1vdW50ZWQgZmlsZXN5c3RlbXMgZm9yIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgc3luYyBhIHNwZWNpZmljIG1vdW50ZWQgZmlsZXN5c3RlbSBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gbW91bnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBtb3VudGVkIGZpbGVzeXN0ZW0gdG8gc3luY1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzeW5jIHJlc3VsdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bmNGaWxlU3lzdGVtKGlkOiBzdHJpbmcsIG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmtlcm5lbC5zeW5jRmlsZVN5c3RlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYXdhaXQgaW5zdGFuY2Uua2VybmVsLnN5bmNGaWxlU3lzdGVtKG1vdW50UGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYEtlcm5lbCAke2lkfSBkb2VzIG5vdCBzdXBwb3J0IHN5bmNGaWxlU3lzdGVtIG1ldGhvZGApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAnc3luY0ZpbGVTeXN0ZW0gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGtlcm5lbCdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc3luY2luZyBmaWxlc3lzdGVtIGZvciBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGUgYSBtb3VudGVkIGZpbGVzeXN0ZW0gZnJvbSByZWFkLW9ubHkgdG8gcmVhZC13cml0ZSBwZXJtaXNzaW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgbW91bnRlZCBmaWxlc3lzdGVtIHRvIHVwZ3JhZGVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdXBncmFkZSByZXN1bHRcbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24oaWQ6IHN0cmluZywgbW91bnRQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uua2VybmVsLnVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYXdhaXQgaW5zdGFuY2Uua2VybmVsLnVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbihtb3VudFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBLZXJuZWwgJHtpZH0gZG9lcyBub3Qgc3VwcG9ydCB1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gbWV0aG9kYCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICd1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGtlcm5lbCdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBncmFkaW5nIGZpbGVzeXN0ZW0gcGVybWlzc2lvbiBmb3Iga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/manager.ts\n\n}");

/***/ }),

/***/ "./src/pyodide-loader.ts":
/*!*******************************!*\
  !*** ./src/pyodide-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPyodide: () => (/* binding */ loadPyodide)\n/* harmony export */ });\n/* unused harmony exports isPyodideLoaded, getPyodideCDNUrl, getPyodideIndexUrl */\n/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise = null;\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript() {\n    return new Promise((resolve, reject) => {\n        // Check if script is already loaded\n        if (typeof globalThis.loadPyodide !== 'undefined') {\n            resolve();\n            return;\n        }\n        const script = document.createElement('script');\n        script.src = PYODIDE_CDN_URL;\n        script.onload = () => resolve();\n        script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n        document.head.appendChild(script);\n    });\n}\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker() {\n    return new Promise((resolve, reject) => {\n        try {\n            // Check if we're in a worker environment\n            if (typeof importScripts === 'undefined') {\n                reject(new Error('importScripts is not available - not in a worker context'));\n                return;\n            }\n            // Check if already loaded\n            if (typeof globalThis.loadPyodide !== 'undefined') {\n                resolve();\n                return;\n            }\n            importScripts(PYODIDE_CDN_URL);\n            resolve();\n        }\n        catch (error) {\n            reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n        }\n    });\n}\n/**\n * Initialize Pyodide with proper configuration\n */\nasync function loadPyodide(config = {}) {\n    // Return existing promise if already loading\n    if (pyodideLoadPromise) {\n        return pyodideLoadPromise;\n    }\n    pyodideLoadPromise = (async () => {\n        try {\n            // Determine if we're in a worker or main thread\n            const isWorker = typeof importScripts !== 'undefined';\n            // Load the Pyodide script\n            if (isWorker) {\n                await loadPyodideInWorker();\n            }\n            else {\n                await loadPyodideScript();\n            }\n            // Get the global loadPyodide function\n            const globalLoadPyodide = globalThis.loadPyodide;\n            if (!globalLoadPyodide) {\n                throw new Error('loadPyodide function not found after script load');\n            }\n            // Configure default options\n            const defaultConfig = {\n                indexURL: PYODIDE_INDEX_URL,\n                ...config\n            };\n            // Initialize Pyodide\n            const pyodide = await globalLoadPyodide(defaultConfig);\n            pyodideLoaded = true;\n            console.log('âœ… Pyodide loaded successfully from CDN');\n            return pyodide;\n        }\n        catch (error) {\n            pyodideLoadPromise = null; // Reset on failure\n            throw error;\n        }\n    })();\n    return pyodideLoadPromise;\n}\n/**\n * Check if Pyodide is already loaded\n */\nfunction isPyodideLoaded() {\n    return pyodideLoaded && typeof globalThis.loadPyodide !== 'undefined';\n}\n/**\n * Get Pyodide CDN URL for external use\n */\nfunction getPyodideCDNUrl() {\n    return PYODIDE_CDN_URL;\n}\n/**\n * Get Pyodide index URL for external use\n */\nfunction getPyodideIndexUrl() {\n    return PYODIDE_INDEX_URL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcHlvZGlkZS1sb2FkZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7R0FHRztBQUVILE1BQU0sZUFBZSxHQUFHLDBEQUEwRCxDQUFDO0FBQ25GLE1BQU0saUJBQWlCLEdBQUcsZ0RBQWdELENBQUM7QUFFM0UsNENBQTRDO0FBQzVDLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQztBQUMxQixJQUFJLGtCQUFrQixHQUF3QixJQUFJLENBQUM7QUFFbkQ7O0dBRUc7QUFDSCxTQUFTLGlCQUFpQjtJQUN4QixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQ3JDLG9DQUFvQztRQUNwQyxJQUFJLE9BQVEsVUFBa0IsQ0FBQyxXQUFXLEtBQUssV0FBVyxFQUFFLENBQUM7WUFDM0QsT0FBTyxFQUFFLENBQUM7WUFDVixPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEQsTUFBTSxDQUFDLEdBQUcsR0FBRyxlQUFlLENBQUM7UUFDN0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNoQyxNQUFNLENBQUMsT0FBTyxHQUFHLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQywrQkFBK0IsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzNGLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3BDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxtQkFBbUI7SUFDMUIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUNyQyxJQUFJLENBQUM7WUFDSCx5Q0FBeUM7WUFDekMsSUFBSSxPQUFPLGFBQWEsS0FBSyxXQUFXLEVBQUUsQ0FBQztnQkFDekMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUMsQ0FBQztnQkFDOUUsT0FBTztZQUNULENBQUM7WUFFRCwwQkFBMEI7WUFDMUIsSUFBSSxPQUFRLFVBQWtCLENBQUMsV0FBVyxLQUFLLFdBQVcsRUFBRSxDQUFDO2dCQUMzRCxPQUFPLEVBQUUsQ0FBQztnQkFDVixPQUFPO1lBQ1QsQ0FBQztZQUVELGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUMvQixPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLHVDQUF1QyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEUsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLFdBQVcsQ0FBQyxTQUFjLEVBQUU7SUFDaEQsNkNBQTZDO0lBQzdDLElBQUksa0JBQWtCLEVBQUUsQ0FBQztRQUN2QixPQUFPLGtCQUFrQixDQUFDO0lBQzVCLENBQUM7SUFFRCxrQkFBa0IsR0FBRyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQy9CLElBQUksQ0FBQztZQUNILGdEQUFnRDtZQUNoRCxNQUFNLFFBQVEsR0FBRyxPQUFPLGFBQWEsS0FBSyxXQUFXLENBQUM7WUFFdEQsMEJBQTBCO1lBQzFCLElBQUksUUFBUSxFQUFFLENBQUM7Z0JBQ2IsTUFBTSxtQkFBbUIsRUFBRSxDQUFDO1lBQzlCLENBQUM7aUJBQU0sQ0FBQztnQkFDTixNQUFNLGlCQUFpQixFQUFFLENBQUM7WUFDNUIsQ0FBQztZQUVELHNDQUFzQztZQUN0QyxNQUFNLGlCQUFpQixHQUFJLFVBQWtCLENBQUMsV0FBVyxDQUFDO1lBQzFELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2dCQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7WUFDdEUsQ0FBQztZQUVELDRCQUE0QjtZQUM1QixNQUFNLGFBQWEsR0FBRztnQkFDcEIsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsR0FBRyxNQUFNO2FBQ1YsQ0FBQztZQUVGLHFCQUFxQjtZQUNyQixNQUFNLE9BQU8sR0FBRyxNQUFNLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZELGFBQWEsR0FBRyxJQUFJLENBQUM7WUFFckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2Ysa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUMsbUJBQW1CO1lBQzlDLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRDs7R0FFRztBQUNJLFNBQVMsZUFBZTtJQUM3QixPQUFPLGFBQWEsSUFBSSxPQUFRLFVBQWtCLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FBQztBQUNqRixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGdCQUFnQjtJQUM5QixPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGtCQUFrQjtJQUNoQyxPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9zcmMvcHlvZGlkZS1sb2FkZXIudHM/NTAxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFB5b2RpZGUgQ0ROIExvYWRlciBVdGlsaXR5XG4gKiBEeW5hbWljYWxseSBsb2FkcyBQeW9kaWRlIGZyb20gQ0ROIGZvciBib3RoIG1haW4gdGhyZWFkIGFuZCB3ZWIgd29ya2Vyc1xuICovXG5cbmNvbnN0IFBZT0RJREVfQ0ROX1VSTCA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvcHlvZGlkZS92MC4yOC4wL2Z1bGwvcHlvZGlkZS5qcyc7XG5jb25zdCBQWU9ESURFX0lOREVYX1VSTCA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvcHlvZGlkZS92MC4yOC4wL2Z1bGwvJztcblxuLy8gR2xvYmFsIGZsYWcgdG8gdHJhY2sgaWYgUHlvZGlkZSBpcyBsb2FkZWRcbmxldCBweW9kaWRlTG9hZGVkID0gZmFsc2U7XG5sZXQgcHlvZGlkZUxvYWRQcm9taXNlOiBQcm9taXNlPGFueT4gfCBudWxsID0gbnVsbDtcblxuLyoqXG4gKiBMb2FkIFB5b2RpZGUgc2NyaXB0IGR5bmFtaWNhbGx5IGluIG1haW4gdGhyZWFkXG4gKi9cbmZ1bmN0aW9uIGxvYWRQeW9kaWRlU2NyaXB0KCk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIENoZWNrIGlmIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgIGlmICh0eXBlb2YgKGdsb2JhbFRoaXMgYXMgYW55KS5sb2FkUHlvZGlkZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQuc3JjID0gUFlPRElERV9DRE5fVVJMO1xuICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBQeW9kaWRlIGZyb20gJHtQWU9ESURFX0NETl9VUkx9YCkpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogTG9hZCBQeW9kaWRlIGluIHdlYiB3b3JrZXIgdXNpbmcgaW1wb3J0U2NyaXB0c1xuICovXG5mdW5jdGlvbiBsb2FkUHlvZGlkZUluV29ya2VyKCk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBhIHdvcmtlciBlbnZpcm9ubWVudFxuICAgICAgaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdpbXBvcnRTY3JpcHRzIGlzIG5vdCBhdmFpbGFibGUgLSBub3QgaW4gYSB3b3JrZXIgY29udGV4dCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGxvYWRlZFxuICAgICAgaWYgKHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW1wb3J0U2NyaXB0cyhQWU9ESURFX0NETl9VUkwpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gaW1wb3J0IFB5b2RpZGUgaW4gd29ya2VyOiAke2Vycm9yfWApKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgUHlvZGlkZSB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUHlvZGlkZShjb25maWc6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gUmV0dXJuIGV4aXN0aW5nIHByb21pc2UgaWYgYWxyZWFkeSBsb2FkaW5nXG4gIGlmIChweW9kaWRlTG9hZFByb21pc2UpIHtcbiAgICByZXR1cm4gcHlvZGlkZUxvYWRQcm9taXNlO1xuICB9XG5cbiAgcHlvZGlkZUxvYWRQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlJ3JlIGluIGEgd29ya2VyIG9yIG1haW4gdGhyZWFkXG4gICAgICBjb25zdCBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJztcbiAgICAgIFxuICAgICAgLy8gTG9hZCB0aGUgUHlvZGlkZSBzY3JpcHRcbiAgICAgIGlmIChpc1dvcmtlcikge1xuICAgICAgICBhd2FpdCBsb2FkUHlvZGlkZUluV29ya2VyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBsb2FkUHlvZGlkZVNjcmlwdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIGdsb2JhbCBsb2FkUHlvZGlkZSBmdW5jdGlvblxuICAgICAgY29uc3QgZ2xvYmFsTG9hZFB5b2RpZGUgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlO1xuICAgICAgaWYgKCFnbG9iYWxMb2FkUHlvZGlkZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvYWRQeW9kaWRlIGZ1bmN0aW9uIG5vdCBmb3VuZCBhZnRlciBzY3JpcHQgbG9hZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25maWd1cmUgZGVmYXVsdCBvcHRpb25zXG4gICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICBpbmRleFVSTDogUFlPRElERV9JTkRFWF9VUkwsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBQeW9kaWRlXG4gICAgICBjb25zdCBweW9kaWRlID0gYXdhaXQgZ2xvYmFsTG9hZFB5b2RpZGUoZGVmYXVsdENvbmZpZyk7XG4gICAgICBweW9kaWRlTG9hZGVkID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBQeW9kaWRlIGxvYWRlZCBzdWNjZXNzZnVsbHkgZnJvbSBDRE4nKTtcbiAgICAgIHJldHVybiBweW9kaWRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBweW9kaWRlTG9hZFByb21pc2UgPSBudWxsOyAvLyBSZXNldCBvbiBmYWlsdXJlXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHB5b2RpZGVMb2FkUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBQeW9kaWRlIGlzIGFscmVhZHkgbG9hZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1B5b2RpZGVMb2FkZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBweW9kaWRlTG9hZGVkICYmIHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBHZXQgUHlvZGlkZSBDRE4gVVJMIGZvciBleHRlcm5hbCB1c2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB5b2RpZGVDRE5VcmwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIFBZT0RJREVfQ0ROX1VSTDtcbn1cblxuLyoqXG4gKiBHZXQgUHlvZGlkZSBpbmRleCBVUkwgZm9yIGV4dGVybmFsIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHlvZGlkZUluZGV4VXJsKCk6IHN0cmluZyB7XG4gIHJldHVybiBQWU9ESURFX0lOREVYX1VSTDtcbn0gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pyodide-loader.ts\n\n}");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelEvents: () => (/* binding */ KernelEvents)\n/* harmony export */ });\n// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n// Events enum\nvar KernelEvents;\n(function (KernelEvents) {\n    // IOPub Channel Messages\n    KernelEvents[\"STREAM\"] = \"stream\";\n    KernelEvents[\"DISPLAY_DATA\"] = \"display_data\";\n    KernelEvents[\"UPDATE_DISPLAY_DATA\"] = \"update_display_data\";\n    KernelEvents[\"EXECUTE_RESULT\"] = \"execute_result\";\n    KernelEvents[\"EXECUTE_ERROR\"] = \"execute_error\";\n    KernelEvents[\"EXECUTE_REQUEST\"] = \"execute_request\";\n    // Input request\n    KernelEvents[\"INPUT_REQUEST\"] = \"input_request\";\n    // Output control\n    KernelEvents[\"CLEAR_OUTPUT\"] = \"clear_output\";\n    // Comm messages\n    KernelEvents[\"COMM_OPEN\"] = \"comm_open\";\n    KernelEvents[\"COMM_MSG\"] = \"comm_msg\";\n    KernelEvents[\"COMM_CLOSE\"] = \"comm_close\";\n    // Internal Events\n    KernelEvents[\"KERNEL_READY\"] = \"kernel_ready\";\n    KernelEvents[\"KERNEL_BUSY\"] = \"kernel_busy\";\n    KernelEvents[\"KERNEL_IDLE\"] = \"kernel_idle\";\n    // Special catchall for internal use\n    KernelEvents[\"ALL\"] = \"*\";\n    // Execution monitoring events\n    KernelEvents[\"EXECUTION_STALLED\"] = \"execution_stalled\";\n    // Enhanced stuck kernel handling events\n    KernelEvents[\"KERNEL_UNRECOVERABLE\"] = \"kernel_unrecoverable\";\n    KernelEvents[\"EXECUTION_INTERRUPTED\"] = \"execution_interrupted\";\n    KernelEvents[\"KERNEL_RESTARTED\"] = \"kernel_restarted\";\n    KernelEvents[\"KERNEL_TERMINATED\"] = \"kernel_terminated\";\n})(KernelEvents || (KernelEvents = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0RBQStEO0FBQy9ELHFFQUFxRTtBQUVyRSxjQUFjO0FBQ2QsSUFBWSxZQW9DWDtBQXBDRCxXQUFZLFlBQVk7SUFDdEIseUJBQXlCO0lBQ3pCLGlDQUFpQjtJQUNqQiw2Q0FBNkI7SUFDN0IsMkRBQTJDO0lBQzNDLGlEQUFpQztJQUNqQywrQ0FBK0I7SUFDL0IsbURBQW1DO0lBRW5DLGdCQUFnQjtJQUNoQiwrQ0FBK0I7SUFFL0IsaUJBQWlCO0lBQ2pCLDZDQUE2QjtJQUU3QixnQkFBZ0I7SUFDaEIsdUNBQXVCO0lBQ3ZCLHFDQUFxQjtJQUNyQix5Q0FBeUI7SUFFekIsa0JBQWtCO0lBQ2xCLDZDQUE2QjtJQUM3QiwyQ0FBMkI7SUFDM0IsMkNBQTJCO0lBRTNCLG9DQUFvQztJQUNwQyx5QkFBUztJQUVULDhCQUE4QjtJQUM5Qix1REFBdUM7SUFFdkMsd0NBQXdDO0lBQ3hDLDZEQUE2QztJQUM3QywrREFBK0M7SUFDL0MscURBQXFDO0lBQ3JDLHVEQUF1QztBQUN6QyxDQUFDLEVBcENXLFlBQVksS0FBWixZQUFZLFFBb0N2QiIsInNvdXJjZXMiOlsid2VicGFjazovL1dlYlB5dGhvbktlcm5lbC8uL3NyYy90eXBlcy50cz9hNzZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNoYXJlZCB0eXBlcyBhbmQgaW50ZXJmYWNlcyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuLy8gVGhlc2UgYXJlIGV4dHJhY3RlZCBmcm9tIGluZGV4LnRzIHRvIGJyZWFrIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cbi8vIEV2ZW50cyBlbnVtXG5leHBvcnQgZW51bSBLZXJuZWxFdmVudHMge1xuICAvLyBJT1B1YiBDaGFubmVsIE1lc3NhZ2VzXG4gIFNUUkVBTSA9IFwic3RyZWFtXCIsXG4gIERJU1BMQVlfREFUQSA9IFwiZGlzcGxheV9kYXRhXCIsXG4gIFVQREFURV9ESVNQTEFZX0RBVEEgPSBcInVwZGF0ZV9kaXNwbGF5X2RhdGFcIixcbiAgRVhFQ1VURV9SRVNVTFQgPSBcImV4ZWN1dGVfcmVzdWx0XCIsXG4gIEVYRUNVVEVfRVJST1IgPSBcImV4ZWN1dGVfZXJyb3JcIixcbiAgRVhFQ1VURV9SRVFVRVNUID0gXCJleGVjdXRlX3JlcXVlc3RcIixcbiAgXG4gIC8vIElucHV0IHJlcXVlc3RcbiAgSU5QVVRfUkVRVUVTVCA9IFwiaW5wdXRfcmVxdWVzdFwiLFxuICBcbiAgLy8gT3V0cHV0IGNvbnRyb2xcbiAgQ0xFQVJfT1VUUFVUID0gXCJjbGVhcl9vdXRwdXRcIixcbiAgXG4gIC8vIENvbW0gbWVzc2FnZXNcbiAgQ09NTV9PUEVOID0gXCJjb21tX29wZW5cIixcbiAgQ09NTV9NU0cgPSBcImNvbW1fbXNnXCIsXG4gIENPTU1fQ0xPU0UgPSBcImNvbW1fY2xvc2VcIixcbiAgXG4gIC8vIEludGVybmFsIEV2ZW50c1xuICBLRVJORUxfUkVBRFkgPSBcImtlcm5lbF9yZWFkeVwiLFxuICBLRVJORUxfQlVTWSA9IFwia2VybmVsX2J1c3lcIixcbiAgS0VSTkVMX0lETEUgPSBcImtlcm5lbF9pZGxlXCIsXG4gIFxuICAvLyBTcGVjaWFsIGNhdGNoYWxsIGZvciBpbnRlcm5hbCB1c2VcbiAgQUxMID0gXCIqXCIsIC8vIFdpbGRjYXJkIGV2ZW50IHR5cGVcbiAgXG4gIC8vIEV4ZWN1dGlvbiBtb25pdG9yaW5nIGV2ZW50c1xuICBFWEVDVVRJT05fU1RBTExFRCA9IFwiZXhlY3V0aW9uX3N0YWxsZWRcIixcbiAgXG4gIC8vIEVuaGFuY2VkIHN0dWNrIGtlcm5lbCBoYW5kbGluZyBldmVudHNcbiAgS0VSTkVMX1VOUkVDT1ZFUkFCTEUgPSBcImtlcm5lbF91bnJlY292ZXJhYmxlXCIsXG4gIEVYRUNVVElPTl9JTlRFUlJVUFRFRCA9IFwiZXhlY3V0aW9uX2ludGVycnVwdGVkXCIsXG4gIEtFUk5FTF9SRVNUQVJURUQgPSBcImtlcm5lbF9yZXN0YXJ0ZWRcIixcbiAgS0VSTkVMX1RFUk1JTkFURUQgPSBcImtlcm5lbF90ZXJtaW5hdGVkXCJcbn1cblxuLy8gRXZlbnRFbWl0dGVyIGludGVyZmFjZSBmb3IgdHlwaW5nXG5leHBvcnQgaW50ZXJmYWNlIElFdmVudEVtaXR0ZXIge1xuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKTogdm9pZDtcbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pOiB2b2lkO1xuICBlbWl0KGV2ZW50TmFtZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG4gIHNldE1heExpc3RlbmVycyhuOiBudW1iZXIpOiB2b2lkO1xufVxuXG4vLyBGaWxlU3lzdGVtIG1vdW50IG9wdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgcm9vdD86IHN0cmluZztcbiAgbW91bnRQb2ludD86IHN0cmluZztcbn1cblxuLy8gS2VybmVsIG9wdGlvbnMgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxPcHRpb25zIHtcbiAgZmlsZXN5c3RlbT86IElGaWxlU3lzdGVtTW91bnRPcHRpb25zO1xuICBlbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+OyAvLyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gc2V0IGluIHRoZSBrZXJuZWxcbiAgbG9ja0ZpbGVVUkw/OiBzdHJpbmc7IC8vIFVSTCB0byBweW9kaWRlLWxvY2suanNvbiBmaWxlIGZvciBmYXN0ZXIgbG9hZGluZ1xuICBhdXRvU3luY0ZzPzogYm9vbGVhbjsgLy8gQXV0b21hdGljYWxseSBzeW5jIG5hdGl2ZSBmaWxlc3lzdGVtIGFmdGVyIGNvZGUgZXhlY3V0aW9uIChkZWZhdWx0OiBmYWxzZSlcbn1cblxuLy8gTmF0aXZlIGZpbGVzeXN0ZW0gaGFuZGxlIHR5cGVcbmV4cG9ydCBpbnRlcmZhY2UgSU5hdGl2ZUZTSGFuZGxlIHtcbiAgc3luY2ZzKCk6IFByb21pc2U8dm9pZD47XG59XG5cbi8vIEtlcm5lbCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbCBleHRlbmRzIElFdmVudEVtaXR0ZXIge1xuICBpbml0aWFsaXplKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG4gIGV4ZWN1dGUoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0+O1xuICBleGVjdXRlU3RyZWFtPyhjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSk6IEFzeW5jR2VuZXJhdG9yPGFueSwgeyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfSwgdm9pZD47XG4gIGlzSW5pdGlhbGl6ZWQoKTogYm9vbGVhbjtcbiAgaW5wdXRSZXBseShjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD47XG4gIGdldFN0YXR1cygpOiBQcm9taXNlPFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiPjtcblxuICAvLyBJbnRlcnJ1cHQgZnVuY3Rpb25hbGl0eVxuICBpbnRlcnJ1cHQ/KCk6IFByb21pc2U8Ym9vbGVhbj47XG4gIHNldEludGVycnVwdEJ1ZmZlcj8oYnVmZmVyOiBVaW50OEFycmF5KTogdm9pZDtcblxuICAvLyBOYXRpdmUgZmlsZXN5c3RlbSBtb3VudGluZ1xuICBtb3VudEZTPyhtb3VudFBhdGg6IHN0cmluZywgZGlySGFuZGxlPzogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8IG51bGwsIHBlcm1pc3Npb24/OiAncmVhZCcgfCAncmVhZHdyaXRlJyk6IFByb21pc2U8SU5hdGl2ZUZTSGFuZGxlPjtcbiAgZ2V0TW91bnRlZEZpbGVTeXN0ZW1zPygpOiBBcnJheTx7IG1vdW50UGF0aDogc3RyaW5nOyBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJzsgY2FuU3luYzogYm9vbGVhbjsgfT47XG4gIHN5bmNGaWxlU3lzdGVtPyhtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PjtcbiAgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uPyhtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PjtcblxuICAvLyBPcHRpb25hbCBtZXRob2RzXG4gIGNvbXBsZXRlPyhjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBpbnNwZWN0Pyhjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgZGV0YWlsX2xldmVsOiAwIHwgMSwgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBpc0NvbXBsZXRlPyhjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgY29tbUluZm8/KHRhcmdldF9uYW1lOiBzdHJpbmcgfCBudWxsLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGNvbW1PcGVuPyhjb250ZW50OiBhbnksIHBhcmVudD86IGFueSk6IFByb21pc2U8dm9pZD47XG4gIGNvbW1Nc2c/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbiAgY29tbUNsb3NlPyhjb250ZW50OiBhbnksIHBhcmVudD86IGFueSk6IFByb21pc2U8dm9pZD47XG59XG5cbi8vIEV4ZWN1dGUgb3B0aW9ucyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbEV4ZWN1dGVPcHRpb25zIHtcbiAgY29kZTogc3RyaW5nO1xuICBzaWxlbnQ/OiBib29sZWFuO1xuICBzdG9yZUhpc3Rvcnk/OiBib29sZWFuO1xufVxuXG4vLyBNZXNzYWdlIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJTWVzc2FnZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgYnVuZGxlPzogYW55O1xuICBjb250ZW50PzogYW55O1xuICBtZXRhZGF0YT86IGFueTtcbiAgcGFyZW50SGVhZGVyPzogYW55O1xuICBidWZmZXJzPzogYW55O1xuICBpZGVudD86IGFueTtcbn1cblxuLy8gRXZlbnQgZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50RGF0YSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGF0YTogYW55O1xufSAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/types.ts\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});